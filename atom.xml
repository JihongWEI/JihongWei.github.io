<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>三鹿伴我长大&#39;s blog</title>
  
  <subtitle>纠正错误的方式有很多，而解决一个错误的终极办法就是不让它发生</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jihong.xyz/"/>
  <updated>2018-03-04T11:51:36.591Z</updated>
  <id>http://jihong.xyz/</id>
  
  <author>
    <name>JihongWei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>区块链科技的一些遐想</title>
    <link href="http://jihong.xyz/programer/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%A7%91%E6%8A%80%E7%9A%84%E4%B8%80%E4%BA%9B%E9%81%90%E6%83%B3/"/>
    <id>http://jihong.xyz/programer/区块链科技的一些遐想/</id>
    <published>2018-01-19T05:36:52.000Z</published>
    <updated>2018-03-04T11:51:36.591Z</updated>
    
    <content type="html"><![CDATA[<p>前乔治亚理工大学研究技术史教授Melvin Kranzberg（已故）曾经在30年前提出过6条技术定理，虽然这些定律基于并验证与冷战时期发生的一系列技术变革和革新，但同样适用于今日之日新月异的技术突飞猛进的技术时代。</p><p>对此6条定律，我个人称之为科技哲学：</p><blockquote><ol><li>技术不好也不坏；也不是中性的。</li><li>发明是需求之母。</li><li>技术都是成套出现，或大或小。</li><li>虽然技术可能是引发诸多公共问题的主因，但非技术因素在技术政策决定中占据主导。</li><li>历史相关性普遍存在，但技术的历史相关性最强。</li><li>技术是深受人为因素影响的一种活动。</li></ol></blockquote><p>而对今日炙手可热的区块链概念或者技术，如果用科技哲学的视角观察，也许是最好不过的“冷眼旁观”。<br><a id="more"></a><br>区块链脱胎于中本聪发明的比特币，这个神秘的中本聪发出的第一块区块被称为“创世纪区块”，有人用圣经里的这句话形容，“神说要有光，于是便有了光”。“光”，是相对于黑暗环境的。</p><p>我不知道中本聪发明的本意是什么？但现实世界如果有人出来冒充说自己就是中本聪本人时，中本聪本人就会跳出来指证，“非也，人人都是中本聪！” 。中本聪所说的“人人都是中本聪”，就是区块链的核心特性之一：去中心化。</p><p>这个星球中心化组织形式实在太长了，除了原始社会组织结构形态，漫长的历史无不处在中心化的组织框架统治之内。中心化，也就是集权化，被代表化；去中心化，我不知道这是不是民主的一种形式，按照现代文明的定义，区块化的这种形态应该不算是一种民主。那么它应该是一种什么形态那？自组织？自组织结构形态目前只存在于小型化组织或实验化行为和柏拉图的《理想国》之中，当代人类文明事实上是无法承载“白蚁型”共识主动性自组织结构形态的。</p><h2 id="所以，区块链在中国民间的大火大热，而政府的冷处理态度，这其实不是一个技术问题，是一个政治问题，是一场民主博弈，“究竟是少数代表多数-目前的法币政策-还是多数即正义-全球分布式共识网络，也即区块链-”的博弈。这正如开头引用-Melvin-Kranzberg-教授的科技定律之一，“虽然技术可能是引发诸多公共问题的主因，但非技术因素在技术政策决定中占据主导。”"><a href="#所以，区块链在中国民间的大火大热，而政府的冷处理态度，这其实不是一个技术问题，是一个政治问题，是一场民主博弈，“究竟是少数代表多数-目前的法币政策-还是多数即正义-全球分布式共识网络，也即区块链-”的博弈。这正如开头引用-Melvin-Kranzberg-教授的科技定律之一，“虽然技术可能是引发诸多公共问题的主因，但非技术因素在技术政策决定中占据主导。”" class="headerlink" title="所以，区块链在中国民间的大火大热，而政府的冷处理态度，这其实不是一个技术问题，是一个政治问题，是一场民主博弈，“究竟是少数代表多数(目前的法币政策)还是多数即正义(全球分布式共识网络，也即区块链)”的博弈。这正如开头引用 Melvin Kranzberg 教授的科技定律之一，“虽然技术可能是引发诸多公共问题的主因，但非技术因素在技术政策决定中占据主导。”"></a>所以，区块链在中国民间的大火大热，而政府的冷处理态度，这其实不是一个技术问题，是一个政治问题，是一场民主博弈，“究竟是少数代表多数(目前的法币政策)还是多数即正义(全球分布式共识网络，也即区块链)”的博弈。这正如开头引用 Melvin Kranzberg 教授的科技定律之一，“<strong>虽然技术可能是引发诸多公共问题的主因，但非技术因素在技术政策决定中占据主导。</strong>”</h2><h2 id="什么是区块链"><a href="#什么是区块链" class="headerlink" title="什么是区块链"></a>什么是区块链</h2><p>先看一个通俗的例子：</p><blockquote><p>例如，你们家里有个账本，让你来记账。在以前，就是爸爸妈妈把工资交给你，让你记到账本上。中间万一你贪吃，想买点好吃的，可能账本上的记录会少十几块，然后你想买个手机，账本上就少记录几千块。但有了分布式账本后，这些问题就不会有了，因为你在记账，你爸爸也在记账，你妈妈也在记账，他们都能看到总账，你不能改，爸爸妈妈也不能改，这样想买烟抽的爸爸和想贪吃的你都没办法啦。</p></blockquote><p>上面提到的分布式账本，就是区块链的而核心。</p><p>区块链是比特币所使用的底层技术，后来被抽离出来作为系统层面的开源技术或者框架，它本质是一个互相验证的去中心化的公开分布式记账系统。这个系统所做的事情，就是记录所有账户发生的所有交易。每个账号的每笔数额变化都会被记录在全网总账本中。其本身是一系列使用密码学而产生的互相关联的数据块，每一个数据块中包含了多条经比特币的网络交易有效确认的信息。</p><h3 id="区块链三大特点："><a href="#区块链三大特点：" class="headerlink" title="区块链三大特点："></a>区块链三大特点：</h3><ul><li>是一个分布式账本</li><li>是一个可编程性开源的技术</li><li>是一个基于共识在机器之间建立信任并完成信用创造。</li><li>是一种去中心化的自组织（个人观点）。<br><strong>《经济学人》杂志这样写道：</strong><blockquote><p>区块链是一台创造信任的机器，可以说区块链最核心的问题就是解决信用共识的问题。</p></blockquote></li></ul><h3 id="区块链发展阶段："><a href="#区块链发展阶段：" class="headerlink" title="区块链发展阶段："></a>区块链发展阶段：</h3><ul><li>比特币阶段</li><li>区块链+金融阶段 （2017年）</li><li>区块链+其它行业（2018年）</li><li>区块链+社会（未来）（个人观点）<br>区块链技术其核心特点之一就是其去中心化的自组织，所以其社会意义比技术意义更值得研究。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前乔治亚理工大学研究技术史教授Melvin Kranzberg（已故）曾经在30年前提出过6条技术定理，虽然这些定律基于并验证与冷战时期发生的一系列技术变革和革新，但同样适用于今日之日新月异的技术突飞猛进的技术时代。&lt;/p&gt;
&lt;p&gt;对此6条定律，我个人称之为科技哲学：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;技术不好也不坏；也不是中性的。&lt;/li&gt;
&lt;li&gt;发明是需求之母。&lt;/li&gt;
&lt;li&gt;技术都是成套出现，或大或小。&lt;/li&gt;
&lt;li&gt;虽然技术可能是引发诸多公共问题的主因，但非技术因素在技术政策决定中占据主导。&lt;/li&gt;
&lt;li&gt;历史相关性普遍存在，但技术的历史相关性最强。&lt;/li&gt;
&lt;li&gt;技术是深受人为因素影响的一种活动。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;而对今日炙手可热的区块链概念或者技术，如果用科技哲学的视角观察，也许是最好不过的“冷眼旁观”。&lt;br&gt;
    
    </summary>
    
      <category term="程序员的那些事" scheme="http://jihong.xyz/categories/programer/"/>
    
    
      <category term="碎片" scheme="http://jihong.xyz/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>一个优秀的代理工具应该具备的要素</title>
    <link href="http://jihong.xyz/security/%E4%B8%80%E4%B8%AA%E4%BC%98%E7%A7%80%E7%9A%84%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7%E5%BA%94%E8%AF%A5%E5%85%B7%E5%A4%87%E7%9A%84%E8%A6%81%E7%B4%A0/"/>
    <id>http://jihong.xyz/security/一个优秀的代理工具应该具备的要素/</id>
    <published>2017-12-31T09:34:15.000Z</published>
    <updated>2018-03-04T11:51:25.238Z</updated>
    
    <content type="html"><![CDATA[<p>在当今的网络环境中，我们大多数时候都需要一个代理工具，以便能实现一些特殊的需求。</p><p>首先，我们来设定一个概念：一个代理协议可能具备的三要素。</p><p>一、传输：能在 A、B 两个主机之间建立一条安全可靠信道，用于传输数据；<br>二、协议：对于将要传输的数据，能将这些数据的目的地告知代理服务器；<br>三、内容：可以对传输的数据进行优化，例如压缩、合并等。</p><p>任何一个优秀的代理协议都具备以上三要素中的几个或全部。<br><a id="more"></a><br>文字可能较难理解，我们来举一个简单的例子：Socks 协议。Socks 只具备协议要素，即告知代理服务器要把数据发送到哪里去，以达到代理的目的。但众所周知单纯的 Socks 不具备翻越防火墙能力，因为它不能建立可靠的通道。于是就出现了 Shadowsocks。Shadowsocks 在 Socks 的基础上增加了传输要素，对数据加了密，使防火墙无法分析其具体内容。而 Shadowsocks 不具备内容要素，因为对于客户端的发来的内容，Shadowsocks 不进行任何修改，而是直接发送给了代理服务器。</p><p>在翻越防火墙过程中，我们可能会使用几个协议的组合，比如 Shadowsocks + KcpTun。无论我们怎么组合，所产生的结果，必须包含传输要素和协议要素，才可以进行可靠的翻墙。</p><p>为什么不能单独使用 KcpTun 来翻墙，因为 KcpTun 只有传输+内容要素。KcpTun 只能建立连接，对内容进行一定的处理，比如加密以及其内置的 mux 模式。但它不能发送数据的实际目的地，导致了一定要再套一个其它协议才可以用于翻墙。</p><p>而在 Shadowsocks (传输+协议) + KcpTun (传输+内容) 的场景中，由于两者都有传输要素，重复了，以至于 Shadowsocks 的加密在这个场景中多余。因为 KcpTun 已经有加密了，Shadowsocks 再多加一层也没用。</p><p>这也就是 ShadowsocksR 在最停更前所开发的几个协议推荐使用不加密的原因。</p><p>ShadowsocksR 本质上是对 Shadowsocks 进行了一层封装，即 Shadowsocks + X。这个 X 包含了对协议要素的扩（单端口多用户多种加密方式），加强了传输要素（伪装和其它的加密方式）。和 Shadowsocks + KcpTun 同理，Shadowsocks 本身的传输要素就显得不那么重要了。</p><p>而 Shadowsocks 最近也加强了传输要素，即 obfs plugin。两者在要素这一层面相差无几，这也是为什么很多人不认为 ShadowsocksR 之于 Shadowsocks 有很大改进的原因。</p><p>当然，一个翻墙协议的效率和它具备几个要素没有半点关系。以上这些内容只是想要阐明每个翻墙协议的侧重点，哪些组合是有意义的，哪些是没有意义的。一个协议组合首先要有意义，其次才能探讨它的效率。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在当今的网络环境中，我们大多数时候都需要一个代理工具，以便能实现一些特殊的需求。&lt;/p&gt;
&lt;p&gt;首先，我们来设定一个概念：一个代理协议可能具备的三要素。&lt;/p&gt;
&lt;p&gt;一、传输：能在 A、B 两个主机之间建立一条安全可靠信道，用于传输数据；&lt;br&gt;二、协议：对于将要传输的数据，能将这些数据的目的地告知代理服务器；&lt;br&gt;三、内容：可以对传输的数据进行优化，例如压缩、合并等。&lt;/p&gt;
&lt;p&gt;任何一个优秀的代理协议都具备以上三要素中的几个或全部。&lt;br&gt;
    
    </summary>
    
      <category term="安全" scheme="http://jihong.xyz/categories/security/"/>
    
    
      <category term="碎片" scheme="http://jihong.xyz/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>计组实验 - perflab-handout</title>
    <link href="http://jihong.xyz/computer-principle/%E8%AE%A1%E7%BB%84%E5%AE%9E%E9%AA%8C%20-%20perflab-handout/"/>
    <id>http://jihong.xyz/computer-principle/计组实验 - perflab-handout/</id>
    <published>2016-12-02T10:45:48.000Z</published>
    <updated>2018-03-04T07:42:27.379Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>kernel.c文件中主要有两个需要进行优化的函数：rotate和smooth，并分别给出了naive_rotate和naive_smooth两个函数的基本实现作为baseline作为你改进后的程序的比较对象。你需要读懂rotate和smooth函数，并对其进行优化。你每写一个新版本的、优化的rotate和smooth函数，均可在成注册后使用driver进行测试，并得到对应的CPE和加速比。本次实验，要求针对每个函数、每个人均至少写出3种优化版本、并根据driver报告的结果进行性能分析。 </p><h3 id="优化rotate函数"><a href="#优化rotate函数" class="headerlink" title="优化rotate函数"></a>优化rotate函数</h3><p>原始的rotate函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * naive_rotate - The naive baseline version of rotate </div><div class="line"> */</div><div class="line"><span class="keyword">char</span> naive_rotate_descr[] = <span class="string">"naive_rotate: Naive baseline implementation"</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">naive_rotate</span><span class="params">(<span class="keyword">int</span> dim, pixel *src, pixel *dst)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i, j;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dim; i++)</div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dim; j++)</div><div class="line">        dst[RIDX(dim<span class="number">-1</span>-j, i, dim)] = src[RIDX(i, j, dim)];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>原始代码用了一个双层循环将每个像素点变换到对应的地方去。不难发现，在最内层循环中，j的值每次都会改变，所以每执行一次赋值就要计算一次dim-1-j，这样随着像素点的增多，速度将会慢下来。仔细分析一下代码就能发现一个十分简单的优化方法：将原本从(0,0)处作为src读取起始点改为用i的值作为列作为初始读取值。换句话说就是每次因为外层i保持不变，我们可以将其用<code>dim-1-i</code>来作为读取列,一直从最后一列的第一个像素读到底并转换到i行上。那么赋值语句将变成<code>dst[RIDX(i, j, dim)] = src[RIDX(j, dim-i-1, dim)]</code>，这样就不用每次都计算<code>dim-1-j</code>了。<br>优化代码如下：<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> rotate_descr_v2[] = <span class="string">"The first optimized version"</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate_v2</span><span class="params">(<span class="keyword">int</span> dim, pixel *src, pixel *dst)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i, j;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dim; i++)</div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dim; j++)</div><div class="line">        dst[RIDX(i, j, dim)] = src[RIDX(j, dim-i<span class="number">-1</span>, dim)];<span class="comment">//i change less </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>并在register函数里注册<code>add_rotate_function(&amp;rotate_v2, rotate_descr_v2);</code><br>下图是<code>./driver</code>运行后的评测结果，可以看到CPE比原始的的函数小了不少，特别是像素点越来越大的时候，差距很明显了<br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-11-24-153511.jpg" alt=""></p><p>在网上看了不少的解析，大致第二种优化方案就是把图片再分成若干小块，那么这个小块是多大呢？根据fcyc.c文件中的语句我们可以看到，它把<code>CACHE_BLOCK</code>定义为32x32.<br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-11-24-153949.jpg" alt=""><br>那么我们可以考虑将图片分割成32x32的小块来进行变换，进一步加速程序。<br><strong>在cache存储体不足够大的情况下，对循环分块能够提升高速缓存命中率，从而提升了空间局部性。</strong><br>下面是优化代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> rotate_descr_v3[] = <span class="string">"The second optimized version"</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate_v3</span><span class="params">(<span class="keyword">int</span> dim, pixel *src, pixel *dst)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i,j,i1,j1=<span class="number">0</span>;</div><div class="line">    <span class="comment">//32*32 block size</span></div><div class="line">    <span class="keyword">int</span> block_size=<span class="number">32</span>;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;dim;i+=block_size)</div><div class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;dim;j+=block_size)&#123;</div><div class="line">            <span class="keyword">for</span>(i1=i;i1&lt;i+block_size;i1++)</div><div class="line">                <span class="keyword">for</span>(j1=j;j1&lt;j+block_size;j1++)</div><div class="line">                    dst[RIDX(i1, j1, dim)] = src[RIDX(j1, dim-i1<span class="number">-1</span>, dim)];              </div><div class="line">            &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>同样，运行之后可以观察到，与上一个优化的函数相比，在像素点逐步提升的情况下，CPE是有明显下降的，确实有了比较显著的提升。<br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-11-24-154529.jpg" alt=""></p><p>如果再进一步提升速度的话，得充分利用CPU的流水线特性，并行运算。那么我们可以根据cache的大小分32路并行来写，分析变换后可以得到以下代码（dst += (dim - 1) * dim;将dst指向最后一行第一个元素的地址，因为是从src的首元素，每次+=32进行递增的，也就是按列转换，类似于(0,0)(1,0)(2,0)..这样的顺序一直按列转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> rotate_descr_v4[]= <span class="string">"The three optimized version"</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate_v4</span><span class="params">(<span class="keyword">int</span> dim, pixel *src, pixel *dst)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i,j=<span class="number">0</span>;</div><div class="line">    dst += (dim<span class="number">-1</span>)*dim;<span class="comment">//将dst指向最后一行第一个元素的地址</span></div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;dim;i+=<span class="number">32</span>)&#123;</div><div class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;dim;j++)&#123;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            dst++;src+=dim;</div><div class="line"></div><div class="line">            *dst=*src;</div><div class="line">            <span class="comment">//dst++;src+=dim;</span></div><div class="line"></div><div class="line">            src-=<span class="number">31</span>*dim;src++;<span class="comment">//将src移回当前小块首行下一个元素</span></div><div class="line">            dst-=<span class="number">31</span>;dst-=dim;<span class="comment">//将dst移到当前dst行首的上一行</span></div><div class="line">        &#125;</div><div class="line">        src+=<span class="number">31</span>*dim;<span class="comment">//一次循环结束之后src处于整个块的第二行第一列，加上31*m即可到达下一小块的第一行第一列</span></div><div class="line">        dst+=<span class="number">32</span>;dst+=dim*dim;<span class="comment">//一次循环之后dst处于整个像素矩阵(开始处-31)地址上，所以需要+32使其处于像素矩阵的(开始处+1)地址上，再加上dim*dim，又可以回到整个像素矩阵分成的小块中下一个小块的最底层处</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到，相比与第二个优化方案，又有了不小的提升。至此，由于知识的局限性暂时想不到关于rotate函数还能有什么其他的优化方法了。<br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-11-24-155542.jpg" alt=""></p><hr><h3 id="优化smooth函数"><a href="#优化smooth函数" class="headerlink" title="优化smooth函数"></a>优化smooth函数</h3><p>与Smooth函数相关的原始代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* A struct used to compute averaged pixel value */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">int</span> red;</div><div class="line">    <span class="keyword">int</span> green;</div><div class="line">    <span class="keyword">int</span> blue;</div><div class="line">    <span class="keyword">int</span> num;</div><div class="line">&#125; pixel_sum;</div><div class="line"></div><div class="line"><span class="comment">/* Compute min and max of two integers, respectively */</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> (a &lt; b ? a : b); &#125;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> (a &gt; b ? a : b); &#125;</div><div class="line"></div><div class="line"><span class="comment">/* </span></div><div class="line"> * initialize_pixel_sum - Initializes all fields of sum to 0 </div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initialize_pixel_sum</span><span class="params">(pixel_sum *sum)</span> </span></div><div class="line">&#123;</div><div class="line">    sum-&gt;red = sum-&gt;green = sum-&gt;blue = <span class="number">0</span>;</div><div class="line">    sum-&gt;num = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* </span></div><div class="line"> * accumulate_sum - Accumulates field values of p in corresponding </div><div class="line"> * fields of sum </div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">accumulate_sum</span><span class="params">(pixel_sum *sum, pixel p)</span> </span></div><div class="line">&#123;</div><div class="line">    sum-&gt;red += (<span class="keyword">int</span>) p.red;</div><div class="line">    sum-&gt;green += (<span class="keyword">int</span>) p.green;</div><div class="line">    sum-&gt;blue += (<span class="keyword">int</span>) p.blue;</div><div class="line">    sum-&gt;num++;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* </span></div><div class="line"> * assign_sum_to_pixel - Computes averaged pixel value in current_pixel </div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign_sum_to_pixel</span><span class="params">(pixel *current_pixel, pixel_sum sum)</span> </span></div><div class="line">&#123;</div><div class="line">    current_pixel-&gt;red = (<span class="keyword">unsigned</span> <span class="keyword">short</span>) (sum.red/sum.num);</div><div class="line">    current_pixel-&gt;green = (<span class="keyword">unsigned</span> <span class="keyword">short</span>) (sum.green/sum.num);</div><div class="line">    current_pixel-&gt;blue = (<span class="keyword">unsigned</span> <span class="keyword">short</span>) (sum.blue/sum.num);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* </span></div><div class="line"> * avg - Returns averaged pixel value at (i,j) </div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> pixel <span class="title">avg</span><span class="params">(<span class="keyword">int</span> dim, <span class="keyword">int</span> i, <span class="keyword">int</span> j, pixel *src)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> ii, jj;</div><div class="line">    pixel_sum sum;</div><div class="line">    pixel current_pixel;</div><div class="line"></div><div class="line">    initialize_pixel_sum(&amp;sum);</div><div class="line">    <span class="keyword">for</span>(ii = max(i<span class="number">-1</span>, <span class="number">0</span>); ii &lt;= min(i+<span class="number">1</span>, dim<span class="number">-1</span>); ii++) </div><div class="line"><span class="keyword">for</span>(jj = max(j<span class="number">-1</span>, <span class="number">0</span>); jj &lt;= min(j+<span class="number">1</span>, dim<span class="number">-1</span>); jj++) </div><div class="line">    accumulate_sum(&amp;sum, src[RIDX(ii, jj, dim)]);</div><div class="line"></div><div class="line">    assign_sum_to_pixel(&amp;current_pixel, sum);</div><div class="line">    <span class="keyword">return</span> current_pixel;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/******************************************************</span></div><div class="line"> * Your different versions of the smooth kernel go here</div><div class="line"> ******************************************************/</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * naive_smooth - The naive baseline version of smooth </div><div class="line"> */</div><div class="line"><span class="keyword">char</span> naive_smooth_descr[] = <span class="string">"naive_smooth: Naive baseline implementation"</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">naive_smooth</span><span class="params">(<span class="keyword">int</span> dim, pixel *src, pixel *dst)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i, j;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dim; i++)</div><div class="line"> <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dim; j++)</div><div class="line">    dst[RIDX(i, j, dim)] = avg(dim, i, j, src);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * smooth - Your current working version of smooth. </div><div class="line"> * IMPORTANT: This is the version you will be graded on</div><div class="line"> */</div><div class="line"><span class="keyword">char</span> smooth_descr[] = <span class="string">"smooth: Current working version"</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">smooth</span><span class="params">(<span class="keyword">int</span> dim, pixel *src, pixel *dst)</span> </span></div><div class="line">&#123;</div><div class="line">    naive_smooth(dim, src, dst);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到，从smooth开始，调用<code>naive_smooth</code>，最重要的是，在<code>naive_smooth</code>中的两层for循环中调用了<code>avg</code>函数，而在<code>avg</code>函数中在两层for循环的条件中又调用了<code>min</code>与<code>max</code>函数，在循环体中又调用了<code>accumulate_sum</code>函数，这些频繁的调用显然是会影响到整体的运算效率的。那么可以考虑把这些调用函数都去掉，直接在smooth函数中运算。像素点分成图片四个角、图片四条边、图片内部三块分别进行处理。对角而言只需要4个像素点的均值，对于边而言为6个像素点均值，图片内部则需要9个像素点均值。所以自己写求平均的函数，要分三种情况，一是图像的四个角落，二是四条边界上的点，三是一般情况。<br>优化后的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> smooth_descr_v2[] = <span class="string">"The first smooth version "</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">smooth_v2</span><span class="params">(<span class="keyword">int</span> dim, pixel *src, pixel *dst)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i,j;</div><div class="line"></div><div class="line">    <span class="comment">//四个角</span></div><div class="line">    <span class="comment">//左上角</span></div><div class="line">    dst[RIDX(<span class="number">0</span>,<span class="number">0</span>,dim)].red=(src[RIDX(<span class="number">0</span>,<span class="number">0</span>,dim)].red+</div><div class="line">    src[RIDX(<span class="number">1</span>,<span class="number">0</span>,dim)].red+src[RIDX(<span class="number">0</span>,<span class="number">1</span>,dim)].red+</div><div class="line">    src[RIDX(<span class="number">1</span>,<span class="number">1</span>,dim)].red)&gt;&gt;<span class="number">2</span>;</div><div class="line">    dst[RIDX(<span class="number">0</span>,<span class="number">0</span>,dim)].blue=(src[RIDX(<span class="number">0</span>,<span class="number">0</span>,dim)].blue+</div><div class="line">    src[RIDX(<span class="number">1</span>,<span class="number">0</span>,dim)].blue+src[RIDX(<span class="number">0</span>,<span class="number">1</span>,dim)].blue+</div><div class="line">    src[RIDX(<span class="number">1</span>,<span class="number">1</span>,dim)].blue)&gt;&gt;<span class="number">2</span>;</div><div class="line">    dst[RIDX(<span class="number">0</span>,<span class="number">0</span>,dim)].green=(src[RIDX(<span class="number">0</span>,<span class="number">0</span>,dim)].green+</div><div class="line">    src[RIDX(<span class="number">1</span>,<span class="number">0</span>,dim)].green+src[RIDX(<span class="number">0</span>,<span class="number">1</span>,dim)].green+</div><div class="line">    src[RIDX(<span class="number">1</span>,<span class="number">1</span>,dim)].green)&gt;&gt;<span class="number">2</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//右上角</span></div><div class="line">    dst[RIDX(<span class="number">0</span>,dim<span class="number">-1</span>,dim)].red=(src[RIDX(<span class="number">0</span>,dim<span class="number">-1</span>,dim)].red+</div><div class="line">    src[RIDX(<span class="number">1</span>,dim<span class="number">-1</span>,dim)].red+src[RIDX(<span class="number">0</span>,dim<span class="number">-2</span>,dim)].red+</div><div class="line">    src[RIDX(<span class="number">1</span>,dim<span class="number">-2</span>,dim)].red)&gt;&gt;<span class="number">2</span>;</div><div class="line">    dst[RIDX(<span class="number">0</span>,dim<span class="number">-1</span>,dim)].blue=(src[RIDX(<span class="number">0</span>,dim<span class="number">-1</span>,dim)].blue+</div><div class="line">    src[RIDX(<span class="number">1</span>,dim<span class="number">-1</span>,dim)].blue+src[RIDX(<span class="number">0</span>,dim<span class="number">-2</span>,dim)].blue+</div><div class="line">    src[RIDX(<span class="number">1</span>,dim<span class="number">-2</span>,dim)].blue)&gt;&gt;<span class="number">2</span>;</div><div class="line">    dst[RIDX(<span class="number">0</span>,dim<span class="number">-1</span>,dim)].green=(src[RIDX(<span class="number">0</span>,dim<span class="number">-1</span>,dim)].green+</div><div class="line">    src[RIDX(<span class="number">1</span>,dim<span class="number">-1</span>,dim)].green+src[RIDX(<span class="number">0</span>,dim<span class="number">-2</span>,dim)].green+</div><div class="line">    src[RIDX(<span class="number">1</span>,dim<span class="number">-2</span>,dim)].green)&gt;&gt;<span class="number">2</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//左下角</span></div><div class="line">    dst[RIDX(dim<span class="number">-1</span>,<span class="number">0</span>,dim)].red=(src[RIDX(dim<span class="number">-1</span>,<span class="number">0</span>,dim)].red+</div><div class="line">    src[RIDX(dim<span class="number">-2</span>,<span class="number">0</span>,dim)].red+src[RIDX(dim<span class="number">-1</span>,<span class="number">1</span>,dim)].red+</div><div class="line">    src[RIDX(dim<span class="number">-2</span>,<span class="number">1</span>,dim)].red)&gt;&gt;<span class="number">2</span>;</div><div class="line">    dst[RIDX(dim<span class="number">-1</span>,<span class="number">0</span>,dim)].blue=(src[RIDX(dim<span class="number">-1</span>,<span class="number">0</span>,dim)].blue+</div><div class="line">    src[RIDX(dim<span class="number">-2</span>,<span class="number">0</span>,dim)].blue+src[RIDX(dim<span class="number">-1</span>,<span class="number">1</span>,dim)].blue+</div><div class="line">    src[RIDX(dim<span class="number">-2</span>,<span class="number">1</span>,dim)].blue)&gt;&gt;<span class="number">2</span>;</div><div class="line">    dst[RIDX(dim<span class="number">-1</span>,<span class="number">0</span>,dim)].green=(src[RIDX(dim<span class="number">-1</span>,<span class="number">0</span>,dim)].green+</div><div class="line">    src[RIDX(dim<span class="number">-2</span>,<span class="number">0</span>,dim)].green+src[RIDX(dim<span class="number">-1</span>,<span class="number">1</span>,dim)].green+</div><div class="line">    src[RIDX(dim<span class="number">-2</span>,<span class="number">1</span>,dim)].green)&gt;&gt;<span class="number">2</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//右下角</span></div><div class="line">    dst[RIDX(dim<span class="number">-1</span>,dim<span class="number">-1</span>,dim)].red=(src[RIDX(dim<span class="number">-1</span>,dim<span class="number">-1</span>,dim)].red+</div><div class="line">    src[RIDX(dim<span class="number">-1</span>,dim<span class="number">-2</span>,dim)].red+src[RIDX(dim<span class="number">-2</span>,dim<span class="number">-1</span>,dim)].red+</div><div class="line">    src[RIDX(dim<span class="number">-2</span>,dim<span class="number">-2</span>,dim)].red)&gt;&gt;<span class="number">2</span>;</div><div class="line">    dst[RIDX(dim<span class="number">-1</span>,dim<span class="number">-1</span>,dim)].blue=(src[RIDX(dim<span class="number">-1</span>,dim<span class="number">-1</span>,dim)].blue+</div><div class="line">    src[RIDX(dim<span class="number">-1</span>,dim<span class="number">-2</span>,dim)].blue+src[RIDX(dim<span class="number">-2</span>,dim<span class="number">-1</span>,dim)].blue+</div><div class="line">    src[RIDX(dim<span class="number">-2</span>,dim<span class="number">-2</span>,dim)].blue)&gt;&gt;<span class="number">2</span>;</div><div class="line">    dst[RIDX(dim<span class="number">-1</span>,dim<span class="number">-1</span>,dim)].green=(src[RIDX(dim<span class="number">-1</span>,dim<span class="number">-1</span>,dim)].green+</div><div class="line">    src[RIDX(dim<span class="number">-1</span>,dim<span class="number">-2</span>,dim)].green+src[RIDX(dim<span class="number">-2</span>,dim<span class="number">-1</span>,dim)].green+</div><div class="line">    src[RIDX(dim<span class="number">-2</span>,dim<span class="number">-2</span>,dim)].green)&gt;&gt;<span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="comment">//四条边</span></div><div class="line">    <span class="comment">//左</span></div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;dim<span class="number">-1</span>;i++)&#123;</div><div class="line">        dst[RIDX(i,<span class="number">0</span>,dim)].red=(src[RIDX(i,<span class="number">0</span>,dim)].red+</div><div class="line">        src[RIDX(i<span class="number">-1</span>,<span class="number">0</span>,dim)].red+src[RIDX(i<span class="number">-1</span>,<span class="number">1</span>,dim)].red+</div><div class="line">        src[RIDX(i,<span class="number">1</span>,dim)].red+src[RIDX(i+<span class="number">1</span>,<span class="number">0</span>,dim)].red+</div><div class="line">        src[RIDX(i+<span class="number">1</span>,<span class="number">1</span>,dim)].red)/<span class="number">6</span>;</div><div class="line">        dst[RIDX(i,<span class="number">0</span>,dim)].blue=(src[RIDX(i,<span class="number">0</span>,dim)].blue+</div><div class="line">        src[RIDX(i<span class="number">-1</span>,<span class="number">0</span>,dim)].blue+src[RIDX(i<span class="number">-1</span>,<span class="number">1</span>,dim)].blue+</div><div class="line">        src[RIDX(i,<span class="number">1</span>,dim)].blue+src[RIDX(i+<span class="number">1</span>,<span class="number">0</span>,dim)].blue+</div><div class="line">        src[RIDX(i+<span class="number">1</span>,<span class="number">1</span>,dim)].blue)/<span class="number">6</span>;</div><div class="line">        dst[RIDX(i,<span class="number">0</span>,dim)].green=(src[RIDX(i,<span class="number">0</span>,dim)].green+</div><div class="line">        src[RIDX(i<span class="number">-1</span>,<span class="number">0</span>,dim)].green+src[RIDX(i<span class="number">-1</span>,<span class="number">1</span>,dim)].green+</div><div class="line">        src[RIDX(i,<span class="number">1</span>,dim)].green+src[RIDX(i+<span class="number">1</span>,<span class="number">0</span>,dim)].green+</div><div class="line">        src[RIDX(i+<span class="number">1</span>,<span class="number">1</span>,dim)].green)/<span class="number">6</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//右</span></div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;dim<span class="number">-1</span>;i++)&#123;</div><div class="line">        dst[RIDX(i,dim<span class="number">-1</span>,dim)].red=(src[RIDX(i,dim<span class="number">-1</span>,dim)].red+</div><div class="line">        src[RIDX(i<span class="number">-1</span>,dim<span class="number">-1</span>,dim)].red+src[RIDX(i<span class="number">-1</span>,dim<span class="number">-2</span>,dim)].red+</div><div class="line">        src[RIDX(i,dim<span class="number">-2</span>,dim)].red+src[RIDX(i+<span class="number">1</span>,dim<span class="number">-1</span>,dim)].red+</div><div class="line">        src[RIDX(i+<span class="number">1</span>,dim<span class="number">-2</span>,dim)].red)/<span class="number">6</span>;</div><div class="line">        dst[RIDX(i,dim<span class="number">-1</span>,dim)].blue=(src[RIDX(i,dim<span class="number">-1</span>,dim)].blue+</div><div class="line">        src[RIDX(i<span class="number">-1</span>,dim<span class="number">-1</span>,dim)].blue+src[RIDX(i<span class="number">-1</span>,dim<span class="number">-2</span>,dim)].blue+</div><div class="line">        src[RIDX(i,dim<span class="number">-2</span>,dim)].blue+src[RIDX(i+<span class="number">1</span>,dim<span class="number">-1</span>,dim)].blue+</div><div class="line">        src[RIDX(i+<span class="number">1</span>,dim<span class="number">-2</span>,dim)].blue)/<span class="number">6</span>;</div><div class="line">        dst[RIDX(i,dim<span class="number">-1</span>,dim)].green=(src[RIDX(i,dim<span class="number">-1</span>,dim)].green+</div><div class="line">        src[RIDX(i<span class="number">-1</span>,dim<span class="number">-1</span>,dim)].green+src[RIDX(i<span class="number">-1</span>,dim<span class="number">-2</span>,dim)].green+</div><div class="line">        src[RIDX(i,dim<span class="number">-2</span>,dim)].green+src[RIDX(i+<span class="number">1</span>,dim<span class="number">-1</span>,dim)].green+</div><div class="line">        src[RIDX(i+<span class="number">1</span>,dim<span class="number">-2</span>,dim)].green)/<span class="number">6</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//上</span></div><div class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;dim<span class="number">-1</span>;j++)&#123;</div><div class="line">        dst[RIDX(<span class="number">0</span>,j,dim)].red=(src[RIDX(<span class="number">0</span>,j,dim)].red+</div><div class="line">        src[RIDX(<span class="number">0</span>,j<span class="number">-1</span>,dim)].red+src[RIDX(<span class="number">1</span>,j<span class="number">-1</span>,dim)].red+</div><div class="line">        src[RIDX(<span class="number">1</span>,j,dim)].red+src[RIDX(<span class="number">0</span>,j+<span class="number">1</span>,dim)].red+</div><div class="line">        src[RIDX(<span class="number">1</span>,j+<span class="number">1</span>,dim)].red)/<span class="number">6</span>;</div><div class="line">        dst[RIDX(<span class="number">0</span>,j,dim)].blue=(src[RIDX(<span class="number">0</span>,j,dim)].blue+</div><div class="line">        src[RIDX(<span class="number">0</span>,j<span class="number">-1</span>,dim)].blue+src[RIDX(<span class="number">1</span>,j<span class="number">-1</span>,dim)].blue+</div><div class="line">        src[RIDX(<span class="number">1</span>,j,dim)].blue+src[RIDX(<span class="number">0</span>,j+<span class="number">1</span>,dim)].blue+</div><div class="line">        src[RIDX(<span class="number">1</span>,j+<span class="number">1</span>,dim)].blue)/<span class="number">6</span>;</div><div class="line">        dst[RIDX(<span class="number">0</span>,j,dim)].green=(src[RIDX(<span class="number">0</span>,j,dim)].green+</div><div class="line">        src[RIDX(<span class="number">0</span>,j<span class="number">-1</span>,dim)].green+src[RIDX(<span class="number">1</span>,j<span class="number">-1</span>,dim)].green+</div><div class="line">        src[RIDX(<span class="number">1</span>,j,dim)].green+src[RIDX(<span class="number">0</span>,j+<span class="number">1</span>,dim)].green+</div><div class="line">        src[RIDX(<span class="number">1</span>,j+<span class="number">1</span>,dim)].green)/<span class="number">6</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//下</span></div><div class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;dim<span class="number">-1</span>;j++)&#123;</div><div class="line">        dst[RIDX(dim<span class="number">-1</span>,j,dim)].red=(src[RIDX(dim<span class="number">-1</span>,j,dim)].red+</div><div class="line">        src[RIDX(dim<span class="number">-1</span>,j+<span class="number">1</span>,dim)].red+src[RIDX(dim<span class="number">-1</span>,j<span class="number">-1</span>,dim)].red+</div><div class="line">        src[RIDX(dim<span class="number">-2</span>,j,dim)].red+src[RIDX(dim<span class="number">-2</span>,j+<span class="number">1</span>,dim)].red+</div><div class="line">        src[RIDX(dim<span class="number">-2</span>,j<span class="number">-1</span>,dim)].red)/<span class="number">6</span>;</div><div class="line">        dst[RIDX(dim<span class="number">-1</span>,j,dim)].blue=(src[RIDX(dim<span class="number">-1</span>,j,dim)].blue+</div><div class="line">        src[RIDX(dim<span class="number">-1</span>,j+<span class="number">1</span>,dim)].blue+src[RIDX(dim<span class="number">-1</span>,j<span class="number">-1</span>,dim)].blue+</div><div class="line">        src[RIDX(dim<span class="number">-2</span>,j,dim)].blue+src[RIDX(dim<span class="number">-2</span>,j+<span class="number">1</span>,dim)].blue+</div><div class="line">        src[RIDX(dim<span class="number">-2</span>,j<span class="number">-1</span>,dim)].blue)/<span class="number">6</span>;</div><div class="line">        dst[RIDX(dim<span class="number">-1</span>,j,dim)].green=(src[RIDX(dim<span class="number">-1</span>,j,dim)].green+</div><div class="line">        src[RIDX(dim<span class="number">-1</span>,j+<span class="number">1</span>,dim)].green+src[RIDX(dim<span class="number">-1</span>,j<span class="number">-1</span>,dim)].green+</div><div class="line">        src[RIDX(dim<span class="number">-2</span>,j,dim)].green+src[RIDX(dim<span class="number">-2</span>,j+<span class="number">1</span>,dim)].green+</div><div class="line">        src[RIDX(dim<span class="number">-2</span>,j<span class="number">-1</span>,dim)].green)/<span class="number">6</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//正常情况</span></div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;dim<span class="number">-1</span>;i++)</div><div class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;dim<span class="number">-1</span>;j++)&#123;</div><div class="line">            dst[RIDX(i,j,dim)].red=(src[RIDX(i,j,dim)].red+</div><div class="line">            src[RIDX(i+<span class="number">1</span>,j,dim)].red+src[RIDX(i<span class="number">-1</span>,j,dim)].red+</div><div class="line">            src[RIDX(i,j<span class="number">-1</span>,dim)].red+src[RIDX(i+<span class="number">1</span>,j<span class="number">-1</span>,dim)].red+</div><div class="line">            src[RIDX(i<span class="number">-1</span>,j<span class="number">-1</span>,dim)].red+src[RIDX(i,j+<span class="number">1</span>,dim)].red+</div><div class="line">            src[RIDX(i+<span class="number">1</span>,j+<span class="number">1</span>,dim)].red+src[RIDX(i<span class="number">-1</span>,j+<span class="number">1</span>,dim)].red)/<span class="number">9</span>;</div><div class="line">            dst[RIDX(i,j,dim)].blue=(src[RIDX(i,j,dim)].blue+</div><div class="line">            src[RIDX(i+<span class="number">1</span>,j,dim)].blue+src[RIDX(i<span class="number">-1</span>,j,dim)].blue+</div><div class="line">            src[RIDX(i,j<span class="number">-1</span>,dim)].blue+src[RIDX(i+<span class="number">1</span>,j<span class="number">-1</span>,dim)].blue+</div><div class="line">            src[RIDX(i<span class="number">-1</span>,j<span class="number">-1</span>,dim)].blue+src[RIDX(i,j+<span class="number">1</span>,dim)].blue+</div><div class="line">            src[RIDX(i+<span class="number">1</span>,j+<span class="number">1</span>,dim)].blue+src[RIDX(i<span class="number">-1</span>,j+<span class="number">1</span>,dim)].blue)/<span class="number">9</span>;</div><div class="line">            dst[RIDX(i,j,dim)].green=(src[RIDX(i,j,dim)].green+</div><div class="line">            src[RIDX(i+<span class="number">1</span>,j,dim)].green+src[RIDX(i<span class="number">-1</span>,j,dim)].green+</div><div class="line">            src[RIDX(i,j<span class="number">-1</span>,dim)].green+src[RIDX(i+<span class="number">1</span>,j<span class="number">-1</span>,dim)].green+</div><div class="line">            src[RIDX(i<span class="number">-1</span>,j<span class="number">-1</span>,dim)].green+src[RIDX(i,j+<span class="number">1</span>,dim)].green+</div><div class="line">            src[RIDX(i+<span class="number">1</span>,j+<span class="number">1</span>,dim)].green+src[RIDX(i<span class="number">-1</span>,j+<span class="number">1</span>,dim)].green)/<span class="number">9</span>;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到，CPE值较优化前有了很大的提升：<br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-11-25-135529.jpg" alt=""></p><p>有了前面rotate函数循环展开的经验，那么同样我们可以在smooth函数上使用循环展开，提高并行效率。<br>优化代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> smooth_descr_v3[] = <span class="string">"The second smooth version "</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">smooth_v3</span><span class="params">(<span class="keyword">int</span> dim, pixel *src, pixel *dst)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i,j;</div><div class="line"></div><div class="line">    <span class="comment">//四个角</span></div><div class="line">    <span class="comment">//左上角</span></div><div class="line">    dst[RIDX(<span class="number">0</span>,<span class="number">0</span>,dim)].red=(src[RIDX(<span class="number">0</span>,<span class="number">0</span>,dim)].red+</div><div class="line">    src[RIDX(<span class="number">1</span>,<span class="number">0</span>,dim)].red+src[RIDX(<span class="number">0</span>,<span class="number">1</span>,dim)].red+</div><div class="line">    src[RIDX(<span class="number">1</span>,<span class="number">1</span>,dim)].red)&gt;&gt;<span class="number">2</span>;</div><div class="line">    dst[RIDX(<span class="number">0</span>,<span class="number">0</span>,dim)].blue=(src[RIDX(<span class="number">0</span>,<span class="number">0</span>,dim)].blue+</div><div class="line">    src[RIDX(<span class="number">1</span>,<span class="number">0</span>,dim)].blue+src[RIDX(<span class="number">0</span>,<span class="number">1</span>,dim)].blue+</div><div class="line">    src[RIDX(<span class="number">1</span>,<span class="number">1</span>,dim)].blue)&gt;&gt;<span class="number">2</span>;</div><div class="line">    dst[RIDX(<span class="number">0</span>,<span class="number">0</span>,dim)].green=(src[RIDX(<span class="number">0</span>,<span class="number">0</span>,dim)].green+</div><div class="line">    src[RIDX(<span class="number">1</span>,<span class="number">0</span>,dim)].green+src[RIDX(<span class="number">0</span>,<span class="number">1</span>,dim)].green+</div><div class="line">    src[RIDX(<span class="number">1</span>,<span class="number">1</span>,dim)].green)&gt;&gt;<span class="number">2</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//右上角</span></div><div class="line">    dst[RIDX(<span class="number">0</span>,dim<span class="number">-1</span>,dim)].red=(src[RIDX(<span class="number">0</span>,dim<span class="number">-1</span>,dim)].red+</div><div class="line">    src[RIDX(<span class="number">1</span>,dim<span class="number">-1</span>,dim)].red+src[RIDX(<span class="number">0</span>,dim<span class="number">-2</span>,dim)].red+</div><div class="line">    src[RIDX(<span class="number">1</span>,dim<span class="number">-2</span>,dim)].red)&gt;&gt;<span class="number">2</span>;</div><div class="line">    dst[RIDX(<span class="number">0</span>,dim<span class="number">-1</span>,dim)].blue=(src[RIDX(<span class="number">0</span>,dim<span class="number">-1</span>,dim)].blue+</div><div class="line">    src[RIDX(<span class="number">1</span>,dim<span class="number">-1</span>,dim)].blue+src[RIDX(<span class="number">0</span>,dim<span class="number">-2</span>,dim)].blue+</div><div class="line">    src[RIDX(<span class="number">1</span>,dim<span class="number">-2</span>,dim)].blue)&gt;&gt;<span class="number">2</span>;</div><div class="line">    dst[RIDX(<span class="number">0</span>,dim<span class="number">-1</span>,dim)].green=(src[RIDX(<span class="number">0</span>,dim<span class="number">-1</span>,dim)].green+</div><div class="line">    src[RIDX(<span class="number">1</span>,dim<span class="number">-1</span>,dim)].green+src[RIDX(<span class="number">0</span>,dim<span class="number">-2</span>,dim)].green+</div><div class="line">    src[RIDX(<span class="number">1</span>,dim<span class="number">-2</span>,dim)].green)&gt;&gt;<span class="number">2</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//左下角</span></div><div class="line">    dst[RIDX(dim<span class="number">-1</span>,<span class="number">0</span>,dim)].red=(src[RIDX(dim<span class="number">-1</span>,<span class="number">0</span>,dim)].red+</div><div class="line">    src[RIDX(dim<span class="number">-2</span>,<span class="number">0</span>,dim)].red+src[RIDX(dim<span class="number">-1</span>,<span class="number">1</span>,dim)].red+</div><div class="line">    src[RIDX(dim<span class="number">-2</span>,<span class="number">1</span>,dim)].red)&gt;&gt;<span class="number">2</span>;</div><div class="line">    dst[RIDX(dim<span class="number">-1</span>,<span class="number">0</span>,dim)].blue=(src[RIDX(dim<span class="number">-1</span>,<span class="number">0</span>,dim)].blue+</div><div class="line">    src[RIDX(dim<span class="number">-2</span>,<span class="number">0</span>,dim)].blue+src[RIDX(dim<span class="number">-1</span>,<span class="number">1</span>,dim)].blue+</div><div class="line">    src[RIDX(dim<span class="number">-2</span>,<span class="number">1</span>,dim)].blue)&gt;&gt;<span class="number">2</span>;</div><div class="line">    dst[RIDX(dim<span class="number">-1</span>,<span class="number">0</span>,dim)].green=(src[RIDX(dim<span class="number">-1</span>,<span class="number">0</span>,dim)].green+</div><div class="line">    src[RIDX(dim<span class="number">-2</span>,<span class="number">0</span>,dim)].green+src[RIDX(dim<span class="number">-1</span>,<span class="number">1</span>,dim)].green+</div><div class="line">    src[RIDX(dim<span class="number">-2</span>,<span class="number">1</span>,dim)].green)&gt;&gt;<span class="number">2</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//右下角</span></div><div class="line">    dst[RIDX(dim<span class="number">-1</span>,dim<span class="number">-1</span>,dim)].red=(src[RIDX(dim<span class="number">-1</span>,dim<span class="number">-1</span>,dim)].red+</div><div class="line">    src[RIDX(dim<span class="number">-1</span>,dim<span class="number">-2</span>,dim)].red+src[RIDX(dim<span class="number">-2</span>,dim<span class="number">-1</span>,dim)].red+</div><div class="line">    src[RIDX(dim<span class="number">-2</span>,dim<span class="number">-2</span>,dim)].red)&gt;&gt;<span class="number">2</span>;</div><div class="line">    dst[RIDX(dim<span class="number">-1</span>,dim<span class="number">-1</span>,dim)].blue=(src[RIDX(dim<span class="number">-1</span>,dim<span class="number">-1</span>,dim)].blue+</div><div class="line">    src[RIDX(dim<span class="number">-1</span>,dim<span class="number">-2</span>,dim)].blue+src[RIDX(dim<span class="number">-2</span>,dim<span class="number">-1</span>,dim)].blue+</div><div class="line">    src[RIDX(dim<span class="number">-2</span>,dim<span class="number">-2</span>,dim)].blue)&gt;&gt;<span class="number">2</span>;</div><div class="line">    dst[RIDX(dim<span class="number">-1</span>,dim<span class="number">-1</span>,dim)].green=(src[RIDX(dim<span class="number">-1</span>,dim<span class="number">-1</span>,dim)].green+</div><div class="line">    src[RIDX(dim<span class="number">-1</span>,dim<span class="number">-2</span>,dim)].green+src[RIDX(dim<span class="number">-2</span>,dim<span class="number">-1</span>,dim)].green+</div><div class="line">    src[RIDX(dim<span class="number">-2</span>,dim<span class="number">-2</span>,dim)].green)&gt;&gt;<span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="comment">//四条边</span></div><div class="line">    <span class="comment">//左</span></div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;dim<span class="number">-1</span>;i++)&#123;</div><div class="line">        dst[RIDX(i,<span class="number">0</span>,dim)].red=(src[RIDX(i,<span class="number">0</span>,dim)].red+</div><div class="line">        src[RIDX(i<span class="number">-1</span>,<span class="number">0</span>,dim)].red+src[RIDX(i<span class="number">-1</span>,<span class="number">1</span>,dim)].red+</div><div class="line">        src[RIDX(i,<span class="number">1</span>,dim)].red+src[RIDX(i+<span class="number">1</span>,<span class="number">0</span>,dim)].red+</div><div class="line">        src[RIDX(i+<span class="number">1</span>,<span class="number">1</span>,dim)].red)/<span class="number">6</span>;</div><div class="line">        dst[RIDX(i,<span class="number">0</span>,dim)].blue=(src[RIDX(i,<span class="number">0</span>,dim)].blue+</div><div class="line">        src[RIDX(i<span class="number">-1</span>,<span class="number">0</span>,dim)].blue+src[RIDX(i<span class="number">-1</span>,<span class="number">1</span>,dim)].blue+</div><div class="line">        src[RIDX(i,<span class="number">1</span>,dim)].blue+src[RIDX(i+<span class="number">1</span>,<span class="number">0</span>,dim)].blue+</div><div class="line">        src[RIDX(i+<span class="number">1</span>,<span class="number">1</span>,dim)].blue)/<span class="number">6</span>;</div><div class="line">        dst[RIDX(i,<span class="number">0</span>,dim)].green=(src[RIDX(i,<span class="number">0</span>,dim)].green+</div><div class="line">        src[RIDX(i<span class="number">-1</span>,<span class="number">0</span>,dim)].green+src[RIDX(i<span class="number">-1</span>,<span class="number">1</span>,dim)].green+</div><div class="line">        src[RIDX(i,<span class="number">1</span>,dim)].green+src[RIDX(i+<span class="number">1</span>,<span class="number">0</span>,dim)].green+</div><div class="line">        src[RIDX(i+<span class="number">1</span>,<span class="number">1</span>,dim)].green)/<span class="number">6</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//右</span></div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;dim<span class="number">-1</span>;i++)&#123;</div><div class="line">        dst[RIDX(i,dim<span class="number">-1</span>,dim)].red=(src[RIDX(i,dim<span class="number">-1</span>,dim)].red+</div><div class="line">        src[RIDX(i<span class="number">-1</span>,dim<span class="number">-1</span>,dim)].red+src[RIDX(i<span class="number">-1</span>,dim<span class="number">-2</span>,dim)].red+</div><div class="line">        src[RIDX(i,dim<span class="number">-2</span>,dim)].red+src[RIDX(i+<span class="number">1</span>,dim<span class="number">-1</span>,dim)].red+</div><div class="line">        src[RIDX(i+<span class="number">1</span>,dim<span class="number">-2</span>,dim)].red)/<span class="number">6</span>;</div><div class="line">        dst[RIDX(i,dim<span class="number">-1</span>,dim)].blue=(src[RIDX(i,dim<span class="number">-1</span>,dim)].blue+</div><div class="line">        src[RIDX(i<span class="number">-1</span>,dim<span class="number">-1</span>,dim)].blue+src[RIDX(i<span class="number">-1</span>,dim<span class="number">-2</span>,dim)].blue+</div><div class="line">        src[RIDX(i,dim<span class="number">-2</span>,dim)].blue+src[RIDX(i+<span class="number">1</span>,dim<span class="number">-1</span>,dim)].blue+</div><div class="line">        src[RIDX(i+<span class="number">1</span>,dim<span class="number">-2</span>,dim)].blue)/<span class="number">6</span>;</div><div class="line">        dst[RIDX(i,dim<span class="number">-1</span>,dim)].green=(src[RIDX(i,dim<span class="number">-1</span>,dim)].green+</div><div class="line">        src[RIDX(i<span class="number">-1</span>,dim<span class="number">-1</span>,dim)].green+src[RIDX(i<span class="number">-1</span>,dim<span class="number">-2</span>,dim)].green+</div><div class="line">        src[RIDX(i,dim<span class="number">-2</span>,dim)].green+src[RIDX(i+<span class="number">1</span>,dim<span class="number">-1</span>,dim)].green+</div><div class="line">        src[RIDX(i+<span class="number">1</span>,dim<span class="number">-2</span>,dim)].green)/<span class="number">6</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//上</span></div><div class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;dim<span class="number">-1</span>;j++)&#123;</div><div class="line">        dst[RIDX(<span class="number">0</span>,j,dim)].red=(src[RIDX(<span class="number">0</span>,j,dim)].red+</div><div class="line">        src[RIDX(<span class="number">0</span>,j<span class="number">-1</span>,dim)].red+src[RIDX(<span class="number">1</span>,j<span class="number">-1</span>,dim)].red+</div><div class="line">        src[RIDX(<span class="number">1</span>,j,dim)].red+src[RIDX(<span class="number">0</span>,j+<span class="number">1</span>,dim)].red+</div><div class="line">        src[RIDX(<span class="number">1</span>,j+<span class="number">1</span>,dim)].red)/<span class="number">6</span>;</div><div class="line">        dst[RIDX(<span class="number">0</span>,j,dim)].blue=(src[RIDX(<span class="number">0</span>,j,dim)].blue+</div><div class="line">        src[RIDX(<span class="number">0</span>,j<span class="number">-1</span>,dim)].blue+src[RIDX(<span class="number">1</span>,j<span class="number">-1</span>,dim)].blue+</div><div class="line">        src[RIDX(<span class="number">1</span>,j,dim)].blue+src[RIDX(<span class="number">0</span>,j+<span class="number">1</span>,dim)].blue+</div><div class="line">        src[RIDX(<span class="number">1</span>,j+<span class="number">1</span>,dim)].blue)/<span class="number">6</span>;</div><div class="line">        dst[RIDX(<span class="number">0</span>,j,dim)].green=(src[RIDX(<span class="number">0</span>,j,dim)].green+</div><div class="line">        src[RIDX(<span class="number">0</span>,j<span class="number">-1</span>,dim)].green+src[RIDX(<span class="number">1</span>,j<span class="number">-1</span>,dim)].green+</div><div class="line">        src[RIDX(<span class="number">1</span>,j,dim)].green+src[RIDX(<span class="number">0</span>,j+<span class="number">1</span>,dim)].green+</div><div class="line">        src[RIDX(<span class="number">1</span>,j+<span class="number">1</span>,dim)].green)/<span class="number">6</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//下</span></div><div class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;dim<span class="number">-1</span>;j++)&#123;</div><div class="line">        dst[RIDX(dim<span class="number">-1</span>,j,dim)].red=(src[RIDX(dim<span class="number">-1</span>,j,dim)].red+</div><div class="line">        src[RIDX(dim<span class="number">-1</span>,j+<span class="number">1</span>,dim)].red+src[RIDX(dim<span class="number">-1</span>,j<span class="number">-1</span>,dim)].red+</div><div class="line">        src[RIDX(dim<span class="number">-2</span>,j,dim)].red+src[RIDX(dim<span class="number">-2</span>,j+<span class="number">1</span>,dim)].red+</div><div class="line">        src[RIDX(dim<span class="number">-2</span>,j<span class="number">-1</span>,dim)].red)/<span class="number">6</span>;</div><div class="line">        dst[RIDX(dim<span class="number">-1</span>,j,dim)].blue=(src[RIDX(dim<span class="number">-1</span>,j,dim)].blue+</div><div class="line">        src[RIDX(dim<span class="number">-1</span>,j+<span class="number">1</span>,dim)].blue+src[RIDX(dim<span class="number">-1</span>,j<span class="number">-1</span>,dim)].blue+</div><div class="line">        src[RIDX(dim<span class="number">-2</span>,j,dim)].blue+src[RIDX(dim<span class="number">-2</span>,j+<span class="number">1</span>,dim)].blue+</div><div class="line">        src[RIDX(dim<span class="number">-2</span>,j<span class="number">-1</span>,dim)].blue)/<span class="number">6</span>;</div><div class="line">        dst[RIDX(dim<span class="number">-1</span>,j,dim)].green=(src[RIDX(dim<span class="number">-1</span>,j,dim)].green+</div><div class="line">        src[RIDX(dim<span class="number">-1</span>,j+<span class="number">1</span>,dim)].green+src[RIDX(dim<span class="number">-1</span>,j<span class="number">-1</span>,dim)].green+</div><div class="line">        src[RIDX(dim<span class="number">-2</span>,j,dim)].green+src[RIDX(dim<span class="number">-2</span>,j+<span class="number">1</span>,dim)].green+</div><div class="line">        src[RIDX(dim<span class="number">-2</span>,j<span class="number">-1</span>,dim)].green)/<span class="number">6</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//正常情况</span></div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;dim<span class="number">-1</span>;i+=<span class="number">2</span>)</div><div class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;dim<span class="number">-1</span>;j++)&#123;</div><div class="line">            <span class="keyword">int</span> pos=i*dim+j;</div><div class="line">            dst[pos].red=(src[pos].red+src[pos+dim].red+src[pos-dim].red+</div><div class="line">            src[pos<span class="number">-1</span>].red+src[pos+dim<span class="number">-1</span>].red+src[pos-dim<span class="number">-1</span>].red+</div><div class="line">            src[pos+<span class="number">1</span>].red+src[pos+<span class="number">1</span>+dim].red+src[pos+<span class="number">1</span>-dim].red)/<span class="number">9</span>;</div><div class="line">            dst[pos].blue=(src[pos].blue+src[pos+dim].blue+src[pos-dim].blue+</div><div class="line">            src[pos<span class="number">-1</span>].blue+src[pos+dim<span class="number">-1</span>].blue+src[pos-dim<span class="number">-1</span>].blue+</div><div class="line">            src[pos+<span class="number">1</span>].blue+src[pos+<span class="number">1</span>+dim].blue+src[pos+<span class="number">1</span>-dim].blue)/<span class="number">9</span>;</div><div class="line">            dst[pos].green=(src[pos].green+src[pos+dim].green+src[pos-dim].green+</div><div class="line">            src[pos<span class="number">-1</span>].green+src[pos+dim<span class="number">-1</span>].green+src[pos-dim<span class="number">-1</span>].green+</div><div class="line">            src[pos+<span class="number">1</span>].green+src[pos+<span class="number">1</span>+dim].green+src[pos+<span class="number">1</span>-dim].green)/<span class="number">9</span>;</div><div class="line"></div><div class="line">            <span class="comment">//pos移到下一行</span></div><div class="line">            pos+=dim;</div><div class="line"></div><div class="line">            dst[pos].red=(src[pos].red+src[pos+dim].red+src[pos-dim].red+</div><div class="line">            src[pos<span class="number">-1</span>].red+src[pos+dim<span class="number">-1</span>].red+src[pos-dim<span class="number">-1</span>].red+</div><div class="line">            src[pos+<span class="number">1</span>].red+src[pos+<span class="number">1</span>+dim].red+src[pos+<span class="number">1</span>-dim].red)/<span class="number">9</span>;</div><div class="line">            dst[pos].blue=(src[pos].blue+src[pos+dim].blue+src[pos-dim].blue+</div><div class="line">            src[pos<span class="number">-1</span>].blue+src[pos+dim<span class="number">-1</span>].blue+src[pos-dim<span class="number">-1</span>].blue+</div><div class="line">            src[pos+<span class="number">1</span>].blue+src[pos+<span class="number">1</span>+dim].blue+src[pos+<span class="number">1</span>-dim].blue)/<span class="number">9</span>;</div><div class="line">            dst[pos].green=(src[pos].green+src[pos+dim].green+src[pos-dim].green+</div><div class="line">            src[pos<span class="number">-1</span>].green+src[pos+dim<span class="number">-1</span>].green+src[pos-dim<span class="number">-1</span>].green+</div><div class="line">            src[pos+<span class="number">1</span>].green+src[pos+<span class="number">1</span>+dim].green+src[pos+<span class="number">1</span>-dim].green)/<span class="number">9</span>;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到虽然进行了循环展开，但是CPE在不同的数据上差距并不明显，甚至还有数据越大越低于未展开时的函数，但也算是一种优化方案吧。关于循环展开的长度，因为要去掉上下左右的边，所以变为了32*n-2，而这个数最安全的公因数就是2了，所以选择了两路并行。</p><p>想破脑袋也没想出第三种优化方案，看到网上有关于作弊优化的说明，尝试了一下。确实很好玩…</p><p>说说细节吧：</p><p>总的来说，这个实验就是让我们用一张白纸去依据要求复制一幅画。而验证的时候，程序是通过将你画的画与它事先复制好的样品比对。若一致，则说明程序是正确的。所以我们的优化就是尽量画得快一些。<br>那么，漏洞就来了。既然最后的验证只是与样品比对，那么我们就可以通过在比对前，就先给样品处理，这里是全部涂黑。这样的话，我们画的画就不需要再参照原本的画来画了，只需要也响应涂黑了。涂黑的动作可以根据memset函数来非常快速地格式化掉。<br>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> smooth_descr_v4[] = <span class="string">"The three smooth version "</span>;<span class="function"><span class="keyword">void</span> <span class="title">smooth_v4</span><span class="params">(<span class="keyword">int</span> dim, pixel *src, pixel *dst)</span> </span>&#123;    <span class="built_in">memset</span>(src,<span class="number">0</span>,<span class="keyword">sizeof</span>(pixel)*dim*dim);    <span class="built_in">memset</span>(dst+dim*dim,<span class="number">0</span>,<span class="keyword">sizeof</span>(pixel)*dim*dim);&#125;</div></pre></td></tr></table></figure><p>可以看到结果非常变态，CPE已经降到0.6之低了…不过别忘记加上包含memset函数声明的string.h头文件<br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-11-25-151411.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;实验目的&quot;&gt;&lt;a href=&quot;#实验目的&quot; class=&quot;headerlink&quot; title=&quot;实验目的&quot;&gt;&lt;/a&gt;实验目的&lt;/h3&gt;&lt;p&gt;kernel.c文件中主要有两个需要进行优化的函数：rotate和smooth，并分别给出了naive_rotate和naive_smooth两个函数的基本实现作为baseline作为你改进后的程序的比较对象。你需要读懂rotate和smooth函数，并对其进行优化。你每写一个新版本的、优化的rotate和smooth函数，均可在成注册后使用driver进行测试，并得到对应的CPE和加速比。本次实验，要求针对每个函数、每个人均至少写出3种优化版本、并根据driver报告的结果进行性能分析。 &lt;/p&gt;
&lt;h3 id=&quot;优化rotate函数&quot;&gt;&lt;a href=&quot;#优化rotate函数&quot; class=&quot;headerlink&quot; title=&quot;优化rotate函数&quot;&gt;&lt;/a&gt;优化rotate函数&lt;/h3&gt;&lt;p&gt;原始的rotate函数如下：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * naive_rotate - The naive baseline version of rotate &lt;/div&gt;&lt;div class=&quot;line&quot;&gt; */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; naive_rotate_descr[] = &lt;span class=&quot;string&quot;&gt;&quot;naive_rotate: Naive baseline implementation&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;naive_rotate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; dim, pixel *src, pixel *dst)&lt;/span&gt; &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i, j;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; dim; i++)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; dim; j++)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        dst[RIDX(dim&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;-j, i, dim)] = src[RIDX(i, j, dim)];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;原始代码用了一个双层循环将每个像素点变换到对应的地方去。不难发现，在最内层循环中，j的值每次都会改变，所以每执行一次赋值就要计算一次dim-1-j，这样随着像素点的增多，速度将会慢下来。仔细分析一下代码就能发现一个十分简单的优化方法：将原本从(0,0)处作为src读取起始点改为用i的值作为列作为初始读取值。换句话说就是每次因为外层i保持不变，我们可以将其用&lt;code&gt;dim-1-i&lt;/code&gt;来作为读取列,一直从最后一列的第一个像素读到底并转换到i行上。那么赋值语句将变成&lt;code&gt;dst[RIDX(i, j, dim)] = src[RIDX(j, dim-i-1, dim)]&lt;/code&gt;，这样就不用每次都计算&lt;code&gt;dim-1-j&lt;/code&gt;了。&lt;br&gt;优化代码如下：&lt;br&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="http://jihong.xyz/categories/computer-principle/"/>
    
    
      <category term="编程素养" scheme="http://jihong.xyz/tags/Programming-literacy/"/>
    
  </entry>
  
  <entry>
    <title>比特小镇的集市</title>
    <link href="http://jihong.xyz/programer/%E6%AF%94%E7%89%B9%E5%B0%8F%E9%95%87%E7%9A%84%E9%9B%86%E5%B8%82/"/>
    <id>http://jihong.xyz/programer/比特小镇的集市/</id>
    <published>2016-12-01T10:47:13.000Z</published>
    <updated>2016-12-02T10:52:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="比特小镇的集市"><a href="#比特小镇的集市" class="headerlink" title="比特小镇的集市"></a>比特小镇的集市</h1><p>从前有个叫比特的小镇，镇子上的居民过着无忧无虑的生活，但令大家最为头痛的事情是每天都要翻山越岭，经过长达十几里的路程到另外一个地方参加集市。小镇有很多特产，每次小镇的居民都会带着不同的特产去参加集会，来交换自己所需要的生活物品。忽然有一天，小镇来了一个农夫，农夫说：“大家每天这么辛苦的跑来跑去，只能换取一点点东西，不划算啊！这样吧，我来建一条公路，每天提供货车，大家知道交一点点过路费就好了。“小镇的居民商量了一下，觉得可以。公路建成那天大家兴高采烈的乘着农夫的货车去往集市。</p><p>时间过得很快，转眼一年多过去了，农夫算了算一年的收益，发现光收取过路费对于成本会有有点困难，毕竟公路还需要修修补补，这也是不小的开销。怎么办呢？如果增加过路费的话，小镇居民肯定不同意，想了又想也没有什么好主意。这天农夫的司机马突然说道，既然路程这么远，公路维护费用这么高，不如我们在路中间的位置开辟一个新的集市，让两边的人在新集市交易多好。这样不仅有双份的过路费，同时集市的摊位还能挣钱。农夫立刻同意，着手开始修建集市。<br><a id="more"></a><br>很快集市建好了，因为路程短了，而且费用不高，所以新集市特别收大家欢迎。短短的时间内，集市的所有摊位都被租光了。没有租到摊位的居民还非常不满，天天吵吵着要农夫增加摊位。好吧，大好的生意哪有不做的道理，很快农夫就开辟了更多的摊位。随着摊位的数量越来越多的，很多人发现，摊位的位置很重要。在边缘位置的摊位一天下来都没有人光顾，更不要提卖出更多特产了。这可苦了一批摊位的老板。这些边缘地带的老板一想，要想办法招揽人啊，怎么办呢？狗的叫声大，不如我们请狗来帮我们吆喝把，声音一大，自然顾客就多了。说干就干，这下可把小镇的狗忙坏了，每天在集市叫嚷。这下子集市从热热闹闹变成了吵吵闹闹，农夫不高兴了，这么多叫嚷怎么可以，于是把那些为了找来顾客而找狗吆喝的摊位全部回收了。集市回到了以前热热闹闹的场景。</p><p>过了几天，企鹅突然登门拜访农夫。农夫知道企鹅肯定又要排挤它周围的摊位了，为什么呢？因为一开始企鹅卖的特产很稀少，它的摊位每天都有很多顾客。周围的摊位眼馋，也卖相同的特产。因为出现竞争，企鹅的顾客一下子少了许多。但它并不生气，反而在购买特产的时候，赠送几种其他的特产。用这种方式，企鹅的顾客又多了起来。时间久了，那些附赠的特产也渐渐变成了商品，种类越滚越多，相邻的几个摊位都被企鹅租了下来。摊位变大了，企鹅底气也足了。以至于看到集市有什么特产都会第一时间在自己的摊位增加相同的品种。大家对其怨声载道，但根本没人管理这事。企鹅今天来拜访农夫其实是想承包一大片摊位，同时承包小镇每天来往的货车。显然农夫是不愿意这么做的。因为企鹅已经在排挤其他小镇居民了，你家的日子过得生龙活虎，那其他人怎么办？把货车承包给你，你每天拉更多的货，公路维修费用要上涨，这个谁来管？</p><p>双方商量之后，觉得可以各让一步，农夫可以租赁给企鹅更多摊位，但是企鹅不能转租。摊位多了，你可以卖各种特产，但是最受大家欢迎的水果特产不能在你自己的摊位卖。企鹅很高兴，除了水果，其他的特产想卖什么就卖什么，而且这次租赁的新摊位都在前几排的位置，顾客会很多。兴奋的企鹅回家后开始计划这些摊位都卖什么东西，最后它发现，这么多东西都自己卖太累了，不如让其他摊位的人每天那一点特产放到自己的摊位卖，最后跟他们分钱就可以了。说干就干，企鹅开始在小镇张贴广告，说大家的特产可以放在企鹅的摊位卖，它的摊位顾客多，这样可以多卖一些。一些小镇居民将信将疑，一些本来生意就不怎么好的居民则直接同意了企鹅的方案。</p><p>第二天果不其然，企鹅的摊位不仅大，而且特产齐全，唯独没有水果。众人不解，但也没人在意。因为企鹅的摊位位置好，顾客多，所以很多人都有所受益，一些人想：”既然把特产放在企鹅的摊位就可以赚钱，自己的摊位位置不好，顾客又少，那还租摊位干啥？直接把特产交给企鹅，然后晚上等着收钱就得了呗！“于是，大家每天只负责把特产放到企鹅摊位，其他的也不再理会。</p><p>企鹅的生意越做越大，越做越好，集市中除了卖水果，买其他的特产基本上都从企鹅的摊位购买。由于企鹅的摊位太火爆，其他摊位的顾客越来越少，最后难以支撑摊位的租金，从而纷纷退租摊位。</p><p>这一天企鹅一天忙碌完集市的事情，高兴的数着手里的钱。一边数，一边走去卖水果的摊位。看着摊位上那些又大又甜的水果，企鹅心里不禁暗想。现在自己的摊位什么都有，其他的摊位几乎没有生存的余地，都纷纷退租。当初农夫不同意将摊位承包给我真是愚蠢，现在这么多摊位空着，根本没有收益，而我也仅仅租赁了前排好位置的摊位，对于农夫来说真是得不偿失啊。如果自己的摊位也能卖水果类的特产那就更好了，这样这几家摊位也会被我排挤走。到时候这个集市其实就是我企鹅的集市了。而农夫也仅仅会收我摊位租金而已。如此想着，企鹅的眼睛都快眯成了一条线。忽然农夫出现在企鹅眼前，并对企鹅说：”你这么做太过了，排挤了其他摊位，自己还觊觎水果特产，这个集市不能再留你了。从明天开始这里的所有摊位将不会再租赁给你“。企鹅瞬间惊出一身冷汗，从床上翻滚到地板。原来这是一场梦啊，但明天摊位到底卖什么才好？</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;比特小镇的集市&quot;&gt;&lt;a href=&quot;#比特小镇的集市&quot; class=&quot;headerlink&quot; title=&quot;比特小镇的集市&quot;&gt;&lt;/a&gt;比特小镇的集市&lt;/h1&gt;&lt;p&gt;从前有个叫比特的小镇，镇子上的居民过着无忧无虑的生活，但令大家最为头痛的事情是每天都要翻山越岭，经过长达十几里的路程到另外一个地方参加集市。小镇有很多特产，每次小镇的居民都会带着不同的特产去参加集会，来交换自己所需要的生活物品。忽然有一天，小镇来了一个农夫，农夫说：“大家每天这么辛苦的跑来跑去，只能换取一点点东西，不划算啊！这样吧，我来建一条公路，每天提供货车，大家知道交一点点过路费就好了。“小镇的居民商量了一下，觉得可以。公路建成那天大家兴高采烈的乘着农夫的货车去往集市。&lt;/p&gt;
&lt;p&gt;时间过得很快，转眼一年多过去了，农夫算了算一年的收益，发现光收取过路费对于成本会有有点困难，毕竟公路还需要修修补补，这也是不小的开销。怎么办呢？如果增加过路费的话，小镇居民肯定不同意，想了又想也没有什么好主意。这天农夫的司机马突然说道，既然路程这么远，公路维护费用这么高，不如我们在路中间的位置开辟一个新的集市，让两边的人在新集市交易多好。这样不仅有双份的过路费，同时集市的摊位还能挣钱。农夫立刻同意，着手开始修建集市。&lt;br&gt;
    
    </summary>
    
      <category term="程序员的那些事" scheme="http://jihong.xyz/categories/programer/"/>
    
    
      <category term="碎片" scheme="http://jihong.xyz/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>IEEE754 浮点数范围</title>
    <link href="http://jihong.xyz/computer-principle/IEEE754-%E6%B5%AE%E7%82%B9%E6%95%B0%E8%8C%83%E5%9B%B4%E4%B8%8E%E7%B2%BE%E5%BA%A6/"/>
    <id>http://jihong.xyz/computer-principle/IEEE754-浮点数范围与精度/</id>
    <published>2016-11-14T05:46:06.000Z</published>
    <updated>2018-03-04T02:36:35.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前一直觉得对浮点数这一块都弄清楚了，但是才过了不到一个月，又记不太清楚了。说明对于这个问题还是理解得不够深刻，于是趁机复习了一遍。对浮点数的范围与精度又有了新的认识。关于浮点数与浮点数精度丢失的问题在<a href="http://jihong.xyz/computer-principle/float与double精度丢失的问题/" target="_blank" rel="noopener">float与double精度丢失的问题</a>里有解释，这里就不再赘述了。</p><h2 id="浮点数的范围"><a href="#浮点数的范围" class="headerlink" title="浮点数的范围"></a>浮点数的范围</h2><p>都知道浮点数的存储是分为[sign][exponent][significand]三个部分的，而阶码采用了偏置位来计算。也就是E=e-Bias，Bias=2^(k-1) - 1，k为阶码的位数。</p><ul><li>关于Bias，其实这个和补码的原理是一样的，但是为什么不直接采取补码？这个在之前的文章里也解释过，是因为不需要再重新设计一套电路来判断符号位，直接使用偏置位来使其能够表示负数。</li><li>关于补码，可以查看我之前写的<a href="http://blublu.xyz/computer-principle/关于二进制运算中的原码反码补码的一些理解/" target="_blank" rel="noopener">关于二进制运算中的原码反码补码的一些理解</a></li></ul><p>下面开始进入正题：<br>如果是32位的float格式，那么指数E的范围就是-126~127。为什么是-126~127？因为阶码为<code>0</code>与<code>255</code>时都为非规格化数与特殊值(Inf or Nan)，另有它用了。所以实际上我们能用的数就是1~254，很显然偏置位Bias=127，那么E的最小值为<code>1-127=-126</code>，最大值为<code>254-127=127</code>。如果你还非要问为什么Bias=2^(k-1) - 1 的话，那么其实是这样的：(2^k - 2)/2=2^(k-1) - 1。因为[00..0]与[11..1]这两个阶码被使用作为表示非规格化数与特殊值了，所以总的能表示其它数字的个数只剩下2^k - 2个。</p><p>好了我们来讨论浮点数的范围，既然指数的值为-126~127，那么所能表达的最大的数当然是1.1111111…1<sub>23位</sub> * 2^127 近似于2^128 = 3.40E^38 ，那么负数亦然，只需要把符号位改为1即可。所以float的范围为-3.40E^38 ~ 3.40E^38 。double类型也是如此，因为double的指数范围为<code>-1022 ~ 1023</code>,所以最大能表示的数值约等于2^1024 = 1.7E^308 。所以double的范围为-1.7E^308 ~ 1.7E^308。</p><hr><a id="more"></a><h3 id="几点容易弄混的地方"><a href="#几点容易弄混的地方" class="headerlink" title="几点容易弄混的地方"></a>几点容易弄混的地方</h3><p>有好几个地方我特别容易弄混，好几次了都纠缠在这上面</p><ul><li>当阶码为01111111(float)时，也就是正好表示127时，那么E是为0的，这个与±0.0毫无关系，±0.0是根据阶码<code>00000000</code>来表示的。(浮点数是有±0.0之分的)</li></ul><ul><li>为什么非规格化数的指数E=1-Bias，而不是E=0-Bias？这正是IEEE 754 巧妙的地方。因为非规格化数尾数是没有隐含位1的，而通过E=0-Bias+1弥补了尾数没有隐含位1的这一事实。为什么是+1？假设最小规格化数为0 0001 000，最大非规格化数为0 0000 111，那么我们人为地使指数增加1让它们的指数级别一样，这样就可以平滑地从0.111转变为1.000。</li></ul><ul><li><p>非规格化数的另外一个功能是表示那些非常接近于0.0的数。他们提供了一种逐渐溢出的属性，可能的数值分布均匀地接近于0.0。</p></li><li><p>精度对于指数E为负数同样有效，指数为负数是因为右移了小数点使其接近最左边的1，指数的大小通过右移的位数来决定的。右移到1.x形式为至。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前一直觉得对浮点数这一块都弄清楚了，但是才过了不到一个月，又记不太清楚了。说明对于这个问题还是理解得不够深刻，于是趁机复习了一遍。对浮点数的范围与精度又有了新的认识。关于浮点数与浮点数精度丢失的问题在&lt;a href=&quot;http://jihong.xyz/computer-principle/float与double精度丢失的问题/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;float与double精度丢失的问题&lt;/a&gt;里有解释，这里就不再赘述了。&lt;/p&gt;
&lt;h2 id=&quot;浮点数的范围&quot;&gt;&lt;a href=&quot;#浮点数的范围&quot; class=&quot;headerlink&quot; title=&quot;浮点数的范围&quot;&gt;&lt;/a&gt;浮点数的范围&lt;/h2&gt;&lt;p&gt;都知道浮点数的存储是分为[sign][exponent][significand]三个部分的，而阶码采用了偏置位来计算。也就是E=e-Bias，Bias=2^(k-1) - 1，k为阶码的位数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关于Bias，其实这个和补码的原理是一样的，但是为什么不直接采取补码？这个在之前的文章里也解释过，是因为不需要再重新设计一套电路来判断符号位，直接使用偏置位来使其能够表示负数。&lt;/li&gt;
&lt;li&gt;关于补码，可以查看我之前写的&lt;a href=&quot;http://blublu.xyz/computer-principle/关于二进制运算中的原码反码补码的一些理解/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;关于二进制运算中的原码反码补码的一些理解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面开始进入正题：&lt;br&gt;如果是32位的float格式，那么指数E的范围就是-126~127。为什么是-126~127？因为阶码为&lt;code&gt;0&lt;/code&gt;与&lt;code&gt;255&lt;/code&gt;时都为非规格化数与特殊值(Inf or Nan)，另有它用了。所以实际上我们能用的数就是1~254，很显然偏置位Bias=127，那么E的最小值为&lt;code&gt;1-127=-126&lt;/code&gt;，最大值为&lt;code&gt;254-127=127&lt;/code&gt;。如果你还非要问为什么Bias=2^(k-1) - 1 的话，那么其实是这样的：(2^k - 2)/2=2^(k-1) - 1。因为[00..0]与[11..1]这两个阶码被使用作为表示非规格化数与特殊值了，所以总的能表示其它数字的个数只剩下2^k - 2个。&lt;/p&gt;
&lt;p&gt;好了我们来讨论浮点数的范围，既然指数的值为-126~127，那么所能表达的最大的数当然是1.1111111…1&lt;sub&gt;23位&lt;/sub&gt; * 2^127 近似于2^128 = 3.40E^38 ，那么负数亦然，只需要把符号位改为1即可。所以float的范围为-3.40E^38 ~ 3.40E^38 。double类型也是如此，因为double的指数范围为&lt;code&gt;-1022 ~ 1023&lt;/code&gt;,所以最大能表示的数值约等于2^1024 = 1.7E^308 。所以double的范围为-1.7E^308 ~ 1.7E^308。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="http://jihong.xyz/categories/computer-principle/"/>
    
    
      <category term="编程素养" scheme="http://jihong.xyz/tags/Programming-literacy/"/>
    
  </entry>
  
  <entry>
    <title>计组作业-第三章</title>
    <link href="http://jihong.xyz/computer-principle/%E8%AE%A1%E7%BB%84%E4%BD%9C%E4%B8%9A-%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <id>http://jihong.xyz/computer-principle/计组作业-第三章/</id>
    <published>2016-11-05T12:06:27.000Z</published>
    <updated>2018-03-04T07:44:05.313Z</updated>
    
    <content type="html"><![CDATA[<h6 id="3-54"><a href="#3-54" class="headerlink" title="3.54"></a>3.54</h6><p>一个函数的原型为<br><code>int decode2(int x, int y, int z);</code></p><p>将这个函数编译成 IA32 汇编代码。代码体如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">movl    16(%ebp), %edx</div><div class="line">subl    12(%ebp), %edx</div><div class="line">movl    %edx, %eax</div><div class="line">sall    $15, %eax</div><div class="line">sarl    $15, %eax</div><div class="line">xorl    8(%ebp), %edx</div><div class="line">imull   %edx, %eax</div><div class="line"># x at %ebp+8, y at %ebp+12, z at %ebp+16</div></pre></td></tr></table></figure><p>参数 x、y 和 z 存放在存储器中相对于寄存器 %ebp 中地址偏移量为 8、12 和 16的地方。代码将返回值存放在寄存器 %eax 中。写出等价于我们汇编代码的 decode2 的 C 代码。</p><p><strong>答：</strong></p><table><thead><tr><th style="text-align:center">sal</th><th style="text-align:center">算术左移指令</th></tr></thead><tbody><tr><td style="text-align:center">sar</td><td style="text-align:center">算术右移指令</td></tr><tr><td style="text-align:center">xor</td><td style="text-align:center">异或指令</td></tr><tr><td style="text-align:center">imul</td><td style="text-align:center">有符号数乘法指令</td></tr></tbody></table><p>所以根据以上汇编代码可以得到等价的C代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">decode2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> temp = z-y;</div><div class="line">    <span class="keyword">return</span> (temp ^ x) * (temp &lt;&lt; <span class="number">15</span> &gt;&gt; <span class="number">15</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><a id="more"></a><h6 id="3-56"><a href="#3-56" class="headerlink" title="3.56"></a>3.56</h6><p>考虑下面的汇编代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">movl    8(%ebp), %esi</div><div class="line">movl    12(%ebp), %ebx</div><div class="line">movl    $1431655765, %edi</div><div class="line">movl    $-2147483648, %edx</div><div class="line">.L2:</div><div class="line">movl    %edx, %eax</div><div class="line">andl    %esi, %eax</div><div class="line">xorl    %eax, %edi</div><div class="line">movl    %ebx, %ecx</div><div class="line">shrl    %cl, %edx</div><div class="line">testl   %edx, %edx</div><div class="line">jne     .L2</div><div class="line">movl    %edi, %eax</div><div class="line"># x at %ebp+8, n at %ebp+12</div></pre></td></tr></table></figure><p>以上代码是以下整体形式的 C 代码编译产生的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">loop</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> result = <span class="number">____</span>;</div><div class="line">    <span class="keyword">int</span> mask;</div><div class="line">    <span class="keyword">for</span> (mask = <span class="number">____</span>; mask <span class="number">____</span>; mask = <span class="number">____</span>) &#123;</div><div class="line">        result ^= <span class="number">____</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>你的任务是填写这个 C 代码中缺失的部分，得到一个程序等价于产生的汇编代码。回想一下，这个函数的结果是在寄存器 %eax 中返回的。你会发现以下工作很有帮助：检查循环之前、之中和之后的汇编代码，形成一个寄存器和程序变量之间一致的映射。</p><p>A. 哪个寄存器保存着程序值 x、n、result 和 mask？<br>B. result 和 mask 的初始值是什么？<br>C. mask 的测试条件是什么？<br>D. mask 是如何被修改的？<br>E. result 是如何被修改的？<br>F. 填写这段 C 代码中所有缺失的部分。</p><p><strong>答：</strong><br>A. </p><table><thead><tr><th style="text-align:center">寄存器</th><th style="text-align:center">对应的程序变量</th></tr></thead><tbody><tr><td style="text-align:center">esi</td><td style="text-align:center">x</td></tr><tr><td style="text-align:center">ebx</td><td style="text-align:center">n</td></tr><tr><td style="text-align:center">edi</td><td style="text-align:center">result</td></tr><tr><td style="text-align:center">edx</td><td style="text-align:center">mask</td></tr></tbody></table><p>B.result的初始值为<code>0x55555555</code>，mask的初始值为<code>0x8fffffff</code><br>C.根据<code>testl   %edx, %edx</code> 与 <code>jne     .L2</code>语句可知mask的测试条件是 <code>mask!=0</code><br>D.根据<code>movl    %edx, %eax</code>、<code>movl    %ebx, %ecx</code> 与 <code>shrl    %cl, %edx</code>语句可以知道，mask右移的位数为cl，也就是n的低八位，所以相当于<code>mask = (unsigned)mask &gt;&gt; n&amp;0xff</code>，因为若mask不强转为unsigned类型，移位之后会被符号位（1）填充，mask != 0将一直成立，for循环会死循环。<br>E.根据<code>andl    %esi, %eax</code> 与 <code>xorl    %eax, %edi</code>语句可以得到 result ^= (x &amp; mask)<br>F.完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">loop</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> result = <span class="number">0x55555555</span>;</div><div class="line">    <span class="keyword">int</span> mask;</div><div class="line">    <span class="keyword">for</span> (mask = <span class="number">0x8fffffff</span>; mask != <span class="number">0</span>; mask = (<span class="keyword">unsigned</span>)mask &gt;&gt; n&amp;<span class="number">0xff</span>) &#123;</div><div class="line">        result ^= (x &amp; mask);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h6 id="3-58"><a href="#3-58" class="headerlink" title="3.58"></a>3.58</h6><p>下面的代码是在一个开关语句中根据枚举类型值进行分支选择的例子。回忆一下，C语言中枚举类型只是一种引入一组与整数值相对应的名字的方法。默认情况下，值是从 0 向上依次赋给名字的。在我们的代码中，省略了与各种情况标号相对应的动作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Enumerated type creates set of constants numbered 0 and upward */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; MODE_A, MODE_B, MODE_C, MODE_D, MODE_E &#125; <span class="keyword">mode_t</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">switch3</span><span class="params">(<span class="keyword">int</span> *p1, <span class="keyword">int</span> *p2, <span class="keyword">mode_t</span> action)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">    <span class="keyword">switch</span> (action) &#123;</div><div class="line">        <span class="keyword">case</span> MODE_A:</div><div class="line">        <span class="keyword">case</span> MODE_B:</div><div class="line">        <span class="keyword">case</span> MODE_C:</div><div class="line">        <span class="keyword">case</span> MODE_D:</div><div class="line">        <span class="keyword">case</span> MODE_E:</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>产生的实现各个动作的汇编代码部分如下所示。注释指明了参数位置，寄存器值，以及各个跳转目的的情况标号。寄存器 %edx 对应于程序变量 result，并被初始化为-1。<strong>填写 C 代码中缺失的部分。注意那些会落入其他情况中的情况。</strong></p><p>Arguments: p1 at %ebp+8, p2 at %ebp+12, action at %ebp+16<br>Registers: result in %edx (initialized to -1)<br>The jump targets:</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">.L17:                   # MODE_E</div><div class="line">movl  $17, %edx</div><div class="line">jmp   .L19</div><div class="line">.L13:                   # MODE_A</div><div class="line">movl  8(%ebp), %eax</div><div class="line">movl  (%eax), %edx</div><div class="line">movl  12(%ebp), %ecx</div><div class="line">movl  (%ecx), %eax</div><div class="line">movl  8(%ebp), %ecx</div><div class="line">movl  %eax, (%ecx)</div><div class="line">jmp   .L19</div><div class="line">.L14:                   # MODE_B</div><div class="line">movl  12(%ebp), %edx</div><div class="line">movl  (%edx), %eax</div><div class="line">movl  %eax, %edx</div><div class="line">movl  8(%ebp), %ecx</div><div class="line">addl  (%ecx), %edx</div><div class="line">movl  12(%ebp), %eax</div><div class="line">movl  %edx, (%eax)</div><div class="line">jmp   .L19</div><div class="line">.L15:                   # MODE_C</div><div class="line">movl  12(%ebp), %edx</div><div class="line">movl  $15, (%edx)</div><div class="line">movl  8(%ebp), %ecx</div><div class="line">movl  (%ecx), %edx</div><div class="line">jmp   .L19</div><div class="line">.L16:                   # MODE_D</div><div class="line">movl  8(%ebp), %edx</div><div class="line">movl  (%edx), %eax</div><div class="line">movl  12(%ebp), %ecx</div><div class="line">movl  %eax, (%ecx)</div><div class="line">movl  $17, %edx</div><div class="line">.L19:                   # default</div><div class="line">movl  %edx, %eax      # Set return value</div><div class="line">     上面的代码实现了 switch 语句的各个分支</div></pre></td></tr></table></figure><p><strong>答：</strong><br>根据汇编代码填写的C代码缺失部分如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; MODE_A, MODE_B, MODE_C, MODE_D, MODE_E &#125; <span class="keyword">mode_t</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">switch3</span><span class="params">(<span class="keyword">int</span> *p1, <span class="keyword">int</span> *p2, <span class="keyword">mode_t</span> action)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">    <span class="keyword">switch</span> (action) &#123;</div><div class="line">        <span class="keyword">case</span> MODE_A:</div><div class="line">            result = *p1;</div><div class="line">            *p1 = *p2;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MODE_B:</div><div class="line">            result = p2;</div><div class="line">            result = *p2;</div><div class="line">            result += *p1;</div><div class="line">            *p2 = result;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MODE_C:</div><div class="line">            *p2 = <span class="number">15</span>;</div><div class="line">            result = *p1;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MODE_D:</div><div class="line">            *p2 = *p1;</div><div class="line">            result = <span class="number">17</span>; </div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MODE_E:</div><div class="line">            result = <span class="number">17</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h6 id="3-62"><a href="#3-62" class="headerlink" title="3.62"></a>3.62</h6><p>下面的代码转置一个 MxM 矩阵的元素，这里 M 是一个用 #define 定义的常数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose</span><span class="params">(<span class="keyword">int</span> A[M][M])</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i,j;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++) &#123;</div><div class="line">            <span class="keyword">int</span> t = A[i][j];</div><div class="line">            A[i][j] = A[j][i];</div><div class="line">            A[j][i] = t;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当用优化等级 -O2 编译时，GCC 为这个函数的内部循环产生下面的代码：</p><figure class="highlight as"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.L3:</div><div class="line">movl (%ebx), %eax</div><div class="line">movl (%esi,%ecx,<span class="number">4</span>), %edx</div><div class="line">movl %eax, (%esi,%ecx,<span class="number">4</span>)</div><div class="line">addl $<span class="number">1</span>, %ecx</div><div class="line">movl %edx, (%ebx)</div><div class="line">addl $<span class="number">76</span>, %ebx</div><div class="line">cmpl %edi, %ecx</div><div class="line">jl   .L3</div></pre></td></tr></table></figure><p>A. M 的值是多少？<br>B. 哪个寄存器保存着程序值 i 和 j？<br>C. 写 transpose 的一个 C 代码版本，使用在这个循环中出现的优化。在你的代码中，使用参数 M，而不要使用常数值。</p><p><strong>答：</strong><br>A. M 的值为19<br>B. ecx寄存器保存着j的值，edi寄存器保存着i的值。(cmpl s2,s1指令，s1-s2差关系)<br>C. 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose</span><span class="params">(<span class="keyword">int</span> A[M][M], <span class="keyword">int</span> M)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i,j;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;M; i++)&#123;</div><div class="line">        <span class="keyword">int</span> *p = &amp;A[i][<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</div><div class="line">            <span class="keyword">int</span> temp = A[i][j];</div><div class="line">            A[i][j] = *p;</div><div class="line">            *p = temp;</div><div class="line">            p += <span class="number">19</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h6 id="3-66"><a href="#3-66" class="headerlink" title="3.66"></a>3.66</h6><p>你负责维护一个大型的 C 程序时，遇到下面这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">     <span class="keyword">int</span> left;</div><div class="line">     a_struct a[CNT];</div><div class="line">     <span class="keyword">int</span> right;</div><div class="line">&#125; b_struct;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> i, b_struct *bp)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n = bp-&gt;left + bp-&gt;right;</div><div class="line">    a_struct *ap = &amp;bp-&gt;a[i];</div><div class="line">    ap-&gt;x[ap-&gt;idx] = n;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>编译时常数 CNT 和结构 a_struct 的声明在一个你没有访问权限的文件中。幸好，你有代码的’.o’版本，可以用 objdump 程序来反汇编这些文件，得到下面的反汇编代码：</p><figure class="highlight as"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="number">00000000</span> &lt;test&gt;:</div><div class="line"><span class="number">0</span>:  <span class="number">55</span>                   push %ebp</div><div class="line"><span class="number">1</span>:  <span class="number">89</span> e5                mov %esp, %ebp</div><div class="line"><span class="number">3</span>:  <span class="number">53</span>                   push %ebx</div><div class="line"><span class="number">4</span>:  <span class="number">8</span>b <span class="number">45</span> <span class="number">08</span>             mov <span class="number">0x8</span>(%ebp), %eax</div><div class="line"><span class="number">7</span>:  <span class="number">8</span>b <span class="number">4</span>d <span class="number">0</span>c             mov <span class="number">0xc</span>(%ebp), %ecx</div><div class="line">a:  <span class="number">6</span>b d8 <span class="number">1</span>c             imul $<span class="number">0x1c</span>, %eax, %ebx</div><div class="line">d:  <span class="number">8</span>d <span class="number">14</span> c5 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> lea <span class="number">0x0</span>(,%eax,<span class="number">8</span>), %edx</div><div class="line"><span class="number">14</span>: <span class="number">29</span> c2                sub %eax, %edx</div><div class="line"><span class="number">16</span>: <span class="number">03</span> <span class="number">54</span> <span class="number">19</span> <span class="number">04</span>          add <span class="number">0x4</span>(%ecx,%ebx,<span class="number">1</span>), %edx</div><div class="line"><span class="number">1</span>a: <span class="number">8</span>b <span class="number">81</span> c3 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    mov <span class="number">0xc8</span>(%ecx), %eax</div><div class="line"><span class="number">20</span>: <span class="number">03</span> <span class="number">01</span>                add (%ecx), %eax</div><div class="line"><span class="number">22</span>: <span class="number">89</span> <span class="number">44</span> <span class="number">91</span> <span class="number">08</span>          mov %eax, <span class="number">0x8</span>(%ecx,%edx,<span class="number">4</span>)</div><div class="line"><span class="number">25</span>: <span class="number">5</span>b                   pop %ebx</div><div class="line"><span class="number">27</span>: <span class="number">5</span>d                   pop %ebp</div><div class="line"><span class="number">28</span>: c3                   ret</div></pre></td></tr></table></figure><p>运用你的逆向工程技术，推断下列的内容：<br>A. CNT 的值<br>B. 结构 a_struct 的完整声明。假设这个结构只有字段 idx 和 x。</p><p><strong>答：</strong><br>A. CNT的值为7<br>B. a_struct的完整声明如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> a_struct&#123;</div><div class="line">    <span class="keyword">int</span> idx;</div><div class="line">    <span class="keyword">int</span> x[<span class="number">6</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>整段代码顺序看不容易理解，所以倒序推导。首先根据第13行<code>mov %eax, 0x8(%ecx,%edx,4)</code>可知道其等价于C代码中的<code>ap-&gt;x[ap-&gt;idx] = n</code>语句。那么自然而然%eax就是n了，后面<code>%ecx + %edx*4 + 8</code>语句就是<code>a[i]-&gt;x[ap-&gt;idx]</code>。再根据第6行<code>mov 0xc(%ebp), %ecx</code>语句可知%ecx就是<code>bp</code>指针。所以<code>%edx*4 + 8</code>就相当于对于<code>bp</code>指针的偏移量。<br>再往上看第11行<code>mov 0xc8(%ecx), %eax</code>还有第12行<code>add (%ecx), %eax</code>，其实就相当于C代码中的<code>int n = bp-&gt;left + bp-&gt;right</code>。由此可知bp-&gt;right相对于bp-left偏移了0xc8(200)个字节。那么<code>a[CNT]</code>的空间就应该为<code>200-4=196</code>字节。<br>再看看第7行<code>imul $0x1c, %eax, %ebx</code>，可以猜想到ebx应该存放的是相对于a[0]地址的偏移量，28*i。由于i是下标，所以很显然就可以得到<code>196/28=7</code>个<code>a_struct</code>数组，且<code>a_struct</code>结构体占用的空间为 28 字节。</p><table><thead><tr><th style="text-align:center">int left</th><th style="text-align:center">4字节</th></tr></thead><tbody><tr><td style="text-align:center">a[0]</td><td style="text-align:center">28字节</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">a[6]</td><td style="text-align:center">28字节</td></tr><tr><td style="text-align:center">int right</td><td style="text-align:center">4字节</td></tr></tbody></table><p>整个内存空间如上所示。</p><figure class="highlight as"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">d:  <span class="number">8</span>d <span class="number">14</span> c5 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> lea <span class="number">0x0</span>(,%eax,<span class="number">8</span>), %edx</div><div class="line"><span class="number">14</span>: <span class="number">29</span> c2                sub %eax, %edx</div><div class="line"><span class="number">16</span>: <span class="number">03</span> <span class="number">54</span> <span class="number">19</span> <span class="number">04</span>          add <span class="number">0x4</span>(%ecx,%ebx,<span class="number">1</span>), %edx<span class="comment">//7i+idx</span></div></pre></td></tr></table></figure><p>根据这三条语句以及之前得出的<code>%edx*4 + 8</code>为x[a[i]-&gt;idx]相对于bp的偏移量，7i为相对于<code>left</code>的偏移量，idx为相对于<code>idx</code>的偏移量。最后+8是把<code>left</code>还有<code>idx</code>的偏移量算上。<br>综上推测，整个汇编满足<code>void test(int i, b_struct *bp)</code>函数所表达的功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;3-54&quot;&gt;&lt;a href=&quot;#3-54&quot; class=&quot;headerlink&quot; title=&quot;3.54&quot;&gt;&lt;/a&gt;3.54&lt;/h6&gt;&lt;p&gt;一个函数的原型为&lt;br&gt;&lt;code&gt;int decode2(int x, int y, int z);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将这个函数编译成 IA32 汇编代码。代码体如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;movl    16(%ebp), %edx&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;subl    12(%ebp), %edx&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;movl    %edx, %eax&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;sall    $15, %eax&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;sarl    $15, %eax&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;xorl    8(%ebp), %edx&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;imull   %edx, %eax&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# x at %ebp+8, y at %ebp+12, z at %ebp+16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;参数 x、y 和 z 存放在存储器中相对于寄存器 %ebp 中地址偏移量为 8、12 和 16的地方。代码将返回值存放在寄存器 %eax 中。写出等价于我们汇编代码的 decode2 的 C 代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;sal&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;算术左移指令&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;sar&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;算术右移指令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;xor&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;异或指令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;imul&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;有符号数乘法指令&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;所以根据以上汇编代码可以得到等价的C代码如下:&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;decode2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; z)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; temp = z-y;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (temp ^ x) * (temp &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt; &amp;gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="http://jihong.xyz/categories/computer-principle/"/>
    
    
      <category term="编程素养" scheme="http://jihong.xyz/tags/Programming-literacy/"/>
    
  </entry>
  
  <entry>
    <title>浮点数除0与整数除0的问题</title>
    <link href="http://jihong.xyz/computer-principle/%E6%B5%AE%E7%82%B9%E6%95%B0%E9%99%A40%E4%B8%8E%E6%95%B4%E6%95%B0%E9%99%A40%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://jihong.xyz/computer-principle/浮点数除0与整数除0的问题/</id>
    <published>2016-11-04T11:02:45.000Z</published>
    <updated>2016-11-07T12:45:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整数的除运算"><a href="#整数的除运算" class="headerlink" title="整数的除运算"></a>整数的除运算</h2><p>代码一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> a = <span class="number">0x80000000</span>;</div><div class="line"><span class="keyword">int</span> b = a/<span class="number">-1</span>;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,b );</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>代码二：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> a = <span class="number">0x80000000</span>;</div><div class="line"><span class="keyword">int</span> b = a/<span class="number">-1</span>;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,b );</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><p>虽然以上两段代码看起来的功能都是一样的，就是变量 a 除以 -1 。但是实际运行起来的结果却迥然不同。<br><strong>第一段代码的结果：</strong><br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-11-07-122347.jpg" alt=""><br><strong>第二段代码的结果：</strong><br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-11-07-122401.jpg" alt=""><br>和我们预想的两段代码的结果一致预期不符。为了弄清楚原因，反汇编是最好的选择。<br>第一段代码的汇编代码：</p><figure class="highlight as"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="number">0804840</span>b &lt;main&gt;:</div><div class="line"><span class="number">804840</span>b:   <span class="number">8</span>d <span class="number">4</span>c <span class="number">24</span> <span class="number">04</span>             lea    <span class="number">0x4</span>(%esp),%ecx</div><div class="line"><span class="number">804840</span>f:   <span class="number">83</span> e4 f0                and    $<span class="number">0xfffffff0</span>,%esp</div><div class="line"><span class="number">8048412</span>:   ff <span class="number">71</span> fc                pushl  <span class="number">-0x4</span>(%ecx)</div><div class="line"><span class="number">8048415</span>:   <span class="number">55</span>                      push   %ebp</div><div class="line"><span class="number">8048416</span>:   <span class="number">89</span> e5                   mov    %esp,%ebp</div><div class="line"><span class="number">8048418</span>:   <span class="number">51</span>                      push   %ecx</div><div class="line"><span class="number">8048419</span>:   <span class="number">83</span> ec <span class="number">14</span>                sub    $<span class="number">0x14</span>,%esp</div><div class="line"><span class="number">804841</span>c:   c7 <span class="number">45</span> f0 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">80</span>    movl   $<span class="number">0x80000000</span>,<span class="number">-0x10</span>(%ebp)</div><div class="line"><span class="number">8048423</span>:   <span class="number">8</span>b <span class="number">45</span> f0                mov    <span class="number">-0x10</span>(%ebp),%eax</div><div class="line"><span class="number">8048426</span>:   f7 d8                   neg    %eax</div><div class="line"><span class="number">8048428</span>:   <span class="number">89</span> <span class="number">45</span> f4                mov    %eax,<span class="number">-0xc</span>(%ebp)</div><div class="line"><span class="number">804842</span>b:   <span class="number">83</span> ec <span class="number">08</span>                sub    $<span class="number">0x8</span>,%esp</div><div class="line"><span class="number">804842</span>e:   ff <span class="number">75</span> f4                pushl  <span class="number">-0xc</span>(%ebp)</div><div class="line"><span class="number">8048431</span>:   <span class="number">68</span> d0 <span class="number">84</span> <span class="number">04</span> <span class="number">08</span>          push   $<span class="number">0x80484d0</span></div><div class="line"><span class="number">8048436</span>:   e8 a5 fe ff ff          call   <span class="number">80482e0</span> &lt;printf@plt&gt;</div><div class="line"><span class="number">804843</span>b:   <span class="number">83</span> c4 <span class="number">10</span>                add    $<span class="number">0x10</span>,%esp</div><div class="line"><span class="number">804843</span>e:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</div><div class="line"><span class="number">8048443</span>:   <span class="number">8</span>b <span class="number">4</span>d fc                mov    <span class="number">-0x4</span>(%ebp),%ecx</div><div class="line"><span class="number">8048446</span>:   c9                      leave  </div><div class="line"><span class="number">8048447</span>:   <span class="number">8</span>d <span class="number">61</span> fc                lea    <span class="number">-0x4</span>(%ecx),%esp</div><div class="line"><span class="number">804844</span>a:   c3                      ret    </div><div class="line"><span class="number">804844</span>b:   <span class="number">66</span> <span class="number">90</span>                   xchg   %ax,%ax</div><div class="line"><span class="number">804844</span>d:   <span class="number">66</span> <span class="number">90</span>                   xchg   %ax,%ax</div><div class="line"><span class="number">804844</span>f:   <span class="number">90</span>                      nop</div></pre></td></tr></table></figure><p>第二段代码的汇编代码：</p><figure class="highlight as"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="number">0804840</span>b &lt;main&gt;:</div><div class="line"><span class="number">804840</span>b:   <span class="number">8</span>d <span class="number">4</span>c <span class="number">24</span> <span class="number">04</span>             lea    <span class="number">0x4</span>(%esp),%ecx</div><div class="line"><span class="number">804840</span>f:   <span class="number">83</span> e4 f0                and    $<span class="number">0xfffffff0</span>,%esp</div><div class="line"><span class="number">8048412</span>:   ff <span class="number">71</span> fc                pushl  <span class="number">-0x4</span>(%ecx)</div><div class="line"><span class="number">8048415</span>:   <span class="number">55</span>                      push   %ebp</div><div class="line"><span class="number">8048416</span>:   <span class="number">89</span> e5                   mov    %esp,%ebp</div><div class="line"><span class="number">8048418</span>:   <span class="number">51</span>                      push   %ecx</div><div class="line"><span class="number">8048419</span>:   <span class="number">83</span> ec <span class="number">14</span>                sub    $<span class="number">0x14</span>,%esp</div><div class="line"><span class="number">804841</span>c:   c7 <span class="number">45</span> ec <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">80</span>    movl   $<span class="number">0x80000000</span>,<span class="number">-0x14</span>(%ebp)</div><div class="line"><span class="number">8048423</span>:   c7 <span class="number">45</span> f0 ff ff ff ff    movl   $<span class="number">0xffffffff</span>,<span class="number">-0x10</span>(%ebp)</div><div class="line"><span class="number">804842</span>a:   <span class="number">8</span>b <span class="number">45</span> ec                mov    <span class="number">-0x14</span>(%ebp),%eax</div><div class="line"><span class="number">804842</span>d:   <span class="number">99</span>                      cltd   </div><div class="line"><span class="number">804842</span>e:   f7 <span class="number">7</span>d f0                idivl  <span class="number">-0x10</span>(%ebp)</div><div class="line"><span class="number">8048431</span>:   <span class="number">89</span> <span class="number">45</span> f4                mov    %eax,<span class="number">-0xc</span>(%ebp)</div><div class="line"><span class="number">8048434</span>:   <span class="number">83</span> ec <span class="number">08</span>                sub    $<span class="number">0x8</span>,%esp</div><div class="line"><span class="number">8048437</span>:   ff <span class="number">75</span> f4                pushl  <span class="number">-0xc</span>(%ebp)</div><div class="line"><span class="number">804843</span>a:   <span class="number">68</span> e0 <span class="number">84</span> <span class="number">04</span> <span class="number">08</span>          push   $<span class="number">0x80484e0</span></div><div class="line"><span class="number">804843</span>f:   e8 <span class="number">9</span>c fe ff ff          call   <span class="number">80482e0</span> &lt;printf@plt&gt;</div><div class="line"><span class="number">8048444</span>:   <span class="number">83</span> c4 <span class="number">10</span>                add    $<span class="number">0x10</span>,%esp</div><div class="line"><span class="number">8048447</span>:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</div><div class="line"><span class="number">804844</span>c:   <span class="number">8</span>b <span class="number">4</span>d fc                mov    <span class="number">-0x4</span>(%ebp),%ecx</div><div class="line"><span class="number">804844</span>f:   c9                      leave  </div><div class="line"><span class="number">8048450</span>:   <span class="number">8</span>d <span class="number">61</span> fc                lea    <span class="number">-0x4</span>(%ecx),%esp</div><div class="line"><span class="number">8048453</span>:   c3                      ret    </div><div class="line"><span class="number">8048454</span>:   <span class="number">66</span> <span class="number">90</span>                   xchg   %ax,%ax</div><div class="line"><span class="number">8048456</span>:   <span class="number">66</span> <span class="number">90</span>                   xchg   %ax,%ax</div><div class="line"><span class="number">8048458</span>:   <span class="number">66</span> <span class="number">90</span>                   xchg   %ax,%ax</div><div class="line"><span class="number">804845</span>a:   <span class="number">66</span> <span class="number">90</span>                   xchg   %ax,%ax</div><div class="line"><span class="number">804845</span>c:   <span class="number">66</span> <span class="number">90</span>                   xchg   %ax,%ax</div><div class="line"><span class="number">804845</span>e:   <span class="number">66</span> <span class="number">90</span>                   xchg   %ax,%ax</div></pre></td></tr></table></figure><p>通过对比可以看到，第一段代码的汇编代码中是直接用<code>neg</code>指令对变量a进行求相反数（全部按位取反再+1，也就是求相反数的补码）得到结果，而同时又因为符号位溢出了，所以导致相反数的补码与自身补码一致，所以结果不变，依然为-2147483648。而第二段中是用<code>idivl</code>指令做除法运算的。按2进制的除法运算规则0x80000000这个数(十进制为-2147483648)它除以-1应该为十进制的2147483648。但是%eax这个寄存器是32位的，它能存储的最大数字是2147483647，导致的结果就是真实的值无法存入%eax这个寄存器里面，便出现了上述与代码一截然不同的结果。</p><hr><h2 id="整数除0与浮点数除0的问题"><a href="#整数除0与浮点数除0的问题" class="headerlink" title="整数除0与浮点数除0的问题"></a>整数除0与浮点数除0的问题</h2><p>依然通过两段代码来探讨这两个问题：<br>代码一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="comment">//代码一</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a/b );</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>代码二：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="comment">//代码二</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv)</span></span>&#123;</div><div class="line">    <span class="keyword">double</span> x=<span class="number">1.0</span>,y=<span class="number">-1.0</span>,z=<span class="number">0.0</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%f,%f\n"</span>, x/z,y/z);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>代码一的结果：<br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-11-07-123246.jpg" alt=""><br>代码二的结果：<br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-11-07-124516.jpg" alt=""></p><p>可以看到，整数除0与浮点数除0的结果是不相同的，整数除0会报异常，而浮点数除0则会得到inf的结果。</p><p><strong>代码一汇编代码：</strong></p><figure class="highlight as"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="number">0804840</span>b &lt;main&gt;:</div><div class="line"><span class="number">804840</span>b:   <span class="number">8</span>d <span class="number">4</span>c <span class="number">24</span> <span class="number">04</span>             lea    <span class="number">0x4</span>(%esp),%ecx</div><div class="line"><span class="number">804840</span>f:   <span class="number">83</span> e4 f0                and    $<span class="number">0xfffffff0</span>,%esp</div><div class="line"><span class="number">8048412</span>:   ff <span class="number">71</span> fc                pushl  <span class="number">-0x4</span>(%ecx)</div><div class="line"><span class="number">8048415</span>:   <span class="number">55</span>                      push   %ebp</div><div class="line"><span class="number">8048416</span>:   <span class="number">89</span> e5                   mov    %esp,%ebp</div><div class="line"><span class="number">8048418</span>:   <span class="number">51</span>                      push   %ecx</div><div class="line"><span class="number">8048419</span>:   <span class="number">83</span> ec <span class="number">14</span>                sub    $<span class="number">0x14</span>,%esp</div><div class="line"><span class="number">804841</span>c:   c7 <span class="number">45</span> f0 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   $<span class="number">0x1</span>,<span class="number">-0x10</span>(%ebp)</div><div class="line"><span class="number">8048423</span>:   c7 <span class="number">45</span> f4 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   $<span class="number">0x0</span>,<span class="number">-0xc</span>(%ebp)</div><div class="line"><span class="number">804842</span>a:   <span class="number">8</span>b <span class="number">45</span> f0                mov    <span class="number">-0x10</span>(%ebp),%eax</div><div class="line"><span class="number">804842</span>d:   <span class="number">99</span>                      cltd   </div><div class="line"><span class="number">804842</span>e:   f7 <span class="number">7</span>d f4                idivl  <span class="number">-0xc</span>(%ebp)</div><div class="line"><span class="number">8048431</span>:   <span class="number">83</span> ec <span class="number">08</span>                sub    $<span class="number">0x8</span>,%esp</div><div class="line"><span class="number">8048434</span>:   <span class="number">50</span>                      push   %eax</div><div class="line"><span class="number">8048435</span>:   <span class="number">68</span> d0 <span class="number">84</span> <span class="number">04</span> <span class="number">08</span>          push   $<span class="number">0x80484d0</span></div><div class="line"><span class="number">804843</span>a:   e8 a1 fe ff ff          call   <span class="number">80482e0</span> &lt;printf@plt&gt;</div><div class="line"><span class="number">804843</span>f:   <span class="number">83</span> c4 <span class="number">10</span>                add    $<span class="number">0x10</span>,%esp</div><div class="line"><span class="number">8048442</span>:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</div><div class="line"><span class="number">8048447</span>:   <span class="number">8</span>b <span class="number">4</span>d fc                mov    <span class="number">-0x4</span>(%ebp),%ecx</div><div class="line"><span class="number">804844</span>a:   c9                      leave  </div><div class="line"><span class="number">804844</span>b:   <span class="number">8</span>d <span class="number">61</span> fc                lea    <span class="number">-0x4</span>(%ecx),%esp</div><div class="line"><span class="number">804844</span>e:   c3                      ret    </div><div class="line"><span class="number">804844</span>f:   <span class="number">90</span>                      nop</div></pre></td></tr></table></figure><p><strong>代码二的汇编代码：</strong></p><figure class="highlight as"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="number">0804840</span>b &lt;main&gt;:</div><div class="line"> <span class="number">804840</span>b:   <span class="number">8</span>d <span class="number">4</span>c <span class="number">24</span> <span class="number">04</span>             lea    <span class="number">0x4</span>(%esp),%ecx</div><div class="line"> <span class="number">804840</span>f:   <span class="number">83</span> e4 f0                and    $<span class="number">0xfffffff0</span>,%esp</div><div class="line"> <span class="number">8048412</span>:   ff <span class="number">71</span> fc                pushl  <span class="number">-0x4</span>(%ecx)</div><div class="line"> <span class="number">8048415</span>:   <span class="number">55</span>                      push   %ebp</div><div class="line"> <span class="number">8048416</span>:   <span class="number">89</span> e5                   mov    %esp,%ebp</div><div class="line"> <span class="number">8048418</span>:   <span class="number">51</span>                      push   %ecx</div><div class="line"> <span class="number">8048419</span>:   <span class="number">83</span> ec <span class="number">24</span>                sub    $<span class="number">0x24</span>,%esp</div><div class="line"> <span class="number">804841</span>c:   d9 e8                   fld1   <span class="comment">//将1.0压入ST(0)中</span></div><div class="line"> <span class="number">804841</span>e:   dd <span class="number">5</span>d e0                fstpl  <span class="number">-0x20</span>(%ebp)<span class="comment">//将ST(0)中的数据以浮点数形式存入-0x20(%ebp)地址中，且进行出栈操作</span></div><div class="line"> <span class="number">8048421</span>:   d9 e8                   fld1   <span class="comment">//将1.0压入ST(0)中</span></div><div class="line"> <span class="number">8048423</span>:   d9 e0                   fchs   <span class="comment">//取 ST(0) 符号位的反</span></div><div class="line"> <span class="number">8048425</span>:   dd <span class="number">5</span>d e8                fstpl  <span class="number">-0x18</span>(%ebp)<span class="comment">//将ST(0)中的数据以浮点数形式存入-0x18(%ebp)地址中，且进行出栈操作</span></div><div class="line"> <span class="number">8048428</span>:   d9 ee                   fldz   <span class="comment">//将0.0压入ST(0)中</span></div><div class="line"> <span class="number">804842</span>a:   dd <span class="number">5</span>d f0                fstpl  <span class="number">-0x10</span>(%ebp)<span class="comment">//将ST(0)中的数据以浮点数形式存入-0x10(%ebp)地址中，且进行出栈操作</span></div><div class="line"> <span class="number">804842</span>d:   dd <span class="number">45</span> e8                fldl   <span class="number">-0x18</span>(%ebp)<span class="comment">//将浮点数-0x18(%ebp)压入ST(0)中</span></div><div class="line"> <span class="number">8048430</span>:   dc <span class="number">75</span> f0                fdivl  <span class="number">-0x10</span>(%ebp)<span class="comment">//将 ST(0) 除以 -0x10(%ebp)，结果存储到 ST(0)</span></div><div class="line"> <span class="number">8048433</span>:   dd <span class="number">45</span> e0                fldl   <span class="number">-0x20</span>(%ebp)<span class="comment">//将浮点数-0x18(%ebp)压入ST(0)中，当ST(0)存在数据时，执行压栈操作后，ST(0)中的数据将装入ST(1)中</span></div><div class="line"> <span class="number">8048436</span>:   dc <span class="number">75</span> f0                fdivl  <span class="number">-0x10</span>(%ebp)<span class="comment">//将 ST(0) 除以 -0x10(%ebp)，结果存储到 ST(0)</span></div><div class="line"> <span class="number">8048439</span>:   d9 c9                   fxch   %st(<span class="number">1</span>)<span class="comment">//ST(0)与ST(1)交换数据</span></div><div class="line"> <span class="number">804843</span>b:   <span class="number">83</span> ec <span class="number">0</span>c                sub    $<span class="number">0xc</span>,%esp</div><div class="line"> <span class="number">804843</span>e:   <span class="number">8</span>d <span class="number">64</span> <span class="number">24</span> f8             lea    <span class="number">-0x8</span>(%esp),%esp</div><div class="line"> <span class="number">8048442</span>:   dd <span class="number">1</span>c <span class="number">24</span>                fstpl  (%esp)<span class="comment">//将ST(0)中的数据以浮点数形式存入(%esp)中,之后ST(1)的数据会自动转入ST(0)中</span></div><div class="line"> <span class="number">8048445</span>:   <span class="number">8</span>d <span class="number">64</span> <span class="number">24</span> f8             lea    <span class="number">-0x8</span>(%esp),%esp</div><div class="line"> <span class="number">8048449</span>:   dd <span class="number">1</span>c <span class="number">24</span>                fstpl  (%esp)<span class="comment">//将ST(0)中的数据以浮点数形式存入(%esp)中</span></div><div class="line"> <span class="number">804844</span>c:   <span class="number">68</span> f0 <span class="number">84</span> <span class="number">04</span> <span class="number">08</span>          push   $<span class="number">0x80484f0</span></div><div class="line"> <span class="number">8048451</span>:   e8 <span class="number">8</span>a fe ff ff          call   <span class="number">80482e0</span> &lt;printf@plt&gt;</div><div class="line"> <span class="number">8048456</span>:   <span class="number">83</span> c4 <span class="number">20</span>                add    $<span class="number">0x20</span>,%esp</div><div class="line"> <span class="number">8048459</span>:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</div><div class="line"> <span class="number">804845</span>e:   <span class="number">8</span>b <span class="number">4</span>d fc                mov    <span class="number">-0x4</span>(%ebp),%ecx</div><div class="line"> <span class="number">8048461</span>:   c9                      leave  </div><div class="line"> <span class="number">8048462</span>:   <span class="number">8</span>d <span class="number">61</span> fc                lea    <span class="number">-0x4</span>(%ecx),%esp</div><div class="line"> <span class="number">8048465</span>:   c3                      ret    </div><div class="line"> <span class="number">8048466</span>:   <span class="number">66</span> <span class="number">90</span>                   xchg   %ax,%ax</div><div class="line"> <span class="number">8048468</span>:   <span class="number">66</span> <span class="number">90</span>                   xchg   %ax,%ax</div><div class="line"> <span class="number">804846</span>a:   <span class="number">66</span> <span class="number">90</span>                   xchg   %ax,%ax</div><div class="line"> <span class="number">804846</span>c:   <span class="number">66</span> <span class="number">90</span>                   xchg   %ax,%ax</div><div class="line"> <span class="number">804846</span>e:   <span class="number">66</span> <span class="number">90</span>                   xchg   %ax,%ax</div></pre></td></tr></table></figure><p>可以看到，整数除0与浮点数除0所用的指令是不相同的。</p><p><strong>浮点数是如何做除法的？</strong><br>浮点寄存器是通过栈结构来实现的，由ST(0)～ST(7)共8个栈空间组成，每个浮点寄存器占8字节。每次使用浮点寄存器都是率先使用ST(0)，而不能越过ST(0)直接使用ST(1)。浮点寄存器的使用就是压栈、出栈的过程。当ST(0)存在数据时，执行压栈操作后，ST(0)中的数据将装入ST(1)中，如无出栈操作，将顺序地向下压栈，直到将浮点寄存器占满。<br>若浮点数寄存器已满，此时再有数据压栈，则栈中的数据将会从ST(7)开始依次出栈转存入内存。</p><p>代码2是浮点数除0，计算机用浮点数表示0的时候并不能做到精确的保存，一方面为浮点数除法提供了可能，另一方面一个数除以过于靠近0的数可能会导致结果过大而溢出，所以计算机对这类的计算作出了统一处理。用inf(011111111110…0)和-inf(111111111110…0)作为这类结果。</p><p>因为浮点数使用FPU计算的原因，所以才导致了以上整数除 0 出现异常，而浮点数除 0 会得到<code>inf</code> 与<code>-inf</code>的结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;整数的除运算&quot;&gt;&lt;a href=&quot;#整数的除运算&quot; class=&quot;headerlink&quot; title=&quot;整数的除运算&quot;&gt;&lt;/a&gt;整数的除运算&lt;/h2&gt;&lt;p&gt;代码一：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *argv)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;0x80000000&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b = a/&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d\n&quot;&lt;/span&gt;,b );&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码二：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *argv)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;0x80000000&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b = a/&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d\n&quot;&lt;/span&gt;,b );&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="http://jihong.xyz/categories/computer-principle/"/>
    
    
      <category term="编程素养" scheme="http://jihong.xyz/tags/Programming-literacy/"/>
    
  </entry>
  
  <entry>
    <title>计组实验 - 拆炸弹实验</title>
    <link href="http://jihong.xyz/computer-principle/%E8%AE%A1%E7%BB%84%E5%AE%9E%E9%AA%8C%20-%20%E6%8B%86%E7%82%B8%E5%BC%B9%E5%AE%9E%E9%AA%8C/"/>
    <id>http://jihong.xyz/computer-principle/计组实验 - 拆炸弹实验/</id>
    <published>2016-10-28T12:04:40.000Z</published>
    <updated>2018-03-04T07:42:48.580Z</updated>
    
    <content type="html"><![CDATA[<p>查看bomb.c文件里的main函数，可以发现它在分析完命令行的参数完成之后调用了initialize_bomb()函数，之后输出了两个语句。紧接着就是read_line()函数，显然这个是读取我们所需要的字符，接着就是phase_1()与phase_defused()函数了。再往下看，可以看出分别调用了phase_1 ~ phase_6六个函数，这应该就是每个拆除炸弹的阶段函数了。<br>通过<code>objdump -d bomb &gt; bomb.s</code>把反汇编代码输出到bomb.s文件上，方便查找。<br>接下来就是逐个阶段的分析了</p><h6 id="phase1"><a href="#phase1" class="headerlink" title="phase1"></a>phase1</h6><p>首先找到phase_1函数的汇编代码如下:</p><figure class="highlight as"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="number">08048</span>f61 &lt;phase_1&gt;:</div><div class="line"><span class="number">8048</span>f61:   <span class="number">55</span>                      push   %ebp</div><div class="line"><span class="number">8048</span>f62:   <span class="number">89</span> e5                   mov    %esp,%ebp</div><div class="line"><span class="number">8048</span>f64:   <span class="number">83</span> ec <span class="number">18</span>                sub    $<span class="number">0x18</span>,%esp</div><div class="line"><span class="number">8048</span>f67:   c7 <span class="number">44</span> <span class="number">24</span> <span class="number">04</span> <span class="number">5</span>c a1 <span class="number">04</span>    movl   $<span class="number">0x804a15c</span>,<span class="number">0x4</span>(%esp)</div><div class="line"><span class="number">8048</span>f6e:   <span class="number">08</span> </div><div class="line"><span class="number">8048</span>f6f:   <span class="number">8</span>b <span class="number">45</span> <span class="number">08</span>                mov    <span class="number">0x8</span>(%ebp),%eax</div><div class="line"><span class="number">8048</span>f72:   <span class="number">89</span> <span class="number">04</span> <span class="number">24</span>                mov    %eax,(%esp)</div><div class="line"><span class="number">8048</span>f75:   e8 <span class="number">31</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">8048</span>fab &lt;strings_not_equal&gt;</div><div class="line"><span class="number">8048</span>f7a:   <span class="number">85</span> c0                   test   %eax,%eax</div><div class="line"><span class="number">8048</span>f7c:   <span class="number">74</span> <span class="number">05</span>                   je     <span class="number">8048</span>f83 &lt;phase_1+<span class="number">0x22</span>&gt;</div><div class="line"><span class="number">8048</span>f7e:   e8 <span class="number">4</span>e <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">80490</span>d1 &lt;explode_bomb&gt;</div><div class="line"><span class="number">8048</span>f83:   c9                      leave  </div><div class="line"><span class="number">8048</span>f84:   c3                      ret    </div><div class="line"><span class="number">8048</span>f85:   <span class="number">90</span>                      nop</div><div class="line"><span class="number">8048</span>f86:   <span class="number">90</span>                      nop</div><div class="line"><span class="number">8048</span>f87:   <span class="number">90</span>                      nop</div><div class="line"><span class="number">8048</span>f88:   <span class="number">90</span>                      nop</div><div class="line"><span class="number">8048</span>f89:   <span class="number">90</span>                      nop</div><div class="line"><span class="number">8048</span>f8a:   <span class="number">90</span>                      nop</div><div class="line"><span class="number">8048</span>f8b:   <span class="number">90</span>                      nop</div><div class="line"><span class="number">8048</span>f8c:   <span class="number">90</span>                      nop</div><div class="line"><span class="number">8048</span>f8d:   <span class="number">90</span>                      nop</div><div class="line"><span class="number">8048</span>f8e:   <span class="number">90</span>                      nop</div><div class="line"><span class="number">8048</span>f8f:   <span class="number">90</span>                      nop</div></pre></td></tr></table></figure><a id="more"></a><p>看完整段代码可以发现主要入栈了两个地址上的函数（调用函数）：<code>call   8048fab &lt;strings_not_equal&gt;</code>与<code>call   80490d1 &lt;explode_bomb&gt;</code>。根据字面意思可以猜测出大概的逻辑为:比较输入的字符是否与源字符相等，不相等则拆炸弹失败。根据后面的<code>test   %eax,%eax</code>指令我们也可以看到，eax寄存器里的值必须为0，这样test之后值才会为0，ZF才会置1，je(等同于jz)才会跳转。也就是说&lt;strings_not_equal&gt;必须返回0才能继续进行。<br>再往上看可以看到<code>movl   $0x804a15c,0x4(%esp)</code>指令，把立即数（0x804a15c地址里的值）送入0x4(%esp)中;再往下就可以看到<code>mov    0x8(%ebp),%eax</code>指令，可以假设前一条指令是把源字符送入0x4(%esp)中，而后一条就是把我们输入的指令送入%esp中。所以我们可以在gdb里用x /s 0x804a15c查看0x804a15c地址里的内容：<br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-11-07-122443.jpg" alt=""><br><code>We have to stand with our North Korean allies.</code>应该就是拆炸弹所需的密钥了，可以把bomb跑起来试试看第一条密钥是否正确。<br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-11-07-122457.jpg" alt=""><br>可以看到炸弹已经拆除了。</p><hr><h6 id="phase2"><a href="#phase2" class="headerlink" title="phase2"></a>phase2</h6><p>phase_2的汇编代码如下：</p><figure class="highlight as"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="number">08048</span>d6a &lt;phase_2&gt;:</div><div class="line"><span class="number">8048</span>d6a:   <span class="number">55</span>                      push   %ebp</div><div class="line"><span class="number">8048</span>d6b:   <span class="number">89</span> e5                   mov    %esp,%ebp</div><div class="line"><span class="number">8048</span>d6d:   <span class="number">56</span>                      push   %esi</div><div class="line"><span class="number">8048</span>d6e:   <span class="number">53</span>                      push   %ebx</div><div class="line"><span class="number">8048</span>d6f:   <span class="number">83</span> ec <span class="number">30</span>                sub    $<span class="number">0x30</span>,%esp</div><div class="line"><span class="number">8048</span>d72:   <span class="number">8</span>d <span class="number">45</span> e0                lea    <span class="number">-0x20</span>(%ebp),%eax</div><div class="line"><span class="number">8048</span>d75:   <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">04</span>             mov    %eax,<span class="number">0x4</span>(%esp)</div><div class="line"><span class="number">8048</span>d79:   <span class="number">8</span>b <span class="number">45</span> <span class="number">08</span>                mov    <span class="number">0x8</span>(%ebp),%eax</div><div class="line"><span class="number">8048</span>d7c:   <span class="number">89</span> <span class="number">04</span> <span class="number">24</span>                mov    %eax,(%esp)</div><div class="line"><span class="number">8048</span>d7f:   e8 <span class="number">87</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">804910</span>b &lt;read_six_numbers&gt;</div><div class="line"><span class="number">8048</span>d84:   <span class="number">83</span> <span class="number">7</span>d e0 <span class="number">00</span>             cmpl   $<span class="number">0x0</span>,<span class="number">-0x20</span>(%ebp)</div><div class="line"><span class="number">8048</span>d88:   <span class="number">75</span> <span class="number">06</span>                   jne    <span class="number">8048</span>d90 &lt;phase_2+<span class="number">0x26</span>&gt;</div><div class="line"><span class="number">8048</span>d8a:   <span class="number">83</span> <span class="number">7</span>d e4 <span class="number">01</span>             cmpl   $<span class="number">0x1</span>,<span class="number">-0x1c</span>(%ebp)</div><div class="line"><span class="number">8048</span>d8e:   <span class="number">74</span> <span class="number">05</span>                   je     <span class="number">8048</span>d95 &lt;phase_2+<span class="number">0x2b</span>&gt;</div><div class="line"><span class="number">8048</span>d90:   e8 <span class="number">3</span>c <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">80490</span>d1 &lt;explode_bomb&gt;</div><div class="line"><span class="number">8048</span>d95:   <span class="number">8</span>d <span class="number">5</span>d e8                lea    <span class="number">-0x18</span>(%ebp),%ebx</div><div class="line"><span class="number">8048</span>d98:   <span class="number">8</span>d <span class="number">75</span> f8                lea    <span class="number">-0x8</span>(%ebp),%esi</div><div class="line"><span class="number">8048</span>d9b:   <span class="number">8</span>b <span class="number">43</span> fc                mov    <span class="number">-0x4</span>(%ebx),%eax</div><div class="line"><span class="number">8048</span>d9e:   <span class="number">03</span> <span class="number">43</span> f8                add    <span class="number">-0x8</span>(%ebx),%eax</div><div class="line"><span class="number">8048</span>da1:   <span class="number">39</span> <span class="number">03</span>                   cmp    %eax,(%ebx)</div><div class="line"><span class="number">8048</span>da3:   <span class="number">74</span> <span class="number">05</span>                   je     <span class="number">8048</span>daa &lt;phase_2+<span class="number">0x40</span>&gt;</div><div class="line"><span class="number">8048</span>da5:   e8 <span class="number">27</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">80490</span>d1 &lt;explode_bomb&gt;</div><div class="line"><span class="number">8048</span>daa:   <span class="number">83</span> c3 <span class="number">04</span>                add    $<span class="number">0x4</span>,%ebx</div><div class="line"><span class="number">8048</span>dad:   <span class="number">39</span> f3                   cmp    %esi,%ebx</div><div class="line"><span class="number">8048</span>daf:   <span class="number">75</span> ea                   jne    <span class="number">8048</span>d9b &lt;phase_2+<span class="number">0x31</span>&gt;</div><div class="line"><span class="number">8048</span>db1:   <span class="number">83</span> c4 <span class="number">30</span>                add    $<span class="number">0x30</span>,%esp</div><div class="line"><span class="number">8048</span>db4:   <span class="number">5</span>b                      pop    %ebx</div><div class="line"><span class="number">8048</span>db5:   <span class="number">5</span>e                      pop    %esi</div><div class="line"><span class="number">8048</span>db6:   <span class="number">5</span>d                      pop    %ebp</div><div class="line"><span class="number">8048</span>db7:   c3                      ret</div></pre></td></tr></table></figure><p>这一段汇编代码主要调用的两个函数就是<code>&lt;read_six_numbers&gt;</code>和<code>&lt;explode_bomb&gt;</code>，<code>&lt;explode_bomb&gt;</code>从第一阶段可以知道这就是验证失败后调用的函数，<code>&lt;read_six_numbers&gt;</code>从字面意思可以猜测第二阶段是要输入六个数字来进行验证。</p><figure class="highlight as"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">8048</span>d84:   <span class="number">83</span> <span class="number">7</span>d e0 <span class="number">00</span>             cmpl   $<span class="number">0x0</span>,<span class="number">-0x20</span>(%ebp)</div><div class="line"><span class="number">8048</span>d88:   <span class="number">75</span> <span class="number">06</span>                   jne    <span class="number">8048</span>d90 &lt;phase_2+<span class="number">0x26</span>&gt;</div><div class="line"><span class="number">8048</span>d8a:   <span class="number">83</span> <span class="number">7</span>d e4 <span class="number">01</span>             cmpl   $<span class="number">0x1</span>,<span class="number">-0x1c</span>(%ebp)</div><div class="line"><span class="number">8048</span>d8e:   <span class="number">74</span> <span class="number">05</span>                   je     <span class="number">8048</span>d95 &lt;phase_2+<span class="number">0x2b</span>&gt;</div></pre></td></tr></table></figure><p>从这几个语句可以看出，首先用 0 和栈底指针ebp-0x20的地址上的数值（第一位数）相比较，如果不相等则跳转到<code>0x8048d90</code>也就是<code>&lt;explode_bomb&gt;</code>;同样接来下一句是用 1 和栈底指针ebp-0x20的地址上的数值（第二位数）相比较，相等的话则跳过<code>&lt;explode_bomb&gt;</code>继续执行。由此我们可以大胆猜测前两位就是0与1。</p><figure class="highlight as"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="number">8048</span>d95:   <span class="number">8</span>d <span class="number">5</span>d e8                lea    <span class="number">-0x18</span>(%ebp),%ebx</div><div class="line"><span class="number">8048</span>d98:   <span class="number">8</span>d <span class="number">75</span> f8                lea    <span class="number">-0x8</span>(%ebp),%esi</div><div class="line"><span class="number">8048</span>d9b:   <span class="number">8</span>b <span class="number">43</span> fc                mov    <span class="number">-0x4</span>(%ebx),%eax</div><div class="line"><span class="number">8048</span>d9e:   <span class="number">03</span> <span class="number">43</span> f8                add    <span class="number">-0x8</span>(%ebx),%eax</div><div class="line"><span class="number">8048</span>da1:   <span class="number">39</span> <span class="number">03</span>                   cmp    %eax,(%ebx)</div><div class="line"><span class="number">8048</span>da3:   <span class="number">74</span> <span class="number">05</span>                   je     <span class="number">8048</span>daa &lt;phase_2+<span class="number">0x40</span>&gt;</div><div class="line"><span class="number">8048</span>da5:   e8 <span class="number">27</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">80490</span>d1 &lt;explode_bomb&gt;</div><div class="line"><span class="number">8048</span>daa:   <span class="number">83</span> c3 <span class="number">04</span>                add    $<span class="number">0x4</span>,%ebx</div><div class="line"><span class="number">8048</span>dad:   <span class="number">39</span> f3                   cmp    %esi,%ebx</div><div class="line"><span class="number">8048</span>daf:   <span class="number">75</span> ea                   jne    <span class="number">8048</span>d9b &lt;phase_2+<span class="number">0x31</span>&gt;</div></pre></td></tr></table></figure><p>上述代码第一条<code>lea    -0x18(%ebp),%ebx</code>就是把<code>-0x18(%ebp)</code>（第三位数）转移到<code>%ebx</code>中，再接着<code>lea    -0x8(%ebp),%esi</code>是把栈底往上的第三个值（用来做后续的循环验证条件）转移到<code>%esi</code>中。<br><strong>注意：</strong><br><code>mov    -0x4(%ebx),%eax</code>这条指令在第一次执行时的等价指令为<code>mov    -0x1c(%ebp),%ebx</code>（输入的第二个数字），<code>add    -0x8(%ebx),%eax</code>这条指令在第一次执行时的等价指令为<code>mov    -0x20(%ebp),%ebx</code>（输入的第一个数字）。所以综上两条指令的效果就是把输入的第一、第二位数字相加然后把结果送入<code>%eax</code>。然后用第三位数与<code>%eax</code>相比较，确认相同之后把<code>%ebx</code>加上4再作为循环条件与<code>%esi</code>相比较，如果相等就结束循环，否则继续跳转回去校验下一个数字。（<strong>校验规则为后一位为其前两位之和，第一第二位分别为0，1</strong>）</p><p>所以此时可以得出第三位的值为0+1=1，第四位为1+1=2，第五位为1+2=3，第六位为2+3=5。由此我们也可以得出<code>%esi</code>的值为5+4=9。<br>试着验证：<br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-11-07-122536.jpg" alt=""><br>分析是正确的，第二阶段已经通过了！</p><hr><h6 id="phase3"><a href="#phase3" class="headerlink" title="phase3"></a>phase3</h6><p>phase_3的汇编代码如下：</p><figure class="highlight as"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="number">08048</span>ea1 &lt;phase_3&gt;:</div><div class="line"><span class="number">8048</span>ea1:   <span class="number">55</span>                      push   %ebp</div><div class="line"><span class="number">8048</span>ea2:   <span class="number">89</span> e5                   mov    %esp,%ebp</div><div class="line"><span class="number">8048</span>ea4:   <span class="number">83</span> ec <span class="number">28</span>                sub    $<span class="number">0x28</span>,%esp</div><div class="line"><span class="number">8048</span>ea7:   <span class="number">8</span>d <span class="number">45</span> f0                lea    <span class="number">-0x10</span>(%ebp),%eax</div><div class="line"><span class="number">8048</span>eaa:   <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">0</span>c             mov    %eax,<span class="number">0xc</span>(%esp)</div><div class="line"><span class="number">8048</span>eae:   <span class="number">8</span>d <span class="number">45</span> f4                lea    <span class="number">-0xc</span>(%ebp),%eax</div><div class="line"><span class="number">8048</span>eb1:   <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">08</span>             mov    %eax,<span class="number">0x8</span>(%esp)</div><div class="line"><span class="number">8048</span>eb5:   c7 <span class="number">44</span> <span class="number">24</span> <span class="number">04</span> <span class="number">3</span>e a2 <span class="number">04</span>    movl   $<span class="number">0x804a23e</span>,<span class="number">0x4</span>(%esp)</div><div class="line"><span class="number">8048</span>ebc:   <span class="number">08</span> </div><div class="line"><span class="number">8048</span>ebd:   <span class="number">8</span>b <span class="number">45</span> <span class="number">08</span>                mov    <span class="number">0x8</span>(%ebp),%eax</div><div class="line"><span class="number">8048</span>ec0:   <span class="number">89</span> <span class="number">04</span> <span class="number">24</span>                mov    %eax,(%esp)</div><div class="line"><span class="number">8048</span>ec3:   e8 <span class="number">78</span> f9 ff ff          call   <span class="number">8048840</span> &lt;__isoc99_sscanf@plt&gt;</div><div class="line"><span class="number">8048</span>ec8:   <span class="number">83</span> f8 <span class="number">01</span>                cmp    $<span class="number">0x1</span>,%eax</div><div class="line"><span class="number">8048</span>ecb:   <span class="number">7</span>f <span class="number">05</span>                   jg     <span class="number">8048</span>ed2 &lt;phase_3+<span class="number">0x31</span>&gt;</div><div class="line"><span class="number">8048</span>ecd:   e8 ff <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">80490</span>d1 &lt;explode_bomb&gt;</div><div class="line"><span class="number">8048</span>ed2:   <span class="number">83</span> <span class="number">7</span>d f4 <span class="number">07</span>             cmpl   $<span class="number">0x7</span>,<span class="number">-0xc</span>(%ebp)</div><div class="line"><span class="number">8048</span>ed6:   <span class="number">77</span> <span class="number">6</span>b                   ja     <span class="number">8048</span>f43 &lt;phase_3+<span class="number">0xa2</span>&gt;</div><div class="line"><span class="number">8048</span>ed8:   <span class="number">8</span>b <span class="number">45</span> f4                mov    <span class="number">-0xc</span>(%ebp),%eax</div><div class="line"><span class="number">8048</span>edb:   ff <span class="number">24</span> <span class="number">85</span> a0 a1 <span class="number">04</span> <span class="number">08</span>    jmp    *<span class="number">0x804a1a0</span>(,%eax,<span class="number">4</span>)</div><div class="line"><span class="number">8048</span>ee2:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</div><div class="line"><span class="number">8048</span>ee7:   eb <span class="number">53</span>                   jmp    <span class="number">8048</span>f3c &lt;phase_3+<span class="number">0x9b</span>&gt;</div><div class="line"><span class="number">8048</span>ee9:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</div><div class="line"><span class="number">8048</span>eee:   <span class="number">66</span> <span class="number">90</span>                   xchg   %ax,%ax</div><div class="line"><span class="number">8048</span>ef0:   eb <span class="number">45</span>                   jmp    <span class="number">8048</span>f37 &lt;phase_3+<span class="number">0x96</span>&gt;</div><div class="line"><span class="number">8048</span>ef2:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</div><div class="line"><span class="number">8048</span>ef7:   eb <span class="number">39</span>                   jmp    <span class="number">8048</span>f32 &lt;phase_3+<span class="number">0x91</span>&gt;</div><div class="line"><span class="number">8048</span>ef9:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</div><div class="line"><span class="number">8048</span>efe:   <span class="number">66</span> <span class="number">90</span>                   xchg   %ax,%ax</div><div class="line"><span class="number">8048</span>f00:   eb <span class="number">2</span>b                   jmp    <span class="number">8048</span>f2d &lt;phase_3+<span class="number">0x8c</span>&gt;</div><div class="line"><span class="number">8048</span>f02:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</div><div class="line"><span class="number">8048</span>f07:   eb <span class="number">1</span>f                   jmp    <span class="number">8048</span>f28 &lt;phase_3+<span class="number">0x87</span>&gt;</div><div class="line"><span class="number">8048</span>f09:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</div><div class="line"><span class="number">8048</span>f0e:   <span class="number">66</span> <span class="number">90</span>                   xchg   %ax,%ax</div><div class="line"><span class="number">8048</span>f10:   eb <span class="number">11</span>                   jmp    <span class="number">8048</span>f23 &lt;phase_3+<span class="number">0x82</span>&gt;</div><div class="line"><span class="number">8048</span>f12:   b8 <span class="number">14</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x314</span>,%eax</div><div class="line"><span class="number">8048</span>f17:   eb <span class="number">05</span>                   jmp    <span class="number">8048</span>f1e &lt;phase_3+<span class="number">0x7d</span>&gt;</div><div class="line"><span class="number">8048</span>f19:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</div><div class="line"><span class="number">8048</span>f1e:   <span class="number">2</span>d <span class="number">5</span>a <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>          sub    $<span class="number">0x35a</span>,%eax</div><div class="line"><span class="number">8048</span>f23:   <span class="number">05</span> ef <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>          add    $<span class="number">0x2ef</span>,%eax</div><div class="line"><span class="number">8048</span>f28:   <span class="number">2</span>d <span class="number">16</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>          sub    $<span class="number">0x216</span>,%eax</div><div class="line"><span class="number">8048</span>f2d:   <span class="number">05</span> <span class="number">16</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>          add    $<span class="number">0x216</span>,%eax</div><div class="line"><span class="number">8048</span>f32:   <span class="number">2</span>d <span class="number">16</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>          sub    $<span class="number">0x216</span>,%eax</div><div class="line"><span class="number">8048</span>f37:   <span class="number">05</span> <span class="number">16</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>          add    $<span class="number">0x216</span>,%eax</div><div class="line"><span class="number">8048</span>f3c:   <span class="number">2</span>d <span class="number">16</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>          sub    $<span class="number">0x216</span>,%eax</div><div class="line"><span class="number">8048</span>f41:   eb <span class="number">0</span>a                   jmp    <span class="number">8048</span>f4d &lt;phase_3+<span class="number">0xac</span>&gt;</div><div class="line"><span class="number">8048</span>f43:   e8 <span class="number">89</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">80490</span>d1 &lt;explode_bomb&gt;</div><div class="line"><span class="number">8048</span>f48:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</div><div class="line"><span class="number">8048</span>f4d:   <span class="number">83</span> <span class="number">7</span>d f4 <span class="number">05</span>             cmpl   $<span class="number">0x5</span>,<span class="number">-0xc</span>(%ebp)</div><div class="line"><span class="number">8048</span>f51:   <span class="number">7</span>f <span class="number">05</span>                   jg     <span class="number">8048</span>f58 &lt;phase_3+<span class="number">0xb7</span>&gt;</div><div class="line"><span class="number">8048</span>f53:   <span class="number">3</span>b <span class="number">45</span> f0                cmp    <span class="number">-0x10</span>(%ebp),%eax</div><div class="line"><span class="number">8048</span>f56:   <span class="number">74</span> <span class="number">05</span>                   je     <span class="number">8048</span>f5d &lt;phase_3+<span class="number">0xbc</span>&gt;</div><div class="line"><span class="number">8048</span>f58:   e8 <span class="number">74</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">80490</span>d1 &lt;explode_bomb&gt;</div><div class="line"><span class="number">8048</span>f5d:   c9                      leave  </div><div class="line"><span class="number">8048</span>f5e:   <span class="number">66</span> <span class="number">90</span>                   xchg   %ax,%ax</div><div class="line"><span class="number">8048</span>f60:   c3                      ret</div></pre></td></tr></table></figure><p>首先看到如下指令：<br><figure class="highlight as"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">8048</span>ec3:   e8 <span class="number">78</span> f9 ff ff          call   <span class="number">8048840</span> &lt;__isoc99_sscanf@plt&gt;</div><div class="line"><span class="number">8048</span>ec8:   <span class="number">83</span> f8 <span class="number">01</span>                cmp    $<span class="number">0x1</span>,%eax</div><div class="line"><span class="number">8048</span>ecb:   <span class="number">7</span>f <span class="number">05</span>                   jg     <span class="number">8048</span>ed2 &lt;phase_3+<span class="number">0x31</span>&gt;</div><div class="line"><span class="number">8048</span>ecd:   e8 ff <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">80490</span>d1 &lt;explode_bomb&gt;</div><div class="line"><span class="number">8048</span>ed2:   <span class="number">83</span> <span class="number">7</span>d f4 <span class="number">07</span>             cmpl   $<span class="number">0x7</span>,<span class="number">-0xc</span>(%ebp)</div></pre></td></tr></table></figure></p><p><code>&lt;__isoc99_sscanf@plt&gt;</code>语句可以知道调用了c99标准中的scanf函数，在gdb中查看<code>0x804a23e</code>内存里的内容：</p><figure class="highlight as"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(gdb) x /s <span class="number">0x804a23e</span><span class="number">0x804a23e</span>:<span class="string">"%d %d"</span></div></pre></td></tr></table></figure><p>可以知道是要输入两个数字</p><figure class="highlight as"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">8048</span>ed2:   <span class="number">83</span> <span class="number">7</span>d f4 <span class="number">07</span>             cmpl   $<span class="number">0x7</span>,<span class="number">-0xc</span>(%ebp)</div><div class="line"><span class="number">8048</span>ed6:   <span class="number">77</span> <span class="number">6</span>b                   ja     <span class="number">8048</span>f43 &lt;phase_3+<span class="number">0xa2</span>&gt;</div></pre></td></tr></table></figure><p>这两句指令可以知道第一个指令是不能大于7的，否则跳转到<code>&lt;explode_bomb&gt;</code></p><figure class="highlight as"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">8048</span>ed8:   <span class="number">8</span>b <span class="number">45</span> f4                mov    <span class="number">-0xc</span>(%ebp),%eax</div><div class="line"><span class="number">8048</span>edb:   ff <span class="number">24</span> <span class="number">85</span> a0 a1 <span class="number">04</span> <span class="number">08</span>    jmp    *<span class="number">0x804a1a0</span>(,%eax,<span class="number">4</span>)</div></pre></td></tr></table></figure><p>而这两句指令就是一个switch语句，通过<code>-0xc(%ebp)</code>的值来决定具体的内存地址指令，以<code>0x804a1a0</code>为基址，%eax*4为偏址。又因为<code>mov    -0xc(%ebp),%eax</code>指令，可以知道%eax就是第一个参数的值，也就是switch的case条件，所以可以得出这样一个key-value：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>:*<span class="number">0x804a1a0</span></div><div class="line"><span class="number">1</span>:*<span class="number">0x804a1a4</span></div><div class="line"><span class="number">2</span>:*<span class="number">0x804a1a8</span></div><div class="line"><span class="number">3</span>:*<span class="number">0x804a1ac</span></div><div class="line"><span class="number">4</span>:*<span class="number">0x804a1b0</span></div><div class="line"><span class="number">5</span>:*<span class="number">0x804a1b4</span></div></pre></td></tr></table></figure><p>case条件为以上值时它调用的地址。接着通过gdb分别查看他们具体的地址值：<br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-11-07-122549.jpg" alt=""><br>可以看到，他们的具体的值分别如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>:<span class="number">0x8048f12</span></div><div class="line"><span class="number">1</span>:<span class="number">0x8048f19</span></div><div class="line"><span class="number">2</span>:<span class="number">0x8048f09</span></div><div class="line"><span class="number">3</span>:<span class="number">0x8048f02</span></div><div class="line"><span class="number">4</span>:<span class="number">0x8048ef9</span></div><div class="line"><span class="number">5</span>:<span class="number">0x8048ef2</span></div></pre></td></tr></table></figure><p>然后我们从汇编代码的相应地址部分开始逐个分析，首先分析0时它的具体执行过程：</p><figure class="highlight as"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="number">8048</span>f12:   b8 <span class="number">14</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x314</span>,%eax</div><div class="line"><span class="number">8048</span>f17:   eb <span class="number">05</span>                   jmp    <span class="number">8048</span>f1e &lt;phase_3+<span class="number">0x7d</span>&gt;</div><div class="line"><span class="number">8048</span>f19:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</div><div class="line"><span class="number">8048</span>f1e:   <span class="number">2</span>d <span class="number">5</span>a <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>          sub    $<span class="number">0x35a</span>,%eax</div><div class="line"><span class="number">8048</span>f23:   <span class="number">05</span> ef <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>          add    $<span class="number">0x2ef</span>,%eax</div><div class="line"><span class="number">8048</span>f28:   <span class="number">2</span>d <span class="number">16</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>          sub    $<span class="number">0x216</span>,%eax</div><div class="line"><span class="number">8048</span>f2d:   <span class="number">05</span> <span class="number">16</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>          add    $<span class="number">0x216</span>,%eax</div><div class="line"><span class="number">8048</span>f32:   <span class="number">2</span>d <span class="number">16</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>          sub    $<span class="number">0x216</span>,%eax</div><div class="line"><span class="number">8048</span>f37:   <span class="number">05</span> <span class="number">16</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>          add    $<span class="number">0x216</span>,%eax</div><div class="line"><span class="number">8048</span>f3c:   <span class="number">2</span>d <span class="number">16</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>          sub    $<span class="number">0x216</span>,%eax</div><div class="line"><span class="number">8048</span>f41:   eb <span class="number">0</span>a                   jmp    <span class="number">8048</span>f4d &lt;phase_3+<span class="number">0xac</span>&gt;</div><div class="line"><span class="number">8048</span>f43:   e8 <span class="number">89</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">80490</span>d1 &lt;explode_bomb&gt;</div><div class="line"><span class="number">8048</span>f48:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</div><div class="line"><span class="number">8048</span>f4d:   <span class="number">83</span> <span class="number">7</span>d f4 <span class="number">05</span>             cmpl   $<span class="number">0x5</span>,<span class="number">-0xc</span>(%ebp)</div><div class="line"><span class="number">8048</span>f51:   <span class="number">7</span>f <span class="number">05</span>                   jg     <span class="number">8048</span>f58 &lt;phase_3+<span class="number">0xb7</span>&gt;</div><div class="line"><span class="number">8048</span>f53:   <span class="number">3</span>b <span class="number">45</span> f0                cmp    <span class="number">-0x10</span>(%ebp),%eax</div><div class="line"><span class="number">8048</span>f56:   <span class="number">74</span> <span class="number">05</span>                   je     <span class="number">8048</span>f5d &lt;phase_3+<span class="number">0xbc</span>&gt;</div><div class="line"><span class="number">8048</span>f58:   e8 <span class="number">74</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">80490</span>d1 &lt;explode_bomb&gt;</div><div class="line"><span class="number">8048</span>f5d:   c9                      leave</div></pre></td></tr></table></figure><p>1.把0x314送入%eax中，然后无条件跳转到<code>sub    $0x35a,%eax</code>语句中；<br>2.接着就是一系列的加减运算，中间有一段add 0x216与sub 0x216可以当做无效运算，因为它们的操作是对称的，不影响结果。<br>3.接下来就是无条件跳转到<code>cmpl   $0x5,-0xc(%ebp)</code>语句，从这条语句我们可以看到，第一个参数是不能大于5的，相比之前的小于7条件，缩小了范围，这也是为什么之前查看case条件跳转地址的时候只查看5个的原因。<br>4.接着就用<code>-0x10(%ebp)</code>（第二个参数）与%eax比较了，经过之前的运算可以得到%eax的最终结果为0x93(十进制的147)，比较成功之后就结束这一段程序了。<br>5.接着我们可以根据case条件的不同选择不同的跳转地址，然后根据具体的指令运算出%eax的最终结果，就不一一演示了，最终的结果为：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>:<span class="number">147</span></div><div class="line"><span class="number">1</span>:<span class="number">-641</span></div><div class="line"><span class="number">2</span>:<span class="number">217</span></div><div class="line"><span class="number">3</span>:<span class="number">-534</span></div><div class="line"><span class="number">4</span>:<span class="number">0</span></div><div class="line"><span class="number">5</span>:<span class="number">-534</span></div></pre></td></tr></table></figure><p>6.其实了解了它最终的运算结束地址之后完全不必再根据case条件一个个的去运算，我们可以直接把断点设置在运算结束时的下一个地址，在输入条件的时候输入自己想要的case，结果暂时乱输入一个，运行到断点的时候可以用<code>info reg</code>查看<code>eax</code>中的内容。<br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-11-07-122617.jpg" alt=""></p><hr><h6 id="phase4"><a href="#phase4" class="headerlink" title="phase4"></a>phase4</h6><p>phase_4汇编代码如下:</p><figure class="highlight as"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="number">08048e2</span>e &lt;phase_4&gt;:</div><div class="line"><span class="number">8048e2</span>e:   <span class="number">55</span>                      push   %ebp</div><div class="line"><span class="number">8048e2</span>f:   <span class="number">89</span> e5                   mov    %esp,%ebp</div><div class="line"><span class="number">8048e31</span>:   <span class="number">83</span> ec <span class="number">28</span>                sub    $<span class="number">0x28</span>,%esp</div><div class="line"><span class="number">8048e34</span>:   <span class="number">8</span>d <span class="number">45</span> f0                lea    <span class="number">-0x10</span>(%ebp),%eax</div><div class="line"><span class="number">8048e37</span>:   <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">0</span>c             mov    %eax,<span class="number">0xc</span>(%esp)</div><div class="line"><span class="number">8048e3</span>b:   <span class="number">8</span>d <span class="number">45</span> f4                lea    <span class="number">-0xc</span>(%ebp),%eax</div><div class="line"><span class="number">8048e3</span>e:   <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">08</span>             mov    %eax,<span class="number">0x8</span>(%esp)</div><div class="line"><span class="number">8048e42</span>:   c7 <span class="number">44</span> <span class="number">24</span> <span class="number">04</span> <span class="number">3</span>e a2 <span class="number">04</span>    movl   $<span class="number">0x804a23e</span>,<span class="number">0x4</span>(%esp)</div><div class="line"><span class="number">8048e49</span>:   <span class="number">08</span> </div><div class="line"><span class="number">8048e4</span>a:   <span class="number">8</span>b <span class="number">45</span> <span class="number">08</span>                mov    <span class="number">0x8</span>(%ebp),%eax</div><div class="line"><span class="number">8048e4</span>d:   <span class="number">89</span> <span class="number">04</span> <span class="number">24</span>                mov    %eax,(%esp)</div><div class="line"><span class="number">8048e50</span>:   e8 eb f9 ff ff          call   <span class="number">8048840</span> &lt;__isoc99_sscanf@plt&gt;</div><div class="line"><span class="number">8048e55</span>:   <span class="number">83</span> f8 <span class="number">02</span>                cmp    $<span class="number">0x2</span>,%eax</div><div class="line"><span class="number">8048e58</span>:   <span class="number">75</span> <span class="number">0</span>c                   jne    <span class="number">8048e66</span> &lt;phase_4+<span class="number">0x38</span>&gt;</div><div class="line"><span class="number">8048e5</span>a:   <span class="number">8</span>b <span class="number">45</span> f4                mov    <span class="number">-0xc</span>(%ebp),%eax</div><div class="line"><span class="number">8048e5</span>d:   <span class="number">85</span> c0                   test   %eax,%eax</div><div class="line"><span class="number">8048e5</span>f:   <span class="number">78</span> <span class="number">05</span>                   js     <span class="number">8048e66</span> &lt;phase_4+<span class="number">0x38</span>&gt;</div><div class="line"><span class="number">8048e61</span>:   <span class="number">83</span> f8 <span class="number">0</span>e                cmp    $<span class="number">0xe</span>,%eax</div><div class="line"><span class="number">8048e64</span>:   <span class="number">7</span>e <span class="number">05</span>                   jle    <span class="number">8048e6</span>b &lt;phase_4+<span class="number">0x3d</span>&gt;</div><div class="line"><span class="number">8048e66</span>:   e8 <span class="number">66</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">80490</span>d1 &lt;explode_bomb&gt;</div><div class="line"><span class="number">8048e6</span>b:   c7 <span class="number">44</span> <span class="number">24</span> <span class="number">08</span> <span class="number">0</span>e <span class="number">00</span> <span class="number">00</span>    movl   $<span class="number">0xe</span>,<span class="number">0x8</span>(%esp)</div><div class="line"><span class="number">8048e72</span>:   <span class="number">00</span> </div><div class="line"><span class="number">8048e73</span>:   c7 <span class="number">44</span> <span class="number">24</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   $<span class="number">0x0</span>,<span class="number">0x4</span>(%esp)</div><div class="line"><span class="number">8048e7</span>a:   <span class="number">00</span> </div><div class="line"><span class="number">8048e7</span>b:   <span class="number">8</span>b <span class="number">45</span> f4                mov    <span class="number">-0xc</span>(%ebp),%eax</div><div class="line"><span class="number">8048e7</span>e:   <span class="number">89</span> <span class="number">04</span> <span class="number">24</span>                mov    %eax,(%esp)</div><div class="line"><span class="number">8048e81</span>:   e8 da fc ff ff          call   <span class="number">8048</span>b60 &lt;func4&gt;</div><div class="line"><span class="number">8048e86</span>:   <span class="number">83</span> f8 <span class="number">01</span>                cmp    $<span class="number">0x1</span>,%eax</div><div class="line"><span class="number">8048e89</span>:   <span class="number">75</span> <span class="number">06</span>                   jne    <span class="number">8048e91</span> &lt;phase_4+<span class="number">0x63</span>&gt;</div><div class="line"><span class="number">8048e8</span>b:   <span class="number">83</span> <span class="number">7</span>d f0 <span class="number">01</span>             cmpl   $<span class="number">0x1</span>,<span class="number">-0x10</span>(%ebp)</div><div class="line"><span class="number">8048e8</span>f:   <span class="number">74</span> <span class="number">0</span>c                   je     <span class="number">8048e9</span>d &lt;phase_4+<span class="number">0x6f</span>&gt;</div><div class="line"><span class="number">8048e91</span>:   <span class="number">8</span>d b4 <span class="number">26</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    lea    <span class="number">0x0</span>(%esi,%eiz,<span class="number">1</span>),%esi</div><div class="line"><span class="number">8048e98</span>:   e8 <span class="number">34</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">80490</span>d1 &lt;explode_bomb&gt;</div><div class="line"><span class="number">8048e9</span>d:   c9                      leave  </div><div class="line"><span class="number">8048e9</span>e:   <span class="number">66</span> <span class="number">90</span>                   xchg   %ax,%ax</div><div class="line"><span class="number">8048</span>ea0:   c3                      ret</div></pre></td></tr></table></figure><p>根据<code>movl   $0x804a23e,0x4(%esp)</code>指令可以在gdb中查看<code>call   8048840 &lt;__isoc99_sscanf@plt&gt;</code>scanf函数与阶段三一样是需要输入两个数字的。<br>代码分析：<br>假设第一个参数为x，第二个参数为y。<br>1.输入完参数之后验证参数是否为2个，如果不是后续部分就不需要再进行下去了。<br>2.<code>mov    -0xc(%ebp),%eax</code>依然是熟悉的第一个参数的地址<code>-0xc(%ebp)</code>,接着就是测试x的符号位,<code>js     8048e66 &lt;phase_4+0x38&gt;</code>负数就跳转爆炸，所以x肯定是一个整数。又<code>cmp    $0xe,%eax</code>后跟jle指令跳转，所以x肯定也是不能大于0xe的。所以x的范围为：0~14。<br>3.</p>  <figure class="highlight as"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">8048e6</span>b:   c7 <span class="number">44</span> <span class="number">24</span> <span class="number">08</span> <span class="number">0</span>e <span class="number">00</span> <span class="number">00</span>    movl   $<span class="number">0xe</span>,<span class="number">0x8</span>(%esp)</div><div class="line"><span class="number">8048e72</span>:   <span class="number">00</span> </div><div class="line"><span class="number">8048e73</span>:   c7 <span class="number">44</span> <span class="number">24</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   $<span class="number">0x0</span>,<span class="number">0x4</span>(%esp)</div><div class="line"><span class="number">8048e7</span>a:   <span class="number">00</span> </div><div class="line"><span class="number">8048e7</span>b:   <span class="number">8</span>b <span class="number">45</span> f4                mov    <span class="number">-0xc</span>(%ebp),%eax</div><div class="line"><span class="number">8048e7</span>e:   <span class="number">89</span> <span class="number">04</span> <span class="number">24</span>                mov    %eax,(%esp)</div><div class="line"><span class="number">8048e81</span>:   e8 da fc ff ff          call   <span class="number">8048</span>b60 &lt;func4&gt;</div></pre></td></tr></table></figure><p>可以看到调用func4前的指令，是把三个数：0xe、0x0、x分别入栈，所以可以知道func4的参数为（x，0，14）。<br>4.</p>  <figure class="highlight as"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">8048e81</span>:   e8 da fc ff ff          call   <span class="number">8048</span>b60 &lt;func4&gt;</div><div class="line"><span class="number">8048e86</span>:   <span class="number">83</span> f8 <span class="number">01</span>                cmp    $<span class="number">0x1</span>,%eax</div><div class="line"><span class="number">8048e89</span>:   <span class="number">75</span> <span class="number">06</span>                   jne    <span class="number">8048e91</span> &lt;phase_4+<span class="number">0x63</span>&gt;</div><div class="line"><span class="number">8048e8</span>b:   <span class="number">83</span> <span class="number">7</span>d f0 <span class="number">01</span>             cmpl   $<span class="number">0x1</span>,<span class="number">-0x10</span>(%ebp)</div><div class="line"><span class="number">8048e8</span>f:   <span class="number">74</span> <span class="number">0</span>c                   je     <span class="number">8048e9</span>d &lt;phase_4+<span class="number">0x6f</span>&gt;</div><div class="line"><span class="number">8048e91</span>:   <span class="number">8</span>d b4 <span class="number">26</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    lea    <span class="number">0x0</span>(%esi,%eiz,<span class="number">1</span>),%esi</div><div class="line"><span class="number">8048e98</span>:   e8 <span class="number">34</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">80490</span>d1 &lt;explode_bomb&gt;</div><div class="line"><span class="number">8048e9</span>d:   c9                      leave</div></pre></td></tr></table></figure><p>再看调用func4结束之后的指令，首先%eax与0x1比较，不相等跳转爆炸。所以func4的返回值肯定必须为0x1，再接着就是用 0x1 与 -0x10(%ebp)（y）比较，相等则函数整个函数结束。所以y的值肯定也是为0x1的。<br>5.由上可知整个阶段的大概要点就是在0~14中的一个数传入func中经过一些列运算之后能够返回0x1，并且y同时也为1时整个拆炸弹过程成功。因为func4很繁杂，func4代码里还调用了自身（递归），一时间分析不出运算方法，又0~14并不是很大，所以采用试错，从0开始递增测试，最后的结果为<code>8 1</code>、<code>9 1</code>还有<code>11 1</code>这三组答案。</p><hr><h6 id="phase5"><a href="#phase5" class="headerlink" title="phase5"></a>phase5</h6><p>phase_5的汇编代码如下：</p><figure class="highlight as"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="number">08048</span>db8 &lt;phase_5&gt;:</div><div class="line"><span class="number">8048</span>db8:   <span class="number">55</span>                      push   %ebp</div><div class="line"><span class="number">8048</span>db9:   <span class="number">89</span> e5                   mov    %esp,%ebp</div><div class="line"><span class="number">8048</span>dbb:   <span class="number">56</span>                      push   %esi</div><div class="line"><span class="number">8048</span>dbc:   <span class="number">53</span>                      push   %ebx</div><div class="line"><span class="number">8048</span>dbd:   <span class="number">83</span> ec <span class="number">20</span>                sub    $<span class="number">0x20</span>,%esp</div><div class="line"><span class="number">8048</span>dc0:   <span class="number">8</span>d <span class="number">45</span> f0                lea    <span class="number">-0x10</span>(%ebp),%eax</div><div class="line"><span class="number">8048</span>dc3:   <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">0</span>c             mov    %eax,<span class="number">0xc</span>(%esp)</div><div class="line"><span class="number">8048</span>dc7:   <span class="number">8</span>d <span class="number">45</span> f4                lea    <span class="number">-0xc</span>(%ebp),%eax</div><div class="line"><span class="number">8048</span>dca:   <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">08</span>             mov    %eax,<span class="number">0x8</span>(%esp)</div><div class="line"><span class="number">8048</span>dce:   c7 <span class="number">44</span> <span class="number">24</span> <span class="number">04</span> <span class="number">3</span>e a2 <span class="number">04</span>    movl   $<span class="number">0x804a23e</span>,<span class="number">0x4</span>(%esp)</div><div class="line"><span class="number">8048</span>dd5:   <span class="number">08</span> </div><div class="line"><span class="number">8048</span>dd6:   <span class="number">8</span>b <span class="number">45</span> <span class="number">08</span>                mov    <span class="number">0x8</span>(%ebp),%eax</div><div class="line"><span class="number">8048</span>dd9:   <span class="number">89</span> <span class="number">04</span> <span class="number">24</span>                mov    %eax,(%esp)</div><div class="line"><span class="number">8048</span>ddc:   e8 <span class="number">5</span>f fa ff ff          call   <span class="number">8048840</span> &lt;__isoc99_sscanf@plt&gt;</div><div class="line"><span class="number">8048</span>de1:   <span class="number">83</span> f8 <span class="number">01</span>                cmp    $<span class="number">0x1</span>,%eax</div><div class="line"><span class="number">8048</span>de4:   <span class="number">7</span>f <span class="number">05</span>                   jg     <span class="number">8048</span>deb &lt;phase_5+<span class="number">0x33</span>&gt;</div><div class="line"><span class="number">8048</span>de6:   e8 e6 <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">80490</span>d1 &lt;explode_bomb&gt;</div><div class="line"><span class="number">8048</span>deb:   <span class="number">8</span>b <span class="number">45</span> f4                mov    <span class="number">-0xc</span>(%ebp),%eax</div><div class="line"><span class="number">8048</span>dee:   <span class="number">83</span> e0 <span class="number">0</span>f                and    $<span class="number">0xf</span>,%eax</div><div class="line"><span class="number">8048</span>df1:   <span class="number">89</span> <span class="number">45</span> f4                mov    %eax,<span class="number">-0xc</span>(%ebp)</div><div class="line"><span class="number">8048</span>df4:   <span class="number">83</span> f8 <span class="number">0</span>f                cmp    $<span class="number">0xf</span>,%eax</div><div class="line"><span class="number">8048</span>df7:   <span class="number">74</span> <span class="number">29</span>                   je     <span class="number">8048e22</span> &lt;phase_5+<span class="number">0x6a</span>&gt;</div><div class="line"><span class="number">8048</span>df9:   b9 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%ecx</div><div class="line"><span class="number">8048</span>dfe:   ba <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%edx</div><div class="line"><span class="number">8048e03</span>:   bb c0 a1 <span class="number">04</span> <span class="number">08</span>          mov    $<span class="number">0x804a1c0</span>,%ebx</div><div class="line"><span class="number">8048e08</span>:   <span class="number">83</span> c2 <span class="number">01</span>                add    $<span class="number">0x1</span>,%edx</div><div class="line"><span class="number">8048e0</span>b:   <span class="number">8</span>b <span class="number">04</span> <span class="number">83</span>                mov    (%ebx,%eax,<span class="number">4</span>),%eax</div><div class="line"><span class="number">8048e0</span>e:   <span class="number">01</span> c1                   add    %eax,%ecx</div><div class="line"><span class="number">8048e10</span>:   <span class="number">83</span> f8 <span class="number">0</span>f                cmp    $<span class="number">0xf</span>,%eax</div><div class="line"><span class="number">8048e13</span>:   <span class="number">75</span> f3                   jne    <span class="number">8048e08</span> &lt;phase_5+<span class="number">0x50</span>&gt;</div><div class="line"><span class="number">8048e15</span>:   <span class="number">89</span> <span class="number">45</span> f4                mov    %eax,<span class="number">-0xc</span>(%ebp)</div><div class="line"><span class="number">8048e18</span>:   <span class="number">83</span> fa <span class="number">0</span>f                cmp    $<span class="number">0xf</span>,%edx</div><div class="line"><span class="number">8048e1</span>b:   <span class="number">75</span> <span class="number">05</span>                   jne    <span class="number">8048e22</span> &lt;phase_5+<span class="number">0x6a</span>&gt;</div><div class="line"><span class="number">8048e1</span>d:   <span class="number">39</span> <span class="number">4</span>d f0                cmp    %ecx,<span class="number">-0x10</span>(%ebp)</div><div class="line"><span class="number">8048e20</span>:   <span class="number">74</span> <span class="number">05</span>                   je     <span class="number">8048e27</span> &lt;phase_5+<span class="number">0x6f</span>&gt;</div><div class="line"><span class="number">8048e22</span>:   e8 aa <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">80490</span>d1 &lt;explode_bomb&gt;</div><div class="line"><span class="number">8048e27</span>:   <span class="number">83</span> c4 <span class="number">20</span>                add    $<span class="number">0x20</span>,%esp</div><div class="line"><span class="number">8048e2</span>a:   <span class="number">5</span>b                      pop    %ebx</div><div class="line"><span class="number">8048e2</span>b:   <span class="number">5</span>e                      pop    %esi</div><div class="line"><span class="number">8048e2</span>c:   <span class="number">5</span>d                      pop    %ebp</div><div class="line"><span class="number">8048e2</span>d:   c3                      ret</div></pre></td></tr></table></figure><p>根据<code>movl   $0x804a23e,0x4(%esp)</code>指令可以在gdb中查看<code>call   8048840 &lt;__isoc99_sscanf@plt&gt;</code>scanf函数与阶段四一样是需要输入两个数字的。可以很清楚的知道<code>-0xc(%ebp)</code>与<code>-0x10(%ebp)</code>分别为第一个与第二个参数。再根据</p><figure class="highlight as"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">8048e1</span>d:   <span class="number">39</span> <span class="number">4</span>d f0                cmp    %ecx,<span class="number">-0x10</span>(%ebp)</div><div class="line"><span class="number">8048e20</span>:   <span class="number">74</span> <span class="number">05</span>                   je     <span class="number">8048e27</span> &lt;phase_5+<span class="number">0x6f</span>&gt;</div></pre></td></tr></table></figure><p>最后这两条指令，可以知道最后经过运算后的%ecx与第二个参数相等时整个函数结束。<br>接着来解析一下下面这段指令：</p><figure class="highlight as"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="number">8048</span>ddc:   e8 <span class="number">5</span>f fa ff ff          call   <span class="number">8048840</span> &lt;__isoc99_sscanf@plt&gt;</div><div class="line"><span class="number">8048</span>de1:   <span class="number">83</span> f8 <span class="number">01</span>                cmp    $<span class="number">0x1</span>,%eax</div><div class="line"><span class="number">8048</span>de4:   <span class="number">7</span>f <span class="number">05</span>                   jg     <span class="number">8048</span>deb &lt;phase_5+<span class="number">0x33</span>&gt;</div><div class="line"><span class="number">8048</span>de6:   e8 e6 <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">80490</span>d1 &lt;explode_bomb&gt;</div><div class="line"><span class="number">8048</span>deb:   <span class="number">8</span>b <span class="number">45</span> f4                mov    <span class="number">-0xc</span>(%ebp),%eax</div><div class="line"><span class="number">8048</span>dee:   <span class="number">83</span> e0 <span class="number">0</span>f                and    $<span class="number">0xf</span>,%eax</div><div class="line"><span class="number">8048</span>df1:   <span class="number">89</span> <span class="number">45</span> f4                mov    %eax,<span class="number">-0xc</span>(%ebp)</div><div class="line"><span class="number">8048</span>df4:   <span class="number">83</span> f8 <span class="number">0</span>f                cmp    $<span class="number">0xf</span>,%eax</div><div class="line"><span class="number">8048</span>df7:   <span class="number">74</span> <span class="number">29</span>                   je     <span class="number">8048e22</span> &lt;phase_5+<span class="number">0x6a</span>&gt;</div><div class="line"><span class="number">8048</span>df9:   b9 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%ecx</div><div class="line"><span class="number">8048</span>dfe:   ba <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%edx</div><div class="line"><span class="number">8048e03</span>:   bb c0 a1 <span class="number">04</span> <span class="number">08</span>          mov    $<span class="number">0x804a1c0</span>,%ebx</div><div class="line"><span class="number">8048e08</span>:   <span class="number">83</span> c2 <span class="number">01</span>                add    $<span class="number">0x1</span>,%edx</div><div class="line"><span class="number">8048e0</span>b:   <span class="number">8</span>b <span class="number">04</span> <span class="number">83</span>                mov    (%ebx,%eax,<span class="number">4</span>),%eax</div><div class="line"><span class="number">8048e0</span>e:   <span class="number">01</span> c1                   add    %eax,%ecx</div><div class="line"><span class="number">8048e10</span>:   <span class="number">83</span> f8 <span class="number">0</span>f                cmp    $<span class="number">0xf</span>,%eax</div><div class="line"><span class="number">8048e13</span>:   <span class="number">75</span> f3                   jne    <span class="number">8048e08</span> &lt;phase_5+<span class="number">0x50</span>&gt;</div><div class="line"><span class="number">8048e15</span>:   <span class="number">89</span> <span class="number">45</span> f4                mov    %eax,<span class="number">-0xc</span>(%ebp)</div><div class="line"><span class="number">8048e18</span>:   <span class="number">83</span> fa <span class="number">0</span>f                cmp    $<span class="number">0xf</span>,%edx</div><div class="line"><span class="number">8048e1</span>b:   <span class="number">75</span> <span class="number">05</span>                   jne    <span class="number">8048e22</span> &lt;phase_5+<span class="number">0x6a</span>&gt;</div></pre></td></tr></table></figure><p>我们假设第一个参数为x，第二参数为y。<br>1.scanf读取输入数字之后用<code>cmp    $0x1,%eax</code>指令验证输入参数是否大于1个，如果小于或等于则爆炸。然后是通过用x&amp;0xff，确保后四位不都为1，否则爆炸。接着就进入了一个循环，经过不断分析，整个循环大概意思如以下代码:</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">ecx=<span class="number">0</span>;</div><div class="line">edx=<span class="number">0</span>;</div><div class="line">ebx=<span class="keyword">int</span> [];</div><div class="line"><span class="keyword">for</span>(edx=<span class="number">1</span>; eax != <span class="number">0xf</span>; edx++)&#123;</div><div class="line">    eax = ebx[eax];</div><div class="line">    ecx+=eax;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(edx == <span class="number">0xf</span>) &#123;</div><div class="line">    <span class="keyword">if</span>(ecx == y)&#123;</div><div class="line">        phase_defused();</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        explode_bomb();</div><div class="line">    &#125;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    explode_bomb();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>2.上面的代码的主要意思就是传入第一个参数之后，有一个计数器，每一次循环就++，循环到eax寄存器中的值0xf时才停止，但是同时要求是循环0xf次（15次）才满足要求，如果提前或者延后都会导致调用爆炸函数。<br>3.为什么知道ebx是一个数组？</p>  <figure class="highlight as"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mov    $<span class="number">0x804a1c0</span>,%ebx</div><div class="line">add    $<span class="number">0x1</span>,%edx</div><div class="line">mov    (%ebx,%eax,<span class="number">4</span>),%eax</div></pre></td></tr></table></figure><p>因为从第三句指令可以知道，是以%ebx为基址，%eax为偏移因子来计算具体的地址的。不难想象%eax是数组的下标，整个数组是int型，每一次都用<code>下标*4</code>来求出偏移地址。为了验证这个想法可以使用<code>p /x *(int*)0x804a1c0@50</code>指令在gdb中查看，因为不知道具体的数组的大小，所以可以随便@一个大小：<br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-11-07-122645.jpg" alt=""><br>显然想法是正确的，整个数组有效数字为16位。分别为[a,2,e,7,8,c,f,b,0,4,1,d,3,9,6,5]（16进制）。所以下标与具体的值的对应关系如下:</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>:a</div><div class="line"><span class="number">1</span>:<span class="number">2</span></div><div class="line"><span class="number">2</span>:e</div><div class="line"><span class="number">3</span>:<span class="number">7</span></div><div class="line"><span class="number">4</span>:<span class="number">8</span></div><div class="line"><span class="number">5</span>:c</div><div class="line"><span class="number">6</span>:f</div><div class="line"><span class="number">7</span>:b</div><div class="line"><span class="number">8</span>:<span class="number">0</span></div><div class="line"><span class="number">9</span>:<span class="number">4</span></div><div class="line">a:<span class="number">1</span></div><div class="line">b:d</div><div class="line">c:<span class="number">3</span></div><div class="line">d:<span class="number">9</span></div><div class="line">e:<span class="number">6</span></div><div class="line">f:<span class="number">5</span></div></pre></td></tr></table></figure><p>4.因为要循环15次，且在最后一次才能推出0xf，所以选择逆推是比较方便的,逆推关系为：f&lt;-6&lt;-e&lt;-2&lt;-1&lt;-a&lt;-0&lt;-8&lt;-4&lt;-9&lt;-d&lt;-b&lt;-7&lt;-3&lt;-c&lt;-5&lt;-f。所以x应该为5,y应该为5-&gt;f这个过程中所有的数之和(不含5)，也就是115。<br>5.同第三阶段，其实弄清它的关系之后可以不需要计算了，在第一个参数输入5之后，第二个参数可以任意输入，把断点设置在运算比较指令处<code>0x8048e15</code>，通过<code>info reg</code>来查看值即可。<br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-11-07-122706.jpg" alt=""></p><hr><h6 id="phase6"><a href="#phase6" class="headerlink" title="phase6"></a>phase6</h6><p>phase_6的汇编代码如下：</p><figure class="highlight as"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="number">08048</span>c89 &lt;phase_6&gt;:</div><div class="line"><span class="number">8048</span>c89:   <span class="number">55</span>                      push   %ebp</div><div class="line"><span class="number">8048</span>c8a:   <span class="number">89</span> e5                   mov    %esp,%ebp</div><div class="line"><span class="number">8048</span>c8c:   <span class="number">57</span>                      push   %edi</div><div class="line"><span class="number">8048</span>c8d:   <span class="number">56</span>                      push   %esi</div><div class="line"><span class="number">8048</span>c8e:   <span class="number">53</span>                      push   %ebx</div><div class="line"><span class="number">8048</span>c8f:   <span class="number">83</span> ec <span class="number">5</span>c                sub    $<span class="number">0x5c</span>,%esp</div><div class="line"><span class="number">8048</span>c92:   <span class="number">8</span>d <span class="number">45</span> d0                lea    <span class="number">-0x30</span>(%ebp),%eax</div><div class="line"><span class="number">8048</span>c95:   <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">04</span>             mov    %eax,<span class="number">0x4</span>(%esp)</div><div class="line"><span class="number">8048</span>c99:   <span class="number">8</span>b <span class="number">45</span> <span class="number">08</span>                mov    <span class="number">0x8</span>(%ebp),%eax</div><div class="line"><span class="number">8048</span>c9c:   <span class="number">89</span> <span class="number">04</span> <span class="number">24</span>                mov    %eax,(%esp)</div><div class="line"><span class="number">8048</span>c9f:   e8 <span class="number">67</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">804910</span>b &lt;read_six_numbers&gt;</div><div class="line"><span class="number">8048</span>ca4:   be <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%esi</div><div class="line"><span class="number">8048</span>ca9:   <span class="number">8</span>d <span class="number">7</span>d d0                lea    <span class="number">-0x30</span>(%ebp),%edi</div><div class="line"><span class="number">8048</span>cac:   <span class="number">8</span>b <span class="number">04</span> b7                mov    (%edi,%esi,<span class="number">4</span>),%eax</div><div class="line"><span class="number">8048</span>caf:   <span class="number">83</span> e8 <span class="number">01</span>                sub    $<span class="number">0x1</span>,%eax</div><div class="line"><span class="number">8048</span>cb2:   <span class="number">83</span> f8 <span class="number">05</span>                cmp    $<span class="number">0x5</span>,%eax</div><div class="line"><span class="number">8048</span>cb5:   <span class="number">76</span> <span class="number">05</span>                   jbe    <span class="number">8048</span>cbc &lt;phase_6+<span class="number">0x33</span>&gt;</div><div class="line"><span class="number">8048</span>cb7:   e8 <span class="number">15</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">80490</span>d1 &lt;explode_bomb&gt;</div><div class="line"><span class="number">8048</span>cbc:   <span class="number">83</span> c6 <span class="number">01</span>                add    $<span class="number">0x1</span>,%esi</div><div class="line"><span class="number">8048</span>cbf:   <span class="number">83</span> fe <span class="number">06</span>                cmp    $<span class="number">0x6</span>,%esi</div><div class="line"><span class="number">8048</span>cc2:   <span class="number">74</span> <span class="number">22</span>                   je     <span class="number">8048</span>ce6 &lt;phase_6+<span class="number">0x5d</span>&gt;</div><div class="line"><span class="number">8048</span>cc4:   <span class="number">8</span>d <span class="number">1</span>c b7                lea    (%edi,%esi,<span class="number">4</span>),%ebx</div><div class="line"><span class="number">8048</span>cc7:   <span class="number">89</span> <span class="number">75</span> b4                mov    %esi,<span class="number">-0x4c</span>(%ebp)</div><div class="line"><span class="number">8048</span>cca:   <span class="number">8</span>b <span class="number">44</span> b7 fc             mov    <span class="number">-0x4</span>(%edi,%esi,<span class="number">4</span>),%eax</div><div class="line"><span class="number">8048</span>cce:   <span class="number">3</span>b <span class="number">03</span>                   cmp    (%ebx),%eax</div><div class="line"><span class="number">8048</span>cd0:   <span class="number">75</span> <span class="number">05</span>                   jne    <span class="number">8048</span>cd7 &lt;phase_6+<span class="number">0x4e</span>&gt;</div><div class="line"><span class="number">8048</span>cd2:   e8 fa <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">80490</span>d1 &lt;explode_bomb&gt;</div><div class="line"><span class="number">8048</span>cd7:   <span class="number">83</span> <span class="number">45</span> b4 <span class="number">01</span>             addl   $<span class="number">0x1</span>,<span class="number">-0x4c</span>(%ebp)</div><div class="line"><span class="number">8048</span>cdb:   <span class="number">83</span> c3 <span class="number">04</span>                add    $<span class="number">0x4</span>,%ebx</div><div class="line"><span class="number">8048</span>cde:   <span class="number">83</span> <span class="number">7</span>d b4 <span class="number">05</span>             cmpl   $<span class="number">0x5</span>,<span class="number">-0x4c</span>(%ebp)</div><div class="line"><span class="number">8048</span>ce2:   <span class="number">7</span>e e6                   jle    <span class="number">8048</span>cca &lt;phase_6+<span class="number">0x41</span>&gt;</div><div class="line"><span class="number">8048</span>ce4:   eb c6                   jmp    <span class="number">8048</span>cac &lt;phase_6+<span class="number">0x23</span>&gt;</div><div class="line"><span class="number">8048</span>ce6:   bb <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%ebx</div><div class="line"><span class="number">8048</span>ceb:   <span class="number">8</span>d <span class="number">7</span>d d0                lea    <span class="number">-0x30</span>(%ebp),%edi</div><div class="line"><span class="number">8048</span>cee:   eb <span class="number">16</span>                   jmp    <span class="number">8048</span>d06 &lt;phase_6+<span class="number">0x7d</span>&gt;</div><div class="line"><span class="number">8048</span>cf0:   <span class="number">8</span>b <span class="number">52</span> <span class="number">08</span>                mov    <span class="number">0x8</span>(%edx),%edx</div><div class="line"><span class="number">8048</span>cf3:   <span class="number">83</span> c0 <span class="number">01</span>                add    $<span class="number">0x1</span>,%eax</div><div class="line"><span class="number">8048</span>cf6:   <span class="number">39</span> c8                   cmp    %ecx,%eax</div><div class="line"><span class="number">8048</span>cf8:   <span class="number">75</span> f6                   jne    <span class="number">8048</span>cf0 &lt;phase_6+<span class="number">0x67</span>&gt;</div><div class="line"><span class="number">8048</span>cfa:   <span class="number">89</span> <span class="number">54</span> b5 b8             mov    %edx,<span class="number">-0x48</span>(%ebp,%esi,<span class="number">4</span>)</div><div class="line"><span class="number">8048</span>cfe:   <span class="number">83</span> c3 <span class="number">01</span>                add    $<span class="number">0x1</span>,%ebx</div><div class="line"><span class="number">8048</span>d01:   <span class="number">83</span> fb <span class="number">06</span>                cmp    $<span class="number">0x6</span>,%ebx</div><div class="line"><span class="number">8048</span>d04:   <span class="number">74</span> <span class="number">16</span>                   je     <span class="number">8048</span>d1c &lt;phase_6+<span class="number">0x93</span>&gt;</div><div class="line"><span class="number">8048</span>d06:   <span class="number">89</span> de                   mov    %ebx,%esi</div><div class="line"><span class="number">8048</span>d08:   <span class="number">8</span>b <span class="number">0</span>c <span class="number">9</span>f                mov    (%edi,%ebx,<span class="number">4</span>),%ecx</div><div class="line"><span class="number">8048</span>d0b:   ba c4 c0 <span class="number">04</span> <span class="number">08</span>          mov    $<span class="number">0x804c0c4</span>,%edx</div><div class="line"><span class="number">8048</span>d10:   b8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x1</span>,%eax</div><div class="line"><span class="number">8048</span>d15:   <span class="number">83</span> f9 <span class="number">01</span>                cmp    $<span class="number">0x1</span>,%ecx</div><div class="line"><span class="number">8048</span>d18:   <span class="number">7</span>f d6                   jg     <span class="number">8048</span>cf0 &lt;phase_6+<span class="number">0x67</span>&gt;</div><div class="line"><span class="number">8048</span>d1a:   eb de                   jmp    <span class="number">8048</span>cfa &lt;phase_6+<span class="number">0x71</span>&gt;</div><div class="line"><span class="number">8048</span>d1c:   <span class="number">8</span>b <span class="number">5</span>d b8                mov    <span class="number">-0x48</span>(%ebp),%ebx</div><div class="line"><span class="number">8048</span>d1f:   <span class="number">8</span>b <span class="number">45</span> bc                mov    <span class="number">-0x44</span>(%ebp),%eax</div><div class="line"><span class="number">8048</span>d22:   <span class="number">89</span> <span class="number">43</span> <span class="number">08</span>                mov    %eax,<span class="number">0x8</span>(%ebx)</div><div class="line"><span class="number">8048</span>d25:   <span class="number">8</span>b <span class="number">55</span> c0                mov    <span class="number">-0x40</span>(%ebp),%edx</div><div class="line"><span class="number">8048</span>d28:   <span class="number">89</span> <span class="number">50</span> <span class="number">08</span>                mov    %edx,<span class="number">0x8</span>(%eax)</div><div class="line"><span class="number">8048</span>d2b:   <span class="number">8</span>b <span class="number">45</span> c4                mov    <span class="number">-0x3c</span>(%ebp),%eax</div><div class="line"><span class="number">8048</span>d2e:   <span class="number">89</span> <span class="number">42</span> <span class="number">08</span>                mov    %eax,<span class="number">0x8</span>(%edx)</div><div class="line"><span class="number">8048</span>d31:   <span class="number">8</span>b <span class="number">55</span> c8                mov    <span class="number">-0x38</span>(%ebp),%edx</div><div class="line"><span class="number">8048</span>d34:   <span class="number">89</span> <span class="number">50</span> <span class="number">08</span>                mov    %edx,<span class="number">0x8</span>(%eax)</div><div class="line"><span class="number">8048</span>d37:   <span class="number">8</span>b <span class="number">45</span> cc                mov    <span class="number">-0x34</span>(%ebp),%eax</div><div class="line"><span class="number">8048</span>d3a:   <span class="number">89</span> <span class="number">42</span> <span class="number">08</span>                mov    %eax,<span class="number">0x8</span>(%edx)</div><div class="line"><span class="number">8048</span>d3d:   c7 <span class="number">40</span> <span class="number">08</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   $<span class="number">0x0</span>,<span class="number">0x8</span>(%eax)</div><div class="line"><span class="number">8048</span>d44:   be <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%esi</div><div class="line"><span class="number">8048</span>d49:   <span class="number">8</span>b <span class="number">43</span> <span class="number">08</span>                mov    <span class="number">0x8</span>(%ebx),%eax</div><div class="line"><span class="number">8048</span>d4c:   <span class="number">8</span>b <span class="number">13</span>                   mov    (%ebx),%edx</div><div class="line"><span class="number">8048</span>d4e:   <span class="number">3</span>b <span class="number">10</span>                   cmp    (%eax),%edx</div><div class="line"><span class="number">8048</span>d50:   <span class="number">7</span>d <span class="number">05</span>                   jge    <span class="number">8048</span>d57 &lt;phase_6+<span class="number">0xce</span>&gt;</div><div class="line"><span class="number">8048</span>d52:   e8 <span class="number">7</span>a <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">80490</span>d1 &lt;explode_bomb&gt;</div><div class="line"><span class="number">8048</span>d57:   <span class="number">8</span>b <span class="number">5</span>b <span class="number">08</span>                mov    <span class="number">0x8</span>(%ebx),%ebx</div><div class="line"><span class="number">8048</span>d5a:   <span class="number">83</span> c6 <span class="number">01</span>                add    $<span class="number">0x1</span>,%esi</div><div class="line"><span class="number">8048</span>d5d:   <span class="number">83</span> fe <span class="number">05</span>                cmp    $<span class="number">0x5</span>,%esi</div><div class="line"><span class="number">8048</span>d60:   <span class="number">75</span> e7                   jne    <span class="number">8048</span>d49 &lt;phase_6+<span class="number">0xc0</span>&gt;</div><div class="line"><span class="number">8048</span>d62:   <span class="number">83</span> c4 <span class="number">5</span>c                add    $<span class="number">0x5c</span>,%esp</div><div class="line"><span class="number">8048</span>d65:   <span class="number">5</span>b                      pop    %ebx</div><div class="line"><span class="number">8048</span>d66:   <span class="number">5</span>e                      pop    %esi</div><div class="line"><span class="number">8048</span>d67:   <span class="number">5</span>f                      pop    %edi</div><div class="line"><span class="number">8048</span>d68:   <span class="number">5</span>d                      pop    %ebp</div><div class="line"><span class="number">8048</span>d69:   c3                      ret</div></pre></td></tr></table></figure><p>这题汇编代码很长，看得昏天黑地的。根据网上的解析，下面慢慢把这段代码拆开分析吧。首先还是按整体到局部的思想来，整段代码是需要输入6个数字，且6个数字都不能大于6。这六个数字的意义是按照这几个数字的顺序来排列已经存在的链表，使它们是按降序来进行排列的。<br>很自然的我们想到的是就是找出原来的链表的顺序，人工地按照其大小来进行从新排列得出这六个序列。</p><p>在程序内部，第一步当然是要先校验输入的留个序列是否都满足小于6这个条件。然后就是按输入序列重新把链表进行排序，接着再验证是否是降序排列。下面分步解析整段代码：</p><p>1.判断输入序列是否满足都小于6的这个条件，用一个循环，%esi为偏移因子也为循环判断条件，循环一次+1：</p>  <figure class="highlight as"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="number">8048</span>ca4:   be <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%esi</div><div class="line"><span class="number">8048</span>ca9:   <span class="number">8</span>d <span class="number">7</span>d d0                lea    <span class="number">-0x30</span>(%ebp),%edi<span class="comment">//把栈底指针上移0x30赋值给%edi</span></div><div class="line"><span class="number">8048</span>cac:   <span class="number">8</span>b <span class="number">04</span> b7                mov    (%edi,%esi,<span class="number">4</span>),%eax<span class="comment">//从第一个输入序列开始遍历，以%edi为基址</span></div><div class="line"><span class="number">8048</span>caf:   <span class="number">83</span> e8 <span class="number">01</span>                sub    $<span class="number">0x1</span>,%eax</div><div class="line"><span class="number">8048</span>cb2:   <span class="number">83</span> f8 <span class="number">05</span>                cmp    $<span class="number">0x5</span>,%eax</div><div class="line"><span class="number">8048</span>cb5:   <span class="number">76</span> <span class="number">05</span>                   jbe    <span class="number">8048</span>cbc &lt;phase_6+<span class="number">0x33</span>&gt;</div><div class="line"><span class="number">8048</span>cb7:   e8 <span class="number">15</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">80490</span>d1 &lt;explode_bomb&gt;</div><div class="line"><span class="number">8048</span>cbc:   <span class="number">83</span> c6 <span class="number">01</span>                add    $<span class="number">0x1</span>,%esi</div><div class="line"><span class="number">8048</span>cbf:   <span class="number">83</span> fe <span class="number">06</span>                cmp    $<span class="number">0x6</span>,%esi</div><div class="line"><span class="number">8048</span>cc2:   <span class="number">74</span> <span class="number">22</span>                   je     <span class="number">8048</span>ce6 &lt;phase_6+<span class="number">0x5d</span>&gt;</div><div class="line"><span class="number">8048</span>cc4:   <span class="number">8</span>d <span class="number">1</span>c b7                lea    (%edi,%esi,<span class="number">4</span>),%ebx</div><div class="line"><span class="number">8048</span>cc7:   <span class="number">89</span> <span class="number">75</span> b4                mov    %esi,<span class="number">-0x4c</span>(%ebp)</div><div class="line"><span class="number">8048</span>cca:   <span class="number">8</span>b <span class="number">44</span> b7 fc             mov    <span class="number">-0x4</span>(%edi,%esi,<span class="number">4</span>),%eax</div><div class="line"><span class="number">8048</span>cce:   <span class="number">3</span>b <span class="number">03</span>                   cmp    (%ebx),%eax</div><div class="line"><span class="number">8048</span>cd0:   <span class="number">75</span> <span class="number">05</span>                   jne    <span class="number">8048</span>cd7 &lt;phase_6+<span class="number">0x4e</span>&gt;</div><div class="line"><span class="number">8048</span>cd2:   e8 fa <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">80490</span>d1 &lt;explode_bomb&gt;</div><div class="line"><span class="number">8048</span>cd7:   <span class="number">83</span> <span class="number">45</span> b4 <span class="number">01</span>             addl   $<span class="number">0x1</span>,<span class="number">-0x4c</span>(%ebp)</div><div class="line"><span class="number">8048</span>cdb:   <span class="number">83</span> c3 <span class="number">04</span>                add    $<span class="number">0x4</span>,%ebx</div><div class="line"><span class="number">8048</span>cde:   <span class="number">83</span> <span class="number">7</span>d b4 <span class="number">05</span>             cmpl   $<span class="number">0x5</span>,<span class="number">-0x4c</span>(%ebp)</div><div class="line"><span class="number">8048</span>ce2:   <span class="number">7</span>e e6                   jle    <span class="number">8048</span>cca &lt;phase_6+<span class="number">0x41</span>&gt;</div><div class="line"><span class="number">8048</span>ce4:   eb c6                   jmp    <span class="number">8048</span>cac &lt;phase_6+<span class="number">0x23</span>&gt;</div></pre></td></tr></table></figure><p>2.按输入序列进行排列：</p>  <figure class="highlight as"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="number">8048</span>ce6:   bb <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%ebx</div><div class="line"><span class="number">8048</span>ceb:   <span class="number">8</span>d <span class="number">7</span>d d0                lea    <span class="number">-0x30</span>(%ebp),%edi</div><div class="line"><span class="number">8048</span>cee:   eb <span class="number">16</span>                   jmp    <span class="number">8048</span>d06 &lt;phase_6+<span class="number">0x7d</span>&gt;</div><div class="line"><span class="number">8048</span>cf0:   <span class="number">8</span>b <span class="number">52</span> <span class="number">08</span>                mov    <span class="number">0x8</span>(%edx),%edx</div><div class="line"><span class="number">8048</span>cf3:   <span class="number">83</span> c0 <span class="number">01</span>                add    $<span class="number">0x1</span>,%eax</div><div class="line"><span class="number">8048</span>cf6:   <span class="number">39</span> c8                   cmp    %ecx,%eax</div><div class="line"><span class="number">8048</span>cf8:   <span class="number">75</span> f6                   jne    <span class="number">8048</span>cf0 &lt;phase_6+<span class="number">0x67</span>&gt;</div><div class="line"><span class="number">8048</span>cfa:   <span class="number">89</span> <span class="number">54</span> b5 b8             mov    %edx,<span class="number">-0x48</span>(%ebp,%esi,<span class="number">4</span>)</div><div class="line"><span class="number">8048</span>cfe:   <span class="number">83</span> c3 <span class="number">01</span>                add    $<span class="number">0x1</span>,%ebx</div><div class="line"><span class="number">8048</span>d01:   <span class="number">83</span> fb <span class="number">06</span>                cmp    $<span class="number">0x6</span>,%ebx</div><div class="line"><span class="number">8048</span>d04:   <span class="number">74</span> <span class="number">16</span>                   je     <span class="number">8048</span>d1c &lt;phase_6+<span class="number">0x93</span>&gt;</div><div class="line"><span class="number">8048</span>d06:   <span class="number">89</span> de                   mov    %ebx,%esi</div><div class="line"><span class="number">8048</span>d08:   <span class="number">8</span>b <span class="number">0</span>c <span class="number">9</span>f                mov    (%edi,%ebx,<span class="number">4</span>),%ecx</div><div class="line"><span class="number">8048</span>d0b:   ba c4 c0 <span class="number">04</span> <span class="number">08</span>          mov    $<span class="number">0x804c0c4</span>,%edx</div><div class="line"><span class="number">8048</span>d10:   b8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x1</span>,%eax</div><div class="line"><span class="number">8048</span>d15:   <span class="number">83</span> f9 <span class="number">01</span>                cmp    $<span class="number">0x1</span>,%ecx</div><div class="line"><span class="number">8048</span>d18:   <span class="number">7</span>f d6                   jg     <span class="number">8048</span>cf0 &lt;phase_6+<span class="number">0x67</span>&gt;</div><div class="line"><span class="number">8048</span>d1a:   eb de                   jmp    <span class="number">8048</span>cfa &lt;phase_6+<span class="number">0x71</span>&gt;</div></pre></td></tr></table></figure><p> 以上汇编代码等价于如下C代码：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</div><div class="line">    addr = <span class="number">0x804c0c4</span>；</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; data[i]; j++)</div><div class="line">        addr = *(addr + <span class="number">0x8</span>);</div><div class="line">    <span class="number">-0x48</span>(%ebp + <span class="number">4</span> * i) = addr;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过两层循环，根据我们输入的序列（数组），依次根据<code>0x804c0c4</code>这个基址查找当前序列所指的节点（通过一层循环，循环条件为当前序列值，每次地址+8，循环结束之后就是所需要的节点），然后依次反向入栈(序列1在栈顶，序列六在栈底)。</p><p>3.按输入序列重建一个链表</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">8048</span>d1c:   <span class="number">8b</span> <span class="number">5</span>d b8                mov    <span class="number">-0x48</span>(%ebp),%ebx</div><div class="line"><span class="number">8048</span>d1f:   <span class="number">8b</span> <span class="number">45</span> bc                mov    <span class="number">-0x44</span>(%ebp),%eax</div><div class="line"><span class="number">8048</span>d22:   <span class="number">89</span> <span class="number">43</span> <span class="number">08</span>                mov    %eax,<span class="number">0x8</span>(%ebx)</div><div class="line"><span class="number">8048</span>d25:   <span class="number">8b</span> <span class="number">55</span> c0                mov    <span class="number">-0x40</span>(%ebp),%edx</div><div class="line"><span class="number">8048</span>d28:   <span class="number">89</span> <span class="number">50</span> <span class="number">08</span>                mov    %edx,<span class="number">0x8</span>(%eax)</div><div class="line"><span class="number">8048</span>d2b:   <span class="number">8b</span> <span class="number">45</span> c4                mov    <span class="number">-0x3c</span>(%ebp),%eax</div><div class="line"><span class="number">8048</span>d2e:   <span class="number">89</span> <span class="number">42</span> <span class="number">08</span>                mov    %eax,<span class="number">0x8</span>(%edx)</div><div class="line"><span class="number">8048</span>d31:   <span class="number">8b</span> <span class="number">55</span> c8                mov    <span class="number">-0x38</span>(%ebp),%edx</div><div class="line"><span class="number">8048</span>d34:   <span class="number">89</span> <span class="number">50</span> <span class="number">08</span>                mov    %edx,<span class="number">0x8</span>(%eax)</div><div class="line"><span class="number">8048</span>d37:   <span class="number">8b</span> <span class="number">45</span> cc                mov    <span class="number">-0x34</span>(%ebp),%eax</div><div class="line"><span class="number">8048</span>d3a:   <span class="number">89</span> <span class="number">42</span> <span class="number">08</span>                mov    %eax,<span class="number">0x8</span>(%edx)</div><div class="line"><span class="number">8048</span>d3d:   c7 <span class="number">40</span> <span class="number">08</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   $<span class="number">0x0</span>,<span class="number">0x8</span>(%eax)</div><div class="line"><span class="number">8048</span>d44:   be <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%esi</div></pre></td></tr></table></figure><p>因为之前已经按照输入序列查找到具体的节点并反向入栈，此时我们就可以从栈顶取出第一个元素的地址以及第二个元素的地址，把第二个元素的地址赋值给第一个元素的地址+8（next指针），依次类推，就可以把整个链表构建起来，在结尾处，尾指针设置为0。</p><p>4.根据构建的链表开始验证结果</p>  <figure class="highlight as"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="number">8048</span>d49:   <span class="number">8</span>b <span class="number">43</span> <span class="number">08</span>                mov    <span class="number">0x8</span>(%ebx),%eax</div><div class="line"><span class="number">8048</span>d4c:   <span class="number">8</span>b <span class="number">13</span>                   mov    (%ebx),%edx</div><div class="line"><span class="number">8048</span>d4e:   <span class="number">3</span>b <span class="number">10</span>                   cmp    (%eax),%edx</div><div class="line"><span class="number">8048</span>d50:   <span class="number">7</span>d <span class="number">05</span>                   jge    <span class="number">8048</span>d57 &lt;phase_6+<span class="number">0xce</span>&gt;</div><div class="line"><span class="number">8048</span>d52:   e8 <span class="number">7</span>a <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">80490</span>d1 &lt;explode_bomb&gt;</div><div class="line"><span class="number">8048</span>d57:   <span class="number">8</span>b <span class="number">5</span>b <span class="number">08</span>                mov    <span class="number">0x8</span>(%ebx),%ebx</div><div class="line"><span class="number">8048</span>d5a:   <span class="number">83</span> c6 <span class="number">01</span>                add    $<span class="number">0x1</span>,%esi</div><div class="line"><span class="number">8048</span>d5d:   <span class="number">83</span> fe <span class="number">05</span>                cmp    $<span class="number">0x5</span>,%esi</div><div class="line"><span class="number">8048</span>d60:   <span class="number">75</span> e7                   jne    <span class="number">8048</span>d49 &lt;phase_6+<span class="number">0xc0</span>&gt;</div></pre></td></tr></table></figure><p>这段代码实际上就是比较链表是否是降序排列的，首先<code>mov    0x8(%ebx),%eax</code>取第二个值的地址放入<code>eax</code>中，再<code>mov    (%ebx),%edx</code>取第一个值放入<code>edx</code>中，最后<code>cmp    (%eax),%edx</code>比较大小。如果满足前一个大于后一个，则<code>mov    0x8(%ebx),%ebx</code>把后一个的指针赋值给前一个指针变量。也就是当前指针变为下一个。类似于下列C代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">node a = firstNode;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</div><div class="line">    node b = a-&gt;next;</div><div class="line">    <span class="keyword">if</span> (a-&gt;x &gt;= b-&gt;x)</div><div class="line">        a = b;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        explode_bomb();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>5.最后我们可以通过<code>x /x 0x</code>指令从gdb中查看已经存在的链表，并根据它的大小进行降序排列，最后即可得出所需的序列：<br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-11-07-122732.jpg" alt=""><br>所以最后的序列为：5 6 1 4 3 2。<br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-11-07-122749.jpg" alt=""><br>在gdb中可以看到，这个结果是正确的。</p><hr><p>综上，把六个炸弹都拆除了。</p><p>所以全部的答案总结如下：<br>1.We have to stand with our North Korean allies.<br>2.0 1 1 2 3 5<br>3.0 147 (1 -641 | 2 217 | 3 -534 | 4 0 | 5 -534)<br>4.8 1 (9 1 | 11 1)<br>5.5 115<br>6.5 6 1 4 3 2</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;查看bomb.c文件里的main函数，可以发现它在分析完命令行的参数完成之后调用了initialize_bomb()函数，之后输出了两个语句。紧接着就是read_line()函数，显然这个是读取我们所需要的字符，接着就是phase_1()与phase_defused()函数了。再往下看，可以看出分别调用了phase_1 ~ phase_6六个函数，这应该就是每个拆除炸弹的阶段函数了。&lt;br&gt;通过&lt;code&gt;objdump -d bomb &amp;gt; bomb.s&lt;/code&gt;把反汇编代码输出到bomb.s文件上，方便查找。&lt;br&gt;接下来就是逐个阶段的分析了&lt;/p&gt;
&lt;h6 id=&quot;phase1&quot;&gt;&lt;a href=&quot;#phase1&quot; class=&quot;headerlink&quot; title=&quot;phase1&quot;&gt;&lt;/a&gt;phase1&lt;/h6&gt;&lt;p&gt;首先找到phase_1函数的汇编代码如下:&lt;/p&gt;
&lt;figure class=&quot;highlight as&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;08048&lt;/span&gt;f61 &amp;lt;phase_1&amp;gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;8048&lt;/span&gt;f61:   &lt;span class=&quot;number&quot;&gt;55&lt;/span&gt;                      push   %ebp&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;8048&lt;/span&gt;f62:   &lt;span class=&quot;number&quot;&gt;89&lt;/span&gt; e5                   mov    %esp,%ebp&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;8048&lt;/span&gt;f64:   &lt;span class=&quot;number&quot;&gt;83&lt;/span&gt; ec &lt;span class=&quot;number&quot;&gt;18&lt;/span&gt;                sub    $&lt;span class=&quot;number&quot;&gt;0x18&lt;/span&gt;,%esp&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;8048&lt;/span&gt;f67:   c7 &lt;span class=&quot;number&quot;&gt;44&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;24&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;04&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;c a1 &lt;span class=&quot;number&quot;&gt;04&lt;/span&gt;    movl   $&lt;span class=&quot;number&quot;&gt;0x804a15c&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0x4&lt;/span&gt;(%esp)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;8048&lt;/span&gt;f6e:   &lt;span class=&quot;number&quot;&gt;08&lt;/span&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;8048&lt;/span&gt;f6f:   &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;b &lt;span class=&quot;number&quot;&gt;45&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;08&lt;/span&gt;                mov    &lt;span class=&quot;number&quot;&gt;0x8&lt;/span&gt;(%ebp),%eax&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;8048&lt;/span&gt;f72:   &lt;span class=&quot;number&quot;&gt;89&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;04&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;                mov    %eax,(%esp)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;8048&lt;/span&gt;f75:   e8 &lt;span class=&quot;number&quot;&gt;31&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;00&lt;/span&gt;          call   &lt;span class=&quot;number&quot;&gt;8048&lt;/span&gt;fab &amp;lt;strings_not_equal&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;8048&lt;/span&gt;f7a:   &lt;span class=&quot;number&quot;&gt;85&lt;/span&gt; c0                   test   %eax,%eax&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;8048&lt;/span&gt;f7c:   &lt;span class=&quot;number&quot;&gt;74&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;05&lt;/span&gt;                   je     &lt;span class=&quot;number&quot;&gt;8048&lt;/span&gt;f83 &amp;lt;phase_1+&lt;span class=&quot;number&quot;&gt;0x22&lt;/span&gt;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;8048&lt;/span&gt;f7e:   e8 &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;e &lt;span class=&quot;number&quot;&gt;01&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;00&lt;/span&gt;          call   &lt;span class=&quot;number&quot;&gt;80490&lt;/span&gt;d1 &amp;lt;explode_bomb&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;8048&lt;/span&gt;f83:   c9                      leave  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;8048&lt;/span&gt;f84:   c3                      ret    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;8048&lt;/span&gt;f85:   &lt;span class=&quot;number&quot;&gt;90&lt;/span&gt;                      nop&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;8048&lt;/span&gt;f86:   &lt;span class=&quot;number&quot;&gt;90&lt;/span&gt;                      nop&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;8048&lt;/span&gt;f87:   &lt;span class=&quot;number&quot;&gt;90&lt;/span&gt;                      nop&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;8048&lt;/span&gt;f88:   &lt;span class=&quot;number&quot;&gt;90&lt;/span&gt;                      nop&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;8048&lt;/span&gt;f89:   &lt;span class=&quot;number&quot;&gt;90&lt;/span&gt;                      nop&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;8048&lt;/span&gt;f8a:   &lt;span class=&quot;number&quot;&gt;90&lt;/span&gt;                      nop&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;8048&lt;/span&gt;f8b:   &lt;span class=&quot;number&quot;&gt;90&lt;/span&gt;                      nop&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;8048&lt;/span&gt;f8c:   &lt;span class=&quot;number&quot;&gt;90&lt;/span&gt;                      nop&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;8048&lt;/span&gt;f8d:   &lt;span class=&quot;number&quot;&gt;90&lt;/span&gt;                      nop&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;8048&lt;/span&gt;f8e:   &lt;span class=&quot;number&quot;&gt;90&lt;/span&gt;                      nop&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;8048&lt;/span&gt;f8f:   &lt;span class=&quot;number&quot;&gt;90&lt;/span&gt;                      nop&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="http://jihong.xyz/categories/computer-principle/"/>
    
    
      <category term="编程素养" scheme="http://jihong.xyz/tags/Programming-literacy/"/>
    
  </entry>
  
  <entry>
    <title>Float 与 Double精度丢失的问题</title>
    <link href="http://jihong.xyz/computer-principle/float%E4%B8%8Edouble%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://jihong.xyz/computer-principle/float与double精度丢失的问题/</id>
    <published>2016-10-20T12:44:05.000Z</published>
    <updated>2018-03-04T07:30:59.351Z</updated>
    
    <content type="html"><![CDATA[<p><strong>将同一实数分别赋值给单精度和双精度类型变量，然后打印输出</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">float</span> a;</div><div class="line">    <span class="keyword">double</span> b;</div><div class="line">    a = <span class="number">123456.789e4</span>;</div><div class="line">    b = <span class="number">123456.789e4</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%f\n %f\n"</span>,a,b);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">输出结果：</div><div class="line"><span class="number">1234567936.000000</span></div><div class="line"><span class="number">1234567890.000000</span></div></pre></td></tr></table></figure><p>为什么一个整数分别赋值给double和float,在输出的时候float型却不一样且偏大了呢？</p><p>其实导致这样的结果主要是因为float的精度的问题，float在内存中主要分为三部分，第一部分是符号位，第二部分是指数位，第三部分是尾数部分。尾数部分的长度为23位，又因为可以隐式地认为第一位是1（因为我们总是可以通过调整指数大小把小数点移动到最高位为1上的右边），所以实际上我们float能够识别24位二进制数，也就是2^24 - 1 = 16,777,215,所以float的精度是不高于八位的。</p><p>同理因为double是64位的，所以识别的精度要有2^52 - 1 = 450,359,962,770,496，也就是不高于16位。但是题目中的1234567890也就是只有十位而已，所以double可以确保它的精度不被改变而float却不行。<br><a id="more"></a><br>在 IEEE 标准中，浮点数是将特定长度的连续字节的所有二进制位分割为特定宽度的符号域，指数域和尾数域三个域，其中保存的值分别用于表示给定二进制浮点数中的符号，指数和尾数。这样，通过尾数和可以调节的指数（所以称为”浮点”）就可以表达给定的数值了。<br>具体的格式参见下面的表格：</p><table><thead><tr><th style="text-align:right"></th><th style="text-align:right">长度</th><th style="text-align:right">符号</th><th style="text-align:right">指数</th><th style="text-align:right">尾数</th><th style="text-align:right">有效位数</th><th style="text-align:right">指数偏移</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td style="text-align:right">单精度</td><td style="text-align:right">32位</td><td style="text-align:right">1</td><td style="text-align:right">8</td><td style="text-align:right">23</td><td style="text-align:right">24</td><td style="text-align:right">2^8-1 -1=127</td><td style="text-align:right">有一个隐含位</td></tr><tr><td style="text-align:right">双精度</td><td style="text-align:right">64位</td><td style="text-align:right">1</td><td style="text-align:right">11</td><td style="text-align:right">52</td><td style="text-align:right">53</td><td style="text-align:right">2^11-1 - 1=1023</td><td style="text-align:right">有一个隐含位</td></tr><tr><td style="text-align:right">扩展双精度</td><td style="text-align:right">80位</td><td style="text-align:right">1</td><td style="text-align:right">15</td><td style="text-align:right">64</td><td style="text-align:right">64</td><td style="text-align:right">2^15-1 - 1=16383</td><td style="text-align:right">没有隐含位</td></tr></tbody></table><p>再说说为什么会偏大而不是偏小的问题，用IEEE 754规则把浮点数转换成三段式可以得到1234567890转换后的结果为：<code>0---1001 1101---001001-10010110-00000010-11010010</code>。但是存储到内存中因为只有尾数部分只有23位，那么存储到内存中就变为了：<code>0---1001 1101---001001-10010110-00000011</code>.注意到后面舍弃了八位且向前进了一位，说说为什么进位，C语言中采取的默认进位方式是<strong>四舍六入五成双</strong>。先说说这个四舍六入吧：</p><ul><li>四舍也就是不够前面一位的一半，也就是1/2,就把这部分舍去；六入就是超过1/2则向前进一位。五成双就是被修约的数字等于5时，要看5前面的数字，若是奇数则进位，若是偶数则将5舍掉。从统计学的角度，“四舍六入五成双”比“四舍五入”要科学，在大量运算时，它使舍入后的结果误差的均值趋于零，而不是像四舍五入那样逢五就入，导致结果偏向大数，使得误差产生积累进而产生系统误差，“四舍六入五成双”使测量结果受到舍入误差的影响降到最低。</li></ul><p>现在再看看之前的11010010，显然大于前一位的1/2,所以要向前进1.这也是为什么结果会偏大的原因。把其从内存中还原出来就是：<code>1.001001-10010110-00000011-00000000 x 2^30 = 12345678936.0000</code></p><blockquote><p>通常情况下我们采取的舍入规则是在原来的值是舍入值的中间值时,采取向偶数舍入,在二进制中,偶数我们认为是末尾为0的数.而倘若不是这种情况的话,则一般会有选择性的使用向上和向下舍入,但总会向最接近的值舍入.其实这正是IEEE采取的默认的舍入方式,因为这种舍入方式总是企图向最近的值舍入.</p></blockquote><blockquote><p>比如对于10.10011这个值来讲,当舍入到个位数时,会采取向上舍入,因此此时的值为11.当舍入到小数点后1位时,会采取向下舍入,因此此时的值为10.1.当舍入到这个小数点后4位时,由于此时的10.10011舍入值的中间值,因此采取向偶数舍入,此时舍入后的值为10.1010.</p></blockquote><p>最后还想谈谈关于为什么三段式存储方式中指数部分要用Bias偏置位表示：<br>如果用八位中的最高位来表示符号位的话，如果用判断<code>010XXXXX &gt; 0001XXXX</code>成立的电路去判断<code>010XXXXX &lt; 1000XXXX</code>显然也是成立的，但是事实上是<code>010XXXXX &gt; 1000XXXX</code>。所以就需要多设计一套电路去判断符号位，显然这是不划算的。所以可以采取偏置位把所有数都偏移到正数上，就可以使用一套电路来判断。至于为什么是偏移2^k-1 - 1位，我的理解是这样刚好把最小指数偏移到0位上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;将同一实数分别赋值给单精度和双精度类型变量，然后打印输出&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; a;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; b;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    a = &lt;span class=&quot;number&quot;&gt;123456.789e4&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    b = &lt;span class=&quot;number&quot;&gt;123456.789e4&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%f\n %f\n&quot;&lt;/span&gt;,a,b);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;输出结果：&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1234567936.000000&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1234567890.000000&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为什么一个整数分别赋值给double和float,在输出的时候float型却不一样且偏大了呢？&lt;/p&gt;
&lt;p&gt;其实导致这样的结果主要是因为float的精度的问题，float在内存中主要分为三部分，第一部分是符号位，第二部分是指数位，第三部分是尾数部分。尾数部分的长度为23位，又因为可以隐式地认为第一位是1（因为我们总是可以通过调整指数大小把小数点移动到最高位为1上的右边），所以实际上我们float能够识别24位二进制数，也就是2^24 - 1 = 16,777,215,所以float的精度是不高于八位的。&lt;/p&gt;
&lt;p&gt;同理因为double是64位的，所以识别的精度要有2^52 - 1 = 450,359,962,770,496，也就是不高于16位。但是题目中的1234567890也就是只有十位而已，所以double可以确保它的精度不被改变而float却不行。&lt;br&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="http://jihong.xyz/categories/computer-principle/"/>
    
    
      <category term="编程素养" scheme="http://jihong.xyz/tags/Programming-literacy/"/>
    
  </entry>
  
  <entry>
    <title>老罗新机发布会的一些感受</title>
    <link href="http://jihong.xyz/programer/%E8%80%81%E7%BD%97%E6%96%B0%E6%9C%BA%E5%8F%91%E5%B8%83%E4%BC%9A%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E5%8F%97/"/>
    <id>http://jihong.xyz/programer/老罗新机发布会的一些感受/</id>
    <published>2016-10-19T06:53:32.000Z</published>
    <updated>2016-10-19T07:14:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一些个人对老罗的看法"><a href="#一些个人对老罗的看法" class="headerlink" title="一些个人对老罗的看法"></a>一些个人对老罗的看法</h3><p>知道老罗这个人是从2012年的一场发布会开始的，那时候老罗扬言着说要做一个与现今Android机都不一样的东西出来，带着质疑的眼光，老罗风风火火地就开始上路了。老罗其实早在做手机就已经成名了，他的出名绝不是他不知天高地厚的要跨行做手机，而是他的口才。当然，现在还多了一样东西，就是他的执着、他的理想主义。从认识老罗到现在已经4年多了，每年他的每一场发布会我都会看完，这也是为数不多的我能坚持了几年的事情之一。我和老罗一样是个果粉，从他身上也可以看到Jobs的些许身影。当然从Apple最近七年来看，发布会远没有老罗的精彩，在用户体验上的努力也远没有老罗做得好。特别是老罗每年都把发布会的门票捐赠给开源世界，真的让我很佩服！特别是发布会演示了那么多新特性之后宣布将会毫无保留的开源出来，让我对他又多了一层敬畏。我一直都很倡导开源精神，但是其实现在开源并不是很成熟，许多商业公司并不愿意公布自己的源代码与人类分享自己的果实，但是老罗做到了！了不起！</p><h3 id="嘲笑理想主义者的时代是悲哀的"><a href="#嘲笑理想主义者的时代是悲哀的" class="headerlink" title="嘲笑理想主义者的时代是悲哀的"></a>嘲笑理想主义者的时代是悲哀的</h3><a id="more"></a><p>对于今晚的发布会的几百万观众，很显然有2/3的人是来看他的笑话的，看看这孙子还能吹出什么花来。看着弹幕上全是喷子，不得不感叹现在互联网的环境是如此的混乱。直到发布会结束之后论坛上、V站上，也还到处都是各种喷子，抄袭啊、雇水军在刷评论啊，还有各种粗鄙不堪的言语，让人不忍直视。网上一看全是骂抄袭Apple的原型Home键的，我不知道一个原型的home键为什么都是这些喷子的喷点，现在Android机上但凡带有指纹解锁的全是前置的椭圆形或者后置的圆形、方形，为什么没人喷抄袭？而且单从正常的审美与实用性上，我并不觉得原形的Home键有什么不妥。至少他是Android机上第一个敢模仿Apple的圆形Home键的厂商，光凭这一点就已经足够获取肯定（并不是赞同抄袭，只是从用户体验上来说，这是最好的选择）。而且OPPO、Vivo、乐视、魅族这几家厂商我不觉得他们的新款机型我能分辨出来谁是谁…毫无例外的窄边框、前置椭圆home键、金属中框。不喜欢尽可以不买，甚至可以吐槽，但在毫无证据的情况下认为喜欢锤子的人都是水军，这种心态就真的太lowB了。再说一下个人对于现在网络喷子的看法，这些人大多碌碌无为，没有真正的去坚持做过一件事情，凭借自己心中的YY就觉得做某件事很容易。这其中的辛酸大概也只有老罗自己能知道了把。</p><h3 id="理想主义者的无奈"><a href="#理想主义者的无奈" class="headerlink" title="理想主义者的无奈"></a>理想主义者的无奈</h3><p>从四年前老罗的高调进军手机行业到现在被磨得没有棱角，这不得不说是一个悲哀。发布会一开始就显得有点悲壮，如果老罗再拿不出能够让大部分消费者为之买单的产品，这或许真的是锤子的最后一场发布会了。但是有些锤黑的无脑喷真的是让人难以理解，从Smartisan T1开始就有无数的喷子在开喷，就在今年锤子可以已经”被收购“了六次…好在经过四年的沉淀，不论是做事还是说话，老罗都显得比以前沉稳得多得多，也许他真的不幸成为了他最初最讨厌的人，但有一点是没有变的，那就是他身上的执着。现实世界很无奈，太多的事情都不尽如人意，无数的喷子因为自己做不到所以见不得别人好。从优酷大战王自如到封博，再到如今的各种克制言行，已经尝到了无数辛酸与吃尽了苦头。</p><h3 id="锤子新手机的特色"><a href="#锤子新手机的特色" class="headerlink" title="锤子新手机的特色"></a>锤子新手机的特色</h3><p>首先还是要说说配置吧，在现在Android机的市场，虽然配置已经越来越显得不太重要，但是还是有很多人看着配置买手机…骁龙821+6G DDR4内存 + 64G存储空间已经足够称得上机皇。除此之外值得一提的还是它的工业设计，不得不说这次的外形我并不是很喜欢，但是还是有可圈可点之处的。最大的亮点还是在系统上，讯飞的语音识别真的厉害到不行，当时在看发布会直播的时候就被它的语音识别准确度惊艳到了，很佩服在语音识别背后里默默付出的科研人员。最有用的还是Big Bang和One Step功能，真的是每一项都戳到我的痛点，相比大多Android厂商每次都是在系统UI上改了又改，我更乐意看到类似于锤子科技这些有实质性体验提升的功能。</p><h3 id="对老罗的一些期待"><a href="#对老罗的一些期待" class="headerlink" title="对老罗的一些期待"></a>对老罗的一些期待</h3><p>在理想主义上与工匠精神上，老罗早已成为了无冕之王。他对每一个细节的专注与苛求都值得我们学习，在情怀的道路上，我觉得没有坚持过的人是没有办法对他说三道四的。很庆幸我与老罗的很多观点甚至是锤子科技的对待事物的追求是一致的，虽然也有部分不认同，但这并不妨碍它成为我心目中最好的Android手机公司（目前主要是手机公司）。说实话看到他公布新机型M1/M1L的价格的时候我有一种想哭的冲动，这款手机的价值远超它的价格，但是被现实所累的老罗也是穷途末路了，如果这款手机再不能获得成功，这是这个时代的悲哀！不知道为什么现在都在追求什么性价比，一分钱一分货，只有挣钱了企业才能继续活下去。换句话说，我并不认同高性价比这种东西，如果你需要极致的体验必然要付出极致的价钱。<strong>当然三星这种品牌溢价的公司除外。</strong>希望老罗能在商业上也获得成功！</p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>这次的发布会无疑是很成功的，老罗用自己的产品回给了那些嘲笑者一个响亮的耳光。这让我突然想起一段话：<br><strong>在一个国家的墓园里,有许多国家首脑的墓志铭.某个角落里的一段墓志铭是这样写的：<br>我在年轻的时候有一个伟大的愿望,想改变世界,但是随着我的年龄的增长,我发现我不能,所以我想改变整个国家；但是等到我的年龄再大的时候,我发现我没有这个能力改变自己的国家,那我就想我的愿望就是改变我的家庭；等到我年老的时候,我发现我也没有能力改变我的家庭,我就想我要改变我自己；等到我行将入土的时候,我才发现我依然没有改变我自己.这时候我就想,如果我一开始的愿望就是改变我自己,那么我自己改变了,同样就有可能改变我的家庭,就有可能改变我的国家,甚至有可能改变整个世界.</strong></p><p><strong>对于网络的喷子，我会以我所学，举毕生之力，与喷子们大战到底，不死不休。</strong></p><p><strong>如果一开始没成功，那就拿个更大的锤子！！！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一些个人对老罗的看法&quot;&gt;&lt;a href=&quot;#一些个人对老罗的看法&quot; class=&quot;headerlink&quot; title=&quot;一些个人对老罗的看法&quot;&gt;&lt;/a&gt;一些个人对老罗的看法&lt;/h3&gt;&lt;p&gt;知道老罗这个人是从2012年的一场发布会开始的，那时候老罗扬言着说要做一个与现今Android机都不一样的东西出来，带着质疑的眼光，老罗风风火火地就开始上路了。老罗其实早在做手机就已经成名了，他的出名绝不是他不知天高地厚的要跨行做手机，而是他的口才。当然，现在还多了一样东西，就是他的执着、他的理想主义。从认识老罗到现在已经4年多了，每年他的每一场发布会我都会看完，这也是为数不多的我能坚持了几年的事情之一。我和老罗一样是个果粉，从他身上也可以看到Jobs的些许身影。当然从Apple最近七年来看，发布会远没有老罗的精彩，在用户体验上的努力也远没有老罗做得好。特别是老罗每年都把发布会的门票捐赠给开源世界，真的让我很佩服！特别是发布会演示了那么多新特性之后宣布将会毫无保留的开源出来，让我对他又多了一层敬畏。我一直都很倡导开源精神，但是其实现在开源并不是很成熟，许多商业公司并不愿意公布自己的源代码与人类分享自己的果实，但是老罗做到了！了不起！&lt;/p&gt;
&lt;h3 id=&quot;嘲笑理想主义者的时代是悲哀的&quot;&gt;&lt;a href=&quot;#嘲笑理想主义者的时代是悲哀的&quot; class=&quot;headerlink&quot; title=&quot;嘲笑理想主义者的时代是悲哀的&quot;&gt;&lt;/a&gt;嘲笑理想主义者的时代是悲哀的&lt;/h3&gt;
    
    </summary>
    
      <category term="程序员的那些事" scheme="http://jihong.xyz/categories/programer/"/>
    
    
      <category term="碎片" scheme="http://jihong.xyz/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>计组作业 - 第二章</title>
    <link href="http://jihong.xyz/computer-principle/%E8%AE%A1%E7%BB%84%E4%BD%9C%E4%B8%9A-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <id>http://jihong.xyz/computer-principle/计组作业-第二章/</id>
    <published>2016-10-13T12:06:21.000Z</published>
    <updated>2018-03-04T07:43:51.613Z</updated>
    
    <content type="html"><![CDATA[<h6 id="2-58"><a href="#2-58" class="headerlink" title="2.58"></a>2.58</h6><p>编写过程is_little_endian，当在小端机器上编译和运行时返回1，在大端机器上编译运行时返回0.这个过程应该可以运行在任何机器上，无论机器的字长是多少。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_little_endian</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> *(<span class="keyword">char</span>*)&amp;x;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>假设是32位的小端机器，那么x变量存储方式将为<code>0000 0001 0000 0000 0000 0000 0000 0000</code>，反之则为<code>0000 0000 0000 0000 0000 0000 0000 0001</code>。通过取变量<code>x</code>的地址然后强制转换<code>char*</code>，再通过指针取出这个强制转换后的地址上的值（无论是大端还是小端，都是取内存低8位的地址，所以大端模式取到的是<code>0000 0000</code>，而小端模式取到的值是<code>0000 0001</code>）。<strong>如果第二句语句改为<code>return (char)x</code>，则无论是大端还是小端机器，最终的结果都为1。因为强制转换是在寄存器进行的而不是在内存进行的，那么<code>(char)x</code>就是保留其低八位的值，也就是<code>0000 0001</code></strong></p><hr><a id="more"></a><h6 id="2-71"><a href="#2-71" class="headerlink" title="2.71"></a>2.71</h6><p>你刚刚开始在一家公司工作，他们要实现一组过程来操作一个数据结构，要将４个有符号字节封装成一个32位unsigned。在这个unsigned中的字节是从0（最底有效字节）编号到3（最高有效字节）。分配给你的任务是：为使用二进制补码运算和算术右移的机器编写一个具有如下原形的函数：<br>/<em>Declaration of data type where 4 bytes are packed in to an unsigned </em>/<br>typedef unsigned packed_t;</p><p>/<em> Extract byte from word. Return as signed integer </em>/<br>int xbyte(packed_t world, int bytenum);</p><p>也就是说，函数会抽取指定的字节，再把它符号扩展为一个32位int．<br>你的前任（因为水平不高而被解雇了）编写了下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*Failed attempt at xbyte */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">xbyte</span><span class="params">(<span class="keyword">unsigned</span> word, <span class="keyword">int</span> bytenum)</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> (word &gt;&gt;(bytenum &lt;&lt; <span class="number">3</span>)) &amp; <span class="number">0xFF</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>问题<br>１．这段代码错在哪里？<br>２．给出函数的正确实现，只能使用左右移位和一个减法．</strong></p><p><strong>答：</strong></p><ol><li>可以看出，如果要取出的这个字节的值为负数的时候，代码的处理是错误的，即会处理为正数。</li><li>代码的正确实现如下：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">xbyte</span><span class="params">(<span class="keyword">unsigned</span> word, <span class="keyword">int</span> bytenum)</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> (word &lt;&lt;((<span class="number">3</span>-bytenum) &lt;&lt; <span class="number">3</span>)) &gt;&gt; <span class="number">24</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>代码解释：</strong><br>由于算术右移是按照符号位来填充扩展位的，那么我们可以采取先左移(3-n)*8位来把要取的字节左边的无效位左移覆盖掉，再通过右移24位来把当前字节置于最低字节位。而此时，如果此数为正，那么左边将会全是0，不会影响到结果；如果此数为负，低八位的前24位必将全部是1（算术右移），因为负数是用补码表示的，取反后除了符号位其余23位将会变为0，而低八位正常取反加1，同样也不影响结果。</p><hr><h6 id="2-84"><a href="#2-84" class="headerlink" title="2.84"></a>2.84</h6><p>给定一个浮点格式，有 k 位指数和 n 位小数，对于下列数，写出阶码 E、尾数 M、<br>小数 f 和值 V 的公式。另外，请描述其位表示。</p><p>A. 数 5.0。<br>B. 能够被准确描述的最大奇整数。<br>C. 最小的正规格化数的倒数。</p><p><strong>答：</strong></p><pre><code>A.    5.0转化为二进制得0000 0101.0，等价于1.01*2^2     所以：    E=2    M=1.25    f=0.25    V=(-1)^s * M * 2^E = (-1)^0 * 1.25 * 2^2    位表示: [0]1[10··0]k[010··0]nB. 首先明确奇数的最低位一定为1.   其次因为是最大奇整数，所以s位也是为0的.   考虑到可能会出现两种情况，一种是E大于等于小数位n，另一种是E小于小数位n，下面分两种情况讨论   1.E&gt;=n:   显然E可表示的阶数已经超过所需要的了，所以取n就好   E=n   f=0.[1...1]n   M=1.[1...1]n   V=(-1)^0 * M * 2^E=(-1)^0 * 1.[1..1]n * 2^n   位表示: [0]1[E+Bias]k[1...1]n = [0]1[n + (2^(k-1) - 1)]k[1...1]n   2.E&lt;n:   若E&lt;n，那么小数部分的前E位只需要为1就可以了，后面的n-E部分是0 or 1都不影响最终结果   E=2^(k-1) - 1   f=0.[1...1]E[****]n-E   M=1.[1...1]E[****]n-E   V=(-1)^0 * M * 2^E=(-1)^0 * 1.[1...1]E[****]n-E * 2^(2^(k-1) - 1)   位表示: [0]1[1..10]k[1...1]E[****]n-E   需要说明的是E的计算过程：E=(max)e-Bias=(2^k -2) - (2^(k-1) - 1) = 2^(k-1) - 1，其   中e的最大值取2^k - 2是因为阶码全为1时做特殊用途(表示无穷大)，所以e最大的规格化表示为   [1..10]k。C. 最小规格化整数可以根据定义得出：[0]1[0...01]k[00..0]n,它的值V=(-1)^0 * 1.0   * 2^(2-2^(k-1))，它的倒数的值为V=(-1)^0 * 1.0 * 2^-(2-2^(k-1))=2^(2^(k-1) - 2)   所以：   E=2^(k-1) - 2   M=1.0   f=0.0   e=E+Bias=(2^(k-1) - 2) + (2^(k-1) - 1)=2^k -3   位表示: [0]1[11...01]k[0..0]n</code></pre><hr><h6 id="2-88"><a href="#2-88" class="headerlink" title="2.88"></a>2.88</h6><p>我们在一个 int 类型为 32 位补码表示的机器上运行程序。float 类型的值使用 32<br>位 IEEE 格式，而 double 类型的值使用 64 位 IEEE 格式。</p><p>我们产生随机数 x、y 和 z，并且把它们转换成 double 类型的值：</p><p>/<em> Create some arbitrary values </em>/<br>int x = random();<br>int y = random();<br>int z = random();</p><p>/<em> Convert to double </em>/<br>double dx = (double)x;<br>double dy = (double)y;<br>double dz = (double)z;</p><p>对于下列的每个 C 表达式，你要指出表达式是否总是为 1。如果它总是为 1，描述其<br>中的数学原理。否则，列举出使它为 0 的参数的例子。请注意，不能使用 IA32 机器<br>运行 GCC 来测试你的答案，因为对于 float 和 double，它使用的都是 80 位的扩展<br>精度表示。</p><p>A. (double)(float)x == dx<br>B. dx + dy == (double)(x+y)<br>C. dx + dy + dz == dz + dy + dx<br>D. dx <em> dy </em> dz == dz <em> dy </em> dx<br>E. dx / dx == dy / dy</p><p><strong>答：</strong></p><pre><code>A.否，可以想到int可以存储31位有效数字，而float算上隐含的个位数也仅能表示24位的宽度。当  x=2^25 - 1时，左边的值为33554432，而右边因为double可以容纳53位（含隐含位）所以可以无误差  转换一个32位的int整数，float却不行。同理可验证，只要大于24位之后其低位超出的部分为1时都会  产生这样的误差，如果为0则截断无影响。B.是，double的精度容纳范围仍然包含2*Int(max)，所以左右式子总是相等的。C.是，浮点数是不支持结合律的，假设dx=0.001，dy=1e53，dz=-1e53。如果根据左边的运算顺序，结  果为0，而右边为0.001。这是因为在左边运算时，因为double的尾数部分只有52位，而显然要先算  0.001+1e53的话则0.001部分因为超过double所能容纳位数被舍掉，所以最终结果为0。而右边因为先  运算1e53+(-1e53)所以相当于0.001+0，则可以正确表现出结果来。但是题目是通过用int转换为  double值的，所以double可以容纳32位所有int的值，不会发生舍弃的情况，所以不论是按何种顺序运  算结果都是一样的。D.是，double的取值范围为-2^-1024 ~ 2^1024 = -1.7e(-308)～1.7e308。所以当dx=1e155，  dy=1e155，dz=1e-155时，左边的式子结果为Inf，而右边为1e155。但int并没有那么大的数值，32  位int只能表示-2147483648~2147483647这个范围，所以double在这个式子中完全可以容纳3个int  相乘的结果而不产生误差，所以整个式子是为真值的。E.否，若dy或dx中任意一个且仅有一个为0时，那么左右边的值是不一样的，为0的那一部为Not a  Number，而另一部分则为1，所以整个式子不相等。</code></pre><hr><h6 id="2-92"><a href="#2-92" class="headerlink" title="2.92"></a>2.92</h6><p>遵循位级浮点编码规则，实现具有如下原型的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Compute -f.  If f is NaN, then return f. */</span></div><div class="line"><span class="function">float_bits <span class="title">float_negate</span><span class="params">(float_bits f)</span></span>;</div></pre></td></tr></table></figure><p>对于浮点数 f，这个函数计算-f。如果 f 是 NaN，你的函数应该简单地返回 f。测试你的函数，对参数 f 可以取的所有 2^32 个值求值，将结果与你使用机器的浮点运算得到的结果相比较。</p><p><strong>答：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">type <span class="keyword">unsigned</span> float_bits;</div><div class="line"><span class="function">float_bits <span class="title">float_negate</span><span class="params">(float_bits f)</span></span>&#123;</div><div class="line">    <span class="keyword">unsigned</span> s = f &gt;&gt; <span class="number">31</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="built_in">exp</span> = (f &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xff</span>;</div><div class="line">    <span class="keyword">unsigned</span> frac = f &amp; <span class="number">0x7fffff</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(<span class="built_in">exp</span> == <span class="number">0xff</span> &amp;&amp; frac != <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> f;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (~s &lt;&lt; <span class="number">31</span>) | (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>) | frac;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>代码解释：</strong><br>    首先明确，float_bits肯定是用unsigned来保存的。其次我们要把浮点数f的符号位、阶码、尾数三个部分都取出来存到不同的变量中以备后续使用。符号位我们可以通过右移31位得到，因为已经定义float_bits为unsigned，所以右移为逻辑右移，不需要考虑符号位填充右移位的问题。阶码通过右移23位并与0xff相与得到，最后是小数部分通过与低23位1也就是0x7fffff相与取低23位的值得到。<br>    根据题意，若f为NaN则返回f，否则返回-f。根据定义，f为NaN的定义为：阶码全为1且尾数部分不为0。所以有<code>if(exp == 0xff &amp;&amp; frac != 0)</code>。<br>    最后看看返回-f的情况，通过把符号位取反后左移31位还原符号位，接着把阶码左移23位并与之前还原过的符号位相或，最后与小数部分相或，这样就得到了一个-f。</p>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;2-58&quot;&gt;&lt;a href=&quot;#2-58&quot; class=&quot;headerlink&quot; title=&quot;2.58&quot;&gt;&lt;/a&gt;2.58&lt;/h6&gt;&lt;p&gt;编写过程is_little_endian，当在小端机器上编译和运行时返回1，在大端机器上编译运行时返回0.这个过程应该可以运行在任何机器上，无论机器的字长是多少。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;is_little_endian&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; *(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;*)&amp;amp;x;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;假设是32位的小端机器，那么x变量存储方式将为&lt;code&gt;0000 0001 0000 0000 0000 0000 0000 0000&lt;/code&gt;，反之则为&lt;code&gt;0000 0000 0000 0000 0000 0000 0000 0001&lt;/code&gt;。通过取变量&lt;code&gt;x&lt;/code&gt;的地址然后强制转换&lt;code&gt;char*&lt;/code&gt;，再通过指针取出这个强制转换后的地址上的值（无论是大端还是小端，都是取内存低8位的地址，所以大端模式取到的是&lt;code&gt;0000 0000&lt;/code&gt;，而小端模式取到的值是&lt;code&gt;0000 0001&lt;/code&gt;）。&lt;strong&gt;如果第二句语句改为&lt;code&gt;return (char)x&lt;/code&gt;，则无论是大端还是小端机器，最终的结果都为1。因为强制转换是在寄存器进行的而不是在内存进行的，那么&lt;code&gt;(char)x&lt;/code&gt;就是保留其低八位的值，也就是&lt;code&gt;0000 0001&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="http://jihong.xyz/categories/computer-principle/"/>
    
    
      <category term="编程素养" scheme="http://jihong.xyz/tags/Programming-literacy/"/>
    
  </entry>
  
  <entry>
    <title>关于二进制运算中的原码反码补码的一些理解</title>
    <link href="http://jihong.xyz/computer-principle/%E5%85%B3%E4%BA%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BF%90%E7%AE%97%E4%B8%AD%E7%9A%84%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <id>http://jihong.xyz/computer-principle/关于二进制运算中的原码反码补码的一些理解/</id>
    <published>2016-10-11T14:39:23.000Z</published>
    <updated>2016-11-14T08:48:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在上计组的课的时候又再次提到了位运算，当然也提到了加减法中的经典问题，为什么计算机要用补码（Two’s Complement）来表示负数。</p><h3 id="二进制的基本表示范围"><a href="#二进制的基本表示范围" class="headerlink" title="二进制的基本表示范围"></a>二进制的基本表示范围</h3><p>首先先从8位二进制说起吧，依次类推，直到64位及以上都是适用的。<br>8位二进制正数表示范围：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">0000</span> <span class="number">0000</span> ~ <span class="number">1111</span> <span class="number">1111</span></div><div class="line">（<span class="number">0</span> ~ <span class="number">255</span>）</div></pre></td></tr></table></figure><p>可见直观的二进制方案只能表示正数，那么如果需要表示负数就需要占用最高位来作为符号位，0表示正数，1表示负数。这样，8位二进制数表示范围就发生了变化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">负数：<span class="number">1</span> <span class="number">111</span> <span class="number">1111</span> ~ <span class="number">1</span> <span class="number">000</span> <span class="number">0000</span> </div><div class="line">    （<span class="number">-127</span> ~  <span class="number">-0</span>)</div><div class="line">正数：<span class="number">0</span> <span class="number">000</span> <span class="number">0000</span> ~ <span class="number">0</span> <span class="number">111</span> <span class="number">1111</span></div><div class="line">    （<span class="number">0</span> ~ <span class="number">127</span>）</div></pre></td></tr></table></figure><a id="more"></a><p>若要计算16 + (-8) = ?，则我们可以得到以下算式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  <span class="number">0</span> <span class="number">001</span> <span class="number">0000</span></div><div class="line">+ <span class="number">1</span> <span class="number">000</span> <span class="number">1000</span></div><div class="line">----------------</div><div class="line">  <span class="number">1</span> <span class="number">001</span> <span class="number">1000</span></div></pre></td></tr></table></figure><p>结果出乎意料，并非我们想象中的8，而是-24。</p><h3 id="补码运算"><a href="#补码运算" class="headerlink" title="补码运算"></a>补码运算</h3><p>如果要保证结果正确，就需要修改计算机做加法的方式，非常不方便。所以我们需要采用补码形式来表示有符号数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  <span class="number">0</span> <span class="number">001</span> <span class="number">0000</span></div><div class="line">+ <span class="number">1</span> <span class="number">111</span> <span class="number">1000</span></div><div class="line">----------------</div><div class="line"> <span class="number">10</span> <span class="number">000</span> <span class="number">1000</span></div></pre></td></tr></table></figure><p>注意到这是一个9位的二进制，因为我们只有8位，所以舍弃最高位1，看下结果，非常完美，就是8.</p><p>那么补码怎么计算出来的呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>、正数：原码和补码一致</div><div class="line"><span class="number">2</span>、负数：符号位不变，原码取反，然后加<span class="number">1</span></div></pre></td></tr></table></figure><h3 id="补码的本质"><a href="#补码的本质" class="headerlink" title="补码的本质"></a>补码的本质</h3><p>要将证书转变成对应的负数，只要用0减去这个数就可以了，但是明显不够减，所以我们需要<strong>向前借一位</strong>，0-16就可以用以下式子求出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">  <span class="number">1</span> <span class="number">111</span> <span class="number">1111</span></div><div class="line">- <span class="number">0</span> <span class="number">001</span> <span class="number">1111</span></div><div class="line">----------------</div><div class="line">  <span class="number">1</span> <span class="number">110</span> <span class="number">1111</span></div><div class="line">+ <span class="number">0</span> <span class="number">000</span> <span class="number">0001</span></div><div class="line">----------------</div><div class="line">  <span class="number">1</span> <span class="number">111</span> <span class="number">0000</span></div></pre></td></tr></table></figure><p>这不就是我们上边所说的，符号位不变，按位取反再加1么。结果已经很快的出来了，是正确的。<strong>根据<code>1 111 0000</code>再求一次补码就可以得到它的真值<code>1 001 0000</code>。</strong>当然如果是正数也是需要再求一次补码才能得到真值的，但是因为正数的补码与原码相同，所以可以直接求值。</p><p>我们再来看看之前16-8产生溢出的情况，因为结果肯定是为正数，那么前一位的符号位此时为1必然要溢出掉变为0才会得到我们想要的正数结果，是什么造成这样的溢出呢？我们可以看前文，补码的本质是向前借了一位来进行运算求补码的，所以其实这多溢出的一位就是之前向前借的那一位。</p><h3 id="关于补码再求补码为真值"><a href="#关于补码再求补码为真值" class="headerlink" title="关于补码再求补码为真值"></a>关于补码再求补码为真值</h3><p>其实我们可以假设一个时钟的周期为12小时，当前为2点钟，如果要把时钟调整到5点，一种方案是顺时针转动3个单位，另一种方案是逆时针转动9个单位，我们约定顺时针为-，逆时针为+。那么就有-3的补码就是+9，补码的再求补就是-3，就是原值了。相当于反复拨时钟而已。</p><h3 id="移位"><a href="#移位" class="headerlink" title="移位"></a>移位</h3><p>逻辑移位（不管是左移位还是右移位） 都是空缺处补0<br>算术移位要保证符号位的不改变（逻辑左移位补0, 逻辑右移位看符号位）</p><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>不难发现，-1的补码还可以这么求：1取反（包括符号位），然后加1，其实也能得到-1的补码。在程序中，可以让表示一个数的相反数表示如下：~num + 1。当然，表示为-1* num更为直观。其实本质就是先通过符号位取反来达到负数的效果，然后求补码，因为在C语言中int型变量是要用补码来表示的，所以自然而然就求出了相反数。</p><ul><li>如果是正数，比如0001，那么求出的负数的补码就是1111，当计算机要显示为十进制时，又需要再求一次补码，变为1001，结果就是-1；</li><li>如果是负数，比如1011(-3)，那么求出的正数的补码就是0101，当计算机要显示为十进制的时候同样需要再求一次补码，但是因为正数补码相同，所以结果是3. </li></ul><p>一般来说补码教科书上所说的补码都是说表示正数时补码与原码相同，表示负数时符号位不变，按位取反再+1。但是其实这样理解我个人觉得是不能了解补码的本质的。根绝上面写的时钟的例子，再用一个环来表示补码可能更容易理解一些。</p><p>我们可以想象把0~255首尾相接成为一个环，那么环的一边从0 0000000 ~ 0 1111111表示正数，另一边从表示负数。如下图<img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-11-14-075944.jpg" alt=""></p><p><strong>那么可以得到，0-1的结果为-1，也就是环中位置左移至1 1111111，与-1的补码为1 1111111这个结果一致。一个正数与其相反数(补码表示)相加的结果是为0的。0 0000001 + x = 00000000，那么x的值为多少？通过计算我们可以得到x为1 1111110。与我们用环表示的结果不谋而合</strong><br><strong>那么-128呢？-128+x=0，x的值为128，用二进制表示就是1 0000000，但是我们已经用来表示-128了。所以128在8位二进制中是没法表示的。</strong><br><strong>这也就是为什么求一个数的补码可以用其相反数全部按位取反再+1，这样它俩相加之后的结果就会溢出，结果为0</strong><br><strong>好了，再来说说为什么正数与其相反数相加之后为什么结果是0。这不是废话么哈哈哈哈</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在上计组的课的时候又再次提到了位运算，当然也提到了加减法中的经典问题，为什么计算机要用补码（Two’s Complement）来表示负数。&lt;/p&gt;
&lt;h3 id=&quot;二进制的基本表示范围&quot;&gt;&lt;a href=&quot;#二进制的基本表示范围&quot; class=&quot;headerlink&quot; title=&quot;二进制的基本表示范围&quot;&gt;&lt;/a&gt;二进制的基本表示范围&lt;/h3&gt;&lt;p&gt;首先先从8位二进制说起吧，依次类推，直到64位及以上都是适用的。&lt;br&gt;8位二进制正数表示范围：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0000&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0000&lt;/span&gt; ~ &lt;span class=&quot;number&quot;&gt;1111&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1111&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;（&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ~ &lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;）&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可见直观的二进制方案只能表示正数，那么如果需要表示负数就需要占用最高位来作为符号位，0表示正数，1表示负数。这样，8位二进制数表示范围就发生了变化：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;负数：&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;111&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1111&lt;/span&gt; ~ &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;000&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0000&lt;/span&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    （&lt;span class=&quot;number&quot;&gt;-127&lt;/span&gt; ~  &lt;span class=&quot;number&quot;&gt;-0&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;正数：&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;000&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0000&lt;/span&gt; ~ &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;111&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1111&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    （&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ~ &lt;span class=&quot;number&quot;&gt;127&lt;/span&gt;）&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="http://jihong.xyz/categories/computer-principle/"/>
    
    
      <category term="编程素养" scheme="http://jihong.xyz/tags/Programming-literacy/"/>
    
  </entry>
  
  <entry>
    <title>二级指针操纵单向链表</title>
    <link href="http://jihong.xyz/programming/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%93%8D%E7%BA%B5%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://jihong.xyz/programming/二级指针操纵单向链表/</id>
    <published>2016-10-10T07:52:29.000Z</published>
    <updated>2018-03-04T07:37:57.825Z</updated>
    
    <content type="html"><![CDATA[<p>越往后学越发感受到 C 语言的强大，我想这也正是它风靡几十年不倒的原因吧！而学习 C 语言，最重要也是最强大的莫过于它的指针了。今天正好看到了一个比较有趣的关于单向链表删除的问题，下来就来详细剖析这个问题。</p><p>二级指针在之前的一篇关于<a href="/programming/指针的指针——二级指针/">二级指针</a>的文章里有详细谈到。</p><p>一般来说，在单项链表中要删除当前curr节点时，只需要令<code>prev-&gt;next = next</code>，再<code>free(curr)</code>就完成了这个删除操作。但是这样做不好的地方是我们必然要维护一个previous先序结点，且在每次判断时还需要区分当前结点是否是头节点，如果是头节点在删除之前还要令<code>head = next</code>。完整的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> node&#123;</div><div class="line">    <span class="keyword">struct</span> node * next;</div><div class="line">    ....</div><div class="line">&#125; node;</div><div class="line"><span class="comment">//给bool(*)(node const)的类型函数指针取一个别名为remove_fn </span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(* remove_fn)</span><span class="params">(node <span class="keyword">const</span> * v)</span></span>;</div><div class="line"> </div><div class="line"><span class="comment">// Remove all nodes from the supplied list for which the</span></div><div class="line"><span class="comment">// supplied remove function returns true.</span></div><div class="line"><span class="comment">// Returns the new head of the list.</span></div><div class="line"><span class="function">node * <span class="title">remove_if</span><span class="params">(node * head, remove_fn rm)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span> (node * prev = <span class="literal">NULL</span>, * curr = head; curr != <span class="literal">NULL</span>; )&#123;</div><div class="line">        node * <span class="keyword">const</span> next = curr-&gt;next;</div><div class="line">        <span class="keyword">if</span> (rm(curr))&#123;</div><div class="line">            <span class="keyword">if</span> (prev)</div><div class="line">                prev-&gt;next = next;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                head = next;</div><div class="line">            <span class="built_in">free</span>(curr);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            prev = curr;</div><div class="line">            </div><div class="line">        curr = next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><p>如果你了解指针这一神器搬的东西的话，那么我们意识到删除操作的本质是指针值的改变，这样自然而然就会想要用二级指针去操纵指针的值。下面来看一段用二级指针改进的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_if</span><span class="params">(node ** head, remove_fn rm)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span> (node** curr = head; *curr; )&#123;</div><div class="line">        node * entry = *curr;</div><div class="line">        <span class="keyword">if</span> (rm(entry))&#123;</div><div class="line">            *curr = entry-&gt;next;            <span class="built_in">free</span>(entry);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            curr = &amp;entry-&gt;next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以很清楚的看到，不需要再维护prev指针了，也不需要再判断是否为链表头了，奇妙之处就在于，curr变成了一个指向指针的指针。</p><p>我们来好好分析一下上面的代码：</p><ul><li><p>假设当前为程序刚开始的情况：</p><ol><li>调用函数时应为：remove_if(&amp;phead, rm)取phead指针的地址赋给函数里的形参head，phead为指向首节点的指针；</li><li>c/c++ 语言的函数 参数传递一律为值传递。要达到改变所传递的参数的值,我们只能想法把存放这个实际值的内存地址当做参数进行传递，然后我们操作内存地址，通过修改这个地址所指向的值，间接达到修改这个值的效果；</li><li>*curr（我们马上删除它）也就是首节点的地址，因为head的值为phead的地址，所以*head为phead的内容，也就是首节点的地址，**head即为*phead，也就是首节点的内容。</li><li><code>*curr = entry-&gt;next</code>语句中，entry当前值为首节点的地址，也表示首节点，所以*curr在语句执行完之后就会是第二个节点的地址。</li><li><code>curr = &amp;entry-&gt;next</code>语句中，curr保存的是当前结点next指针的地址，也就意味着*curr为下一个节点的地址，**curr为下一个节点的内容。</li></ol></li><li>对于不是刚开始的情况：<ol><li>如果不删除当前结点 —— curr保存的是当前结点next指针的地址</li><li>entry 保存了 *curr —— 这意味着在下一次循环：entry就是prev-&gt;next指针所指向的内存</li><li>删除结点：*curr = entry-&gt;next; —— 于是：prev-&gt;next 指向了 entry -&gt; next</li></ol></li></ul><p>如果不是很清楚的话，来看看下面的几张图：<br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-10-10-19%3A31%3A33.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;越往后学越发感受到 C 语言的强大，我想这也正是它风靡几十年不倒的原因吧！而学习 C 语言，最重要也是最强大的莫过于它的指针了。今天正好看到了一个比较有趣的关于单向链表删除的问题，下来就来详细剖析这个问题。&lt;/p&gt;
&lt;p&gt;二级指针在之前的一篇关于&lt;a href=&quot;/programming/指针的指针——二级指针/&quot;&gt;二级指针&lt;/a&gt;的文章里有详细谈到。&lt;/p&gt;
&lt;p&gt;一般来说，在单项链表中要删除当前curr节点时，只需要令&lt;code&gt;prev-&amp;gt;next = next&lt;/code&gt;，再&lt;code&gt;free(curr)&lt;/code&gt;就完成了这个删除操作。但是这样做不好的地方是我们必然要维护一个previous先序结点，且在每次判断时还需要区分当前结点是否是头节点，如果是头节点在删除之前还要令&lt;code&gt;head = next&lt;/code&gt;。完整的代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; node&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; node * next;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ....&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; node;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//给bool(*)(node const)的类型函数指针取一个别名为remove_fn &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(* remove_fn)&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(node &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; * v)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Remove all nodes from the supplied list for which the&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// supplied remove function returns true.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Returns the new head of the list.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;node * &lt;span class=&quot;title&quot;&gt;remove_if&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(node * head, remove_fn rm)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (node * prev = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, * curr = head; curr != &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;; )&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        node * &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; next = curr-&amp;gt;next;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (rm(curr))&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (prev)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                prev-&amp;gt;next = next;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                head = next;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;free&lt;/span&gt;(curr);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            prev = curr;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        curr = next;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; head;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://jihong.xyz/categories/programming/"/>
    
    
      <category term="C/C++" scheme="http://jihong.xyz/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>指针的指针--二级指针</title>
    <link href="http://jihong.xyz/programming/%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88%E2%80%94%E2%80%94%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/"/>
    <id>http://jihong.xyz/programming/指针的指针——二级指针/</id>
    <published>2016-10-09T09:32:12.000Z</published>
    <updated>2016-10-10T12:06:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>在重新温习C/C++的时候不可避免的重头戏就是指针，指针要用得好，光用一层显然是不行的，我们还需要知道二级指针的操纵。</p><p>假设A-&gt;B-&gt;C,即A指向B，B指向C的关系中，C是一段我们实际关心的内容，假如我们用malloc或者new分配了一块内存，然后赋值”一段内容”进去，那么就是C了。我们假设C的内存起始地址为0x00000008.那么我们自然而然就可以得出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">B == <span class="number">0x00000008</span>;<span class="comment">//B内存块的实际内容</span></div><div class="line">*B == <span class="string">"一段内容"</span>;<span class="comment">//B解引用，也就是B指针指向的C的值</span></div><div class="line">&amp;B == <span class="number">0x00000008</span> <span class="string">"//B取地址，B的地址是0x00000004</span></div></pre></td></tr></table></figure><p>那么我们再来看看A此时的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">*A == B == <span class="number">0x00000008</span>;  <span class="comment">//A解引用也就是B的内容   </span></div><div class="line">**A == *B == <span class="string">"一段内容"</span>;  <span class="comment">//B解引用，也就是B指针指向的C的值  </span></div><div class="line">A == &amp;B == <span class="number">0x00000004</span>;  <span class="comment">//A存的是B的地址，B的地址是0x00000004  </span></div><div class="line">&amp;A == <span class="number">0x00000000</span>;  <span class="comment">//A取地址，A的地址是0x00000000</span></div></pre></td></tr></table></figure><p><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-10-10-17%3A58%3A23.jpg" alt=""><br><a id="more"></a><br><strong>二级指针的意义</strong>：之所以定义二级指针**P，不是为了使用**P表示指向的值，而是为了使用*P来存储存储值的那个单元的地址。<strong>同时也是希望别人给自己的一个指针赋值（可以拿来动态申请内存地址等等）</strong> 。</p><p>看看下面一段代码：有两个变量a,b,指针q,q指向a，我们想让q指向b,在函数里面实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>   </span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </div><div class="line">  </div><div class="line"><span class="keyword">int</span> a= <span class="number">10</span>;  </div><div class="line"><span class="keyword">int</span> b = <span class="number">100</span>;  </div><div class="line"><span class="keyword">int</span> *q;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *p)</span> </span>&#123;  </div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"func:&amp;p="</span>&lt;&lt;&amp;p&lt;&lt;<span class="string">",p="</span>&lt;&lt;p&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//note:3  </span></div><div class="line">    p = &amp;b;  </div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"func:&amp;p="</span>&lt;&lt;&amp;p&lt;&lt;<span class="string">",p="</span>&lt;&lt;p&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//note:4  </span></div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"&amp;a="</span>&lt;&lt;&amp;a&lt;&lt;<span class="string">",&amp;b="</span>&lt;&lt;&amp;b&lt;&lt;<span class="string">",&amp;q="</span>&lt;&lt;&amp;q&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//note:1  </span></div><div class="line">    q = &amp;a;  </div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"*q="</span>&lt;&lt;*q&lt;&lt;<span class="string">",q="</span>&lt;&lt;q&lt;&lt;<span class="string">",&amp;q="</span>&lt;&lt;&amp;q&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//note:2  </span></div><div class="line">    func(q);  </div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"*q="</span>&lt;&lt;*q&lt;&lt;<span class="string">",q="</span>&lt;&lt;q&lt;&lt;<span class="string">",&amp;q="</span>&lt;&lt;&amp;q&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//note:5  </span></div><div class="line">  </div><div class="line">    system(<span class="string">"pause"</span>);  </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们来看看输出的结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&amp;a=<span class="number">0x101d6a0c8</span>,&amp;b=<span class="number">0x101d6a0cc</span>,&amp;q=<span class="number">0x101d6a0d0</span></div><div class="line">*q=<span class="number">10</span>,q=<span class="number">0x101d6a0c8</span>,&amp;q=<span class="number">0x101d6a0d0</span></div><div class="line">func:&amp;p=<span class="number">0x7fff5de97ab8</span>,p=<span class="number">0x101d6a0c8</span></div><div class="line">func:&amp;p=<span class="number">0x7fff5de97ab8</span>,p=<span class="number">0x101d6a0cc</span></div><div class="line">*q=<span class="number">10</span>,q=<span class="number">0x101d6a0c8</span>,&amp;q=<span class="number">0x101d6a0d0</span></div></pre></td></tr></table></figure><p><strong>为什么*q不是100？</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">note:<span class="number">1</span>-&gt;a,b,q都有一个地址.</div><div class="line">note:<span class="number">2</span>-&gt;q指向a.</div><div class="line">note:<span class="number">3</span>-&gt;我们发现参数p的地址变了,跟q不一样了，是的参数传递是制作了一个副本,也就是p和q不是同一个指针,但是指向的地址<span class="number">0x0032F000</span>(a的地址)还是不变的.</div><div class="line">note:<span class="number">4</span>-&gt;p重新指向b.</div><div class="line">note:<span class="number">5</span>-&gt;退出函数,p的修改并不会对q造成影响。</div></pre></td></tr></table></figure><p>你可能会问，我们可以通过<em>p = b,来使得\</em>q==100啊，但是这样，q的内容还是指向a，是a的值变为了100，而不是指针q指向了b。</p><p><strong>编译器总是要为函数的每个参数制作临时副本，指针参数p的副本是 p，编译器使 p = q(但是&amp;p != &amp;q,也就是他们并不在同一块内存地址，只是他们的内容一样，都是a的地址)。如果函数体内的程序修改了p的内容(比如在这里它指向b)。在本例中，p申请了新的内存，只是把 p所指的内存地址改变了(变成了b的地址,但是q指向的内存地址没有影响)，所以在这里并不影响函数外的指针q。</strong></p><p>接下来看看二级指针的操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> a= <span class="number">10</span>;</div><div class="line"><span class="keyword">int</span> b = <span class="number">100</span>;</div><div class="line"><span class="keyword">int</span> *q;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> **p)</span>  </span>&#123;<span class="comment">//2</span></div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"func:&amp;p="</span>&lt;&lt;&amp;p&lt;&lt;<span class="string">", p="</span>&lt;&lt;p&lt;&lt;<span class="string">",*p="</span>&lt;&lt;*p&lt;&lt;<span class="string">",**p="</span>&lt;&lt;**p&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    *p = &amp;b;  <span class="comment">//3</span></div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"func:&amp;p="</span>&lt;&lt;&amp;p&lt;&lt;<span class="string">", p="</span>&lt;&lt;p&lt;&lt;<span class="string">",*p="</span>&lt;&lt;*p&lt;&lt;<span class="string">",**p="</span>&lt;&lt;**p&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"&amp;a="</span>&lt;&lt;&amp;a&lt;&lt;<span class="string">",&amp;b="</span>&lt;&lt;&amp;b&lt;&lt;<span class="string">",&amp;q="</span>&lt;&lt;&amp;q&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    q = &amp;a;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"*q="</span>&lt;&lt;*q&lt;&lt;<span class="string">",q="</span>&lt;&lt;q&lt;&lt;<span class="string">",&amp;q="</span>&lt;&lt;&amp;q&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    func(&amp;q);  <span class="comment">//1</span></div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"*q="</span>&lt;&lt;*q&lt;&lt;<span class="string">",q="</span>&lt;&lt;q&lt;&lt;<span class="string">",&amp;q="</span>&lt;&lt;&amp;q&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    system(<span class="string">"pause"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&amp;a=<span class="number">0x1088990c8</span>,&amp;b=<span class="number">0x1088990cc</span>,&amp;q=<span class="number">0x1088990d0</span></div><div class="line">*q=<span class="number">10</span>,q=<span class="number">0x1088990c8</span>,&amp;q=<span class="number">0x1088990d0</span></div><div class="line">func:&amp;p=<span class="number">0x7fff57368ab8</span>, p=<span class="number">0x1088990d0</span>,*p=<span class="number">0x1088990c8</span>,**p=<span class="number">10</span></div><div class="line">func:&amp;p=<span class="number">0x7fff57368ab8</span>, p=<span class="number">0x1088990d0</span>,*p=<span class="number">0x1088990cc</span>,**p=<span class="number">100</span></div><div class="line">*q=<span class="number">100</span>,q=<span class="number">0x1088990cc</span>,&amp;q=<span class="number">0x1088990d0</span></div></pre></td></tr></table></figure><p>结果一目了然了，p的值为q的地址,<em>p的值为b的地址，\</em>*p的值为b的值100，也就是q的地址的值为b的地址了，q指向了b。</p><p>上面的代码对于第一次一级指针的代码来说只改了三个地方，变成了传二级指针。</p><p>当然二级指针这个东西，需要有更多的时间，理解更深之后，就能够自然而然地理解了。</p><p>现在举个简单例子来说明它。画一个地址大小为 1byte 的内存空间：</p><table><thead><tr><th>addr</th><th>value</th><th></th></tr></thead><tbody><tr><td>20</td><td>0A</td><td>//ch1;</td></tr><tr><td>21</td><td>CC</td><td></td></tr><tr><td>22</td><td>20</td><td>//p1;</td></tr><tr><td>23</td><td>22</td><td>//pp1;</td></tr></tbody></table><p>现在我们假设有一个变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> ch1 = <span class="number">0x0A</span>;  <span class="comment">// 假设 ch1 的地址位于 20H: m[20H] = 0AH;</span></div><div class="line"><span class="keyword">char</span>* p1 = &amp;ch1;</div><div class="line"><span class="keyword">char</span>** pp1 = &amp;p1;</div></pre></td></tr></table></figure><p>假设内存空间，我们看做一个数组： char[ ]; 为这个数组取个名字叫做 m，例如：<br><code>char m[256];</code><br>现在我们得到那个 0x0A ，就可以通过<br><code>char ch2 = **pp1;</code><br>因此，我们就可以理解成：<br><code>char ch2 = m[ m[ pp1 ] ];  //解二级指针引用。</code></p><p><strong>以上是二级指针</strong></p><hr><p>同样，<br><code>char ch3 = *p1;</code><br>可以理解成：<br><code>char ch3 = m[ p1 ]; //解指针引用</code><br>OK，在汇编层面，就是这样（在汇编语言中，没有 m，只会出现 [ ]） 。比如说：</p><figure class="highlight as"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MOV EAX, [ EDX + <span class="number">8</span> ]</div><div class="line">CALL EAX</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在重新温习C/C++的时候不可避免的重头戏就是指针，指针要用得好，光用一层显然是不行的，我们还需要知道二级指针的操纵。&lt;/p&gt;
&lt;p&gt;假设A-&amp;gt;B-&amp;gt;C,即A指向B，B指向C的关系中，C是一段我们实际关心的内容，假如我们用malloc或者new分配了一块内存，然后赋值”一段内容”进去，那么就是C了。我们假设C的内存起始地址为0x00000008.那么我们自然而然就可以得出：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;B == &lt;span class=&quot;number&quot;&gt;0x00000008&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//B内存块的实际内容&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;*B == &lt;span class=&quot;string&quot;&gt;&quot;一段内容&quot;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//B解引用，也就是B指针指向的C的值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;amp;B == &lt;span class=&quot;number&quot;&gt;0x00000008&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;//B取地址，B的地址是0x00000004&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那么我们再来看看A此时的情况：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;*A == B == &lt;span class=&quot;number&quot;&gt;0x00000008&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;//A解引用也就是B的内容   &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;**A == *B == &lt;span class=&quot;string&quot;&gt;&quot;一段内容&quot;&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;//B解引用，也就是B指针指向的C的值  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;A == &amp;amp;B == &lt;span class=&quot;number&quot;&gt;0x00000004&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;//A存的是B的地址，B的地址是0x00000004  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;amp;A == &lt;span class=&quot;number&quot;&gt;0x00000000&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;//A取地址，A的地址是0x00000000&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7xpajj.com1.z0.glb.clouddn.com/2016-10-10-17%3A58%3A23.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://jihong.xyz/categories/programming/"/>
    
    
      <category term="C/C++" scheme="http://jihong.xyz/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>AT&amp;T风格汇编语言语法</title>
    <link href="http://jihong.xyz/programming/AT-T%E9%A3%8E%E6%A0%BC%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://jihong.xyz/programming/AT-T风格汇编语言语法/</id>
    <published>2016-10-01T12:17:39.000Z</published>
    <updated>2016-10-10T12:28:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AT-amp-T风格汇编语言语法"><a href="#AT-amp-T风格汇编语言语法" class="headerlink" title="AT&amp;T风格汇编语言语法"></a>AT&amp;T风格汇编语言语法</h1><h4 id="1-Register-Reference"><a href="#1-Register-Reference" class="headerlink" title="1. Register Reference"></a>1. Register Reference</h4><p>引用寄存器要在寄存器号前加百分号<code>%</code>,如<code>“movl %eax, %ebx”</code>。<br>80386 有如下寄存器:<br>[1] 8 个32-bit 寄存器 <code>%eax，%ebx，%ecx，%edx，%edi，%esi，%ebp，%esp</code>；<br>( 8 个16-bit 寄存器，它们事实上是上面8 个32-bit 寄存器的低16 位：<code>%ax，%bx，%cx，%dx，%di，%si，%bp，%sp</code>；8 个8-bit 寄存器：<code>%ah，%al，%bh，%bl，%ch，%cl，%dh，%dl</code>。它们事实上是寄存器<code>%ax，%bx，%cx，%dx 的高8 位和低8位</code>；)<br>[2] 6 个段寄存器：<code>%cs(code)，%ds(data)，%ss(stack), %es，%fs，%gs</code>；<br>[3] 3 个控制寄存器：<code>%cr0，%cr2，%cr3</code>；<br>[4] 6 个debug 寄存器：<code>%db0，%db1，%db2，%db3，%db6，%db7</code>；<br>[5] 2 个测试寄存器：<code>%tr6，%tr7</code>；<br>[6] 8 个浮点寄存器<br>栈：<code>%st(0)，%st(1)，%st(2)，%st(3)，%st(4)，%st(5)，%st(6)，%st(7)</code>。<br><a id="more"></a></p><h4 id="2-Operator-Sequence"><a href="#2-Operator-Sequence" class="headerlink" title="2. Operator Sequence"></a>2. Operator Sequence</h4><p>操作数排列是从源（左）到目的（右），如“movl %eax(源）, %ebx(目的）”   </p><h4 id="3-Immediately-Operator"><a href="#3-Immediately-Operator" class="headerlink" title="3. Immediately Operator"></a>3. Immediately Operator</h4><p>使用立即数，要在数前面加符号\$, 如 <code>“movl $0x04, %ebx”</code><br>或者：<br><code>para = 0x04</code><br><code>movl $para, %ebx</code><br>指令执行的结果是将立即数 <code>0x04</code> 装入寄存器<code>ebx</code>。   </p><h4 id="4-Symbol-Constant"><a href="#4-Symbol-Constant" class="headerlink" title="4. Symbol Constant"></a>4. Symbol Constant</h4><p>符号常数直接引用 如:<br><code>value: .long 0x12a3f2de</code><br><code>movl value , %ebx</code><br>指令执行的结果是将常数<code>0x12a3f2de</code> 装入寄存器<code>ebx</code>。<br>引用符号地址在符号前加符号\$, 如 <code>“movl $value, % ebx”</code>则是将符号<code>value</code> 的地址装入寄存器<code>ebx</code>。   </p><h4 id="5-Length-of-Operator"><a href="#5-Length-of-Operator" class="headerlink" title="5. Length of Operator"></a>5. Length of Operator</h4><p>操作数的长度用加在指令后的符号表示<code>b(byte, 8-bit), w(word, 16-bits), l(long,32-bits)</code>，如<code>“movb %al, %bl”</code>，<code>“movw %ax, %bx”</code>，<code>“movl %eax, %ebx”</code>。<br><strong>如果没有指定操作数长度的话，编译器将按照目标操作数的长度来设置。</strong><br>比如指令 <code>“mov %ax, %bx”</code>，由于目标操作数<code>bx</code> 的长度为<code>word</code>，那么编译器将把此指令等同于<code>“movw %ax,%bx”</code>。同样道理，指令<code>“mov $4, %ebx”</code>等同于指令<code>“movl $4, %ebx”</code>，<code>“push %al”</code>等同于<code>“pushb %al”</code>。<br>对于没有指定操作数长度，但编译器又无法猜测的指令，编译器将会报错，比如指令<code>“push $4”</code>。   </p><h4 id="6-Sign-and-Zero-Extension"><a href="#6-Sign-and-Zero-Extension" class="headerlink" title="6. Sign and Zero Extension"></a>6. Sign and Zero Extension</h4><p>绝大多数面向80386 的AT&amp;T 汇编指令与Intel 格式的汇编指令都是相同的，但符号扩展指令和零扩展指令有不同格式。符号扩展指令和零扩展指令需要指定源操作数长度和目的操作数长度，即使在某些指令中这些操作数是隐含的。<br>在AT&amp;T 语法中，符号扩展和零扩展指令的格式为，基本部分<code>&quot;movs&quot;</code>和<code>&quot;movz&quot;</code>（对应Intel 语法的<code>movsx</code> 和<code>movzx</code>），后面跟上源操作数长度和目的操作数长度。<br><code>movsbl</code>意味着<code>movs（from）byte（to）long</code>；<br><code>movbw</code>意味着<code>movs （from）byte （to）word</code>；<br><code>movswl</code>意味着<code>movs （from）word （to）long</code>。<br>对于movz 指令也一样。比如指令“movsbl %al,%edx”意味着将al 寄存器的内容进行符号扩展后放置到edx 寄存器中。 其它的Intel 格式的符号扩展指令还有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cbw -- sign-extend byte in %al to word in %ax； </div><div class="line">cwde -- sign-extend word in %ax to long in %eax； </div><div class="line">cwd -- sign-extend word in %ax to long in %dx:%ax； </div><div class="line">cdq -- sign-extend dword in %eax to quad in %edx:%eax； </div><div class="line">对应的AT&amp;T 语法的指令为cbtw，cwtl，cwtd，cltd.</div></pre></td></tr></table></figure></p><h4 id="7-Call-and-Jump"><a href="#7-Call-and-Jump" class="headerlink" title="7. Call and Jump"></a>7. Call and Jump</h4><p>段内调用和跳转指令为<code>call</code>，<code>ret</code>和<code>jmp</code>，段间调用和跳转指令为<code>lcall</code>，<code>lret</code>和<code>ljmp</code>。段间调用和跳转指令的格式为<code>lcall/ljmp $SECTION, $OFFSET</code>，而段间返回指令则为<code>lret $STACK-ADJUST</code>。</p><h4 id="8-Prefix"><a href="#8-Prefix" class="headerlink" title="8. Prefix"></a>8. Prefix</h4><p>操作码前缀被用在下列的情况：<br>[1]字符串重复操作指令(rep,repne)；<br>[2]指定被操作的段(cs,ds,ss,es,fs,gs)；<br>[3]进行总线加锁(lock)；<br>[4]指定地址和操作的大小(data16,addr16)；<br>在AT&amp;T 汇编语法中，操作码前缀通常被单独放在一行，后面不跟任何操作数。例如，对于重复scas 指令，其写法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">repne </div><div class="line">scas</div></pre></td></tr></table></figure></p><p>上述操作码前缀的意义和用法如下：<br>[1]指定被操作的段前缀为<code>cs,ds,ss,es,fs</code>,和<code>gs</code>。在AT&amp;T 语法中，只需要按照 section:memory-operand 的格式就指定了相应的段前缀。比如：<code>lcall %cs:realmode_swtch</code><br>[2]操作数／地址大小前缀是<code>data16</code>和<code>addr16</code>，它们被用来在32-bit 操作数／地址代码中指定16-bit 的操作数／地址。<br>[3]总线加锁前缀<code>lock</code>，它是为了在多处理器环境中，保证在当前指令执行期间禁止一切中断。这个前缀仅仅对<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG,DEC, </div><div class="line">INC, NEG, NOT, OR, SBB, SUB, XOR, XADD,XCHG</div></pre></td></tr></table></figure></p><p>指令有效，如果将Lock 前 缀用在其它指令之前，将会引起异常。<br>[4]字符串重复操作前缀<code>rep</code>,<code>repe</code>,<code>repne</code>用来让字符串操作重复<code>%ecx</code>次。</p><h4 id="9-Memory-Reference"><a href="#9-Memory-Reference" class="headerlink" title="9. Memory Reference"></a>9. Memory Reference</h4><p>Intel 语法的间接内存引用的格式为：<code>section:[base+index*scale+displacement]</code><br>而在AT&amp;T 语法中对应的形式为： <code>section:displacement(base,index,scale)</code><br>其中，<code>base</code> 和<code>index</code>是任意的<code>32-bit base 和index 寄存器</code>。<code>scale</code> 可以取值1，2，4，8。如果不指定scale 值，则默认值为1。<br><code>section</code>可以指定任意的段寄存器作为段前缀，默认的段寄存器在不同的情况下不一样。如果在指令中指定了默认的段前缀，则编译器在目标代码中不会产生此段前缀代码。下面是一些例子：</p><p><code>-4(%ebp)</code>：<code>base=%ebp，displacement=-4</code>，<code>section</code>没有指定，由于<code>base＝%ebp</code>，所以默认的<code>section=%ss</code>，<code>index,scale</code> 没有指定，则<code>index</code>为0。<br><code>foo(,%eax,4)</code>：<code>index=%eax，scale=4，displacement=foo</code>。其它域没有指定。这里默认的<code>section=%ds</code>。<br><code>foo(,1)</code>：这个表达式引用的是指针<code>foo</code>指向的地址所存放的值。注意这个表达式中没有<code>base</code> 和<code>index</code>，并且只有一个逗号，这是一种异常语法，但却合法。</p><p><code>%gs:foo</code>：这个表达式引用的是放置于<code>%gs</code>段里变量<code>foo</code>的值。<br>如果<code>call</code>和<code>jump</code>操作在操作数前指定前缀“*”，则表示是一个绝对地址调用/跳转，也就是说<code>jmp/call</code>指令指定的是一个绝对地址。如果没有指定”*“，则操作数是一个相对地址。任何指令如果其操作数是一个内存操作，则指令必须指定它的操作尺寸<code>byte,word,long</code>，也就是说必须带有指令后缀<code>b,w,l</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AT-amp-T风格汇编语言语法&quot;&gt;&lt;a href=&quot;#AT-amp-T风格汇编语言语法&quot; class=&quot;headerlink&quot; title=&quot;AT&amp;amp;T风格汇编语言语法&quot;&gt;&lt;/a&gt;AT&amp;amp;T风格汇编语言语法&lt;/h1&gt;&lt;h4 id=&quot;1-Register-Reference&quot;&gt;&lt;a href=&quot;#1-Register-Reference&quot; class=&quot;headerlink&quot; title=&quot;1. Register Reference&quot;&gt;&lt;/a&gt;1. Register Reference&lt;/h4&gt;&lt;p&gt;引用寄存器要在寄存器号前加百分号&lt;code&gt;%&lt;/code&gt;,如&lt;code&gt;“movl %eax, %ebx”&lt;/code&gt;。&lt;br&gt;80386 有如下寄存器:&lt;br&gt;[1] 8 个32-bit 寄存器 &lt;code&gt;%eax，%ebx，%ecx，%edx，%edi，%esi，%ebp，%esp&lt;/code&gt;；&lt;br&gt;( 8 个16-bit 寄存器，它们事实上是上面8 个32-bit 寄存器的低16 位：&lt;code&gt;%ax，%bx，%cx，%dx，%di，%si，%bp，%sp&lt;/code&gt;；8 个8-bit 寄存器：&lt;code&gt;%ah，%al，%bh，%bl，%ch，%cl，%dh，%dl&lt;/code&gt;。它们事实上是寄存器&lt;code&gt;%ax，%bx，%cx，%dx 的高8 位和低8位&lt;/code&gt;；)&lt;br&gt;[2] 6 个段寄存器：&lt;code&gt;%cs(code)，%ds(data)，%ss(stack), %es，%fs，%gs&lt;/code&gt;；&lt;br&gt;[3] 3 个控制寄存器：&lt;code&gt;%cr0，%cr2，%cr3&lt;/code&gt;；&lt;br&gt;[4] 6 个debug 寄存器：&lt;code&gt;%db0，%db1，%db2，%db3，%db6，%db7&lt;/code&gt;；&lt;br&gt;[5] 2 个测试寄存器：&lt;code&gt;%tr6，%tr7&lt;/code&gt;；&lt;br&gt;[6] 8 个浮点寄存器&lt;br&gt;栈：&lt;code&gt;%st(0)，%st(1)，%st(2)，%st(3)，%st(4)，%st(5)，%st(6)，%st(7)&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://jihong.xyz/categories/programming/"/>
    
    
      <category term="assembly" scheme="http://jihong.xyz/tags/assembly/"/>
    
  </entry>
  
  <entry>
    <title>使用Intellij Idea + Maven构建Java Web项目</title>
    <link href="http://jihong.xyz/Web/%E4%BD%BF%E7%94%A8Intellij-Idea-Maven%E6%9E%84%E5%BB%BAJava-Web%E9%A1%B9%E7%9B%AE/"/>
    <id>http://jihong.xyz/Web/使用Intellij-Idea-Maven构建Java-Web项目/</id>
    <published>2016-09-18T12:57:49.000Z</published>
    <updated>2018-03-04T07:39:01.871Z</updated>
    
    <content type="html"><![CDATA[<p>   最近正好需要用到Java来做一个web项目，好久也没接触Java了，正好趁着这个机会再熟悉熟悉Java。用Java来做web项目，配置是至关重要的，但也是相当繁琐的。不过好在自从servlet3.0与Spring出现之后，编写Java web已经变得比较简单了。不再需要那么多的xml配置，确实大大提高了生产力。</p><p>   接下来进入主题了，主要还是用maven来构建一个web项目，首先还是先要来了解一下Maven是什么，以及它可以拿来干嘛。</p><blockquote><p>Maven 其实是很多东西，Maven是一个项目管理工具，它包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。当你使用Maven的时候，你用一个明确定义的项目对象模型来描述你的项目，然后Maven可以应用横切的逻辑，这些逻辑来自一组共享的（或者自定义的）插件。Maven 有一个生命周期，当你运行 mvn install 的时候被调用。这条命令告诉 Maven 执行一系列的有序的步骤，直到到达你指定的生命周期。遍历生命周期旅途中的一个影响就是，Maven 运行了许多默认的插件目标，这些目标完成了像编译和创建一个 JAR 文件这样的工作。此外，Maven能够很方便的帮你管理项目报告，生成站点，管理JAR文件，等等。</p></blockquote><p><strong>但是简而言之，maven是把设计模式应用于构建架构的一种尝试，如下列出了maven 的大部分功能。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-Builds</div><div class="line">-Documentation</div><div class="line">-Reporting</div><div class="line">-Dependencies</div><div class="line">-SCMs</div><div class="line">-Releases</div><div class="line">-Distribution.</div></pre></td></tr></table></figure><a id="more"></a><p>值得一提的是，<strong>maven是约定优于配置的</strong> src/main/java约定用于存放源代码，src/main/test用于存放单元测试代码，src/target用于存放编译、打包后的输出文件。这是maven项目的通用约定，所以必须记住这些固定的目录结构。<br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-09-18-22%3A29%3A32.jpg" alt=""></p><p><strong>接下来就是说一些常用的命令了：</strong></p><ol><li>编译项目<ul><li>切换到项目所在的目录，执行<code>mvn compile</code> 这样就能对项目进行编译了，编译后会自动在target目录中生成class文件</li></ul></li><li>单元测试<ul><li>同样的需要切换到项目所在的目录，执行<code>mvn clean test</code></li></ul></li><li>项目打包<ul><li>一般来说我们会把项目打包成jar或者war，打包命令为<code>mvn clean package</code>。运行完后，会在target目录下生成jar包</li></ul></li></ol><p><strong>当然了，以上说的都是在命令行方式下的使用方式，关于maven的安装，如果在OSX系统上的话可以用homebrew来进行安装，其他的Linux发行版的话可以根据不同的包管理器来进行安装，都非常简单。</strong></p><hr><p>然后就开始用idea来一步步新建一个web项目：</p><ol><li>新建一个项目<br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-09-18-22%3A42%3A50.jpg" alt=""></li><li>在弹出的new project 页面，选择maven -&gt; 勾选Create from artifactype<br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-09-18-22%3A48%3A25.jpg" alt=""></li><li>接下来就是填写GroupId和ArtifactId了。GroupId就是项目组织唯一标识符，说简单点就是类似Java包的结构，习惯上都是域名反过来。而ArtifactId就是项目的唯一标识符，其实就是项目的名称而已。<br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-09-18-22%3A51%3A56.jpg" alt=""></li><li>这一步直接默认next也可以，archetypeCatalog表示插件使用的archetype元数据，不加这个参数时默认为remote，local，即中央仓库archetype元数据，由于中央仓库的archetype太多了，所以导致很慢，指定internal来表示仅使用内部元数据，这样创建的速度会快很多。<br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-09-18-23%3A29%3A17.jpg" alt=""></li><li>填写project name和module name，module name默认和project name 一样的。如果有多个module，还是可以改一下module名。<br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-09-18-22%3A58%3A23.jpg" alt=""></li><li>接着就在创建中了，根据网络的情况时间不定<br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-09-18-23%3A00%3A54.jpg" alt=""></li><li>光配置完maven不配置tomcat怎么行，接下来就开始配置一下tomcat.<br><strong>在配置tomcat之前有一点重要的要说，因为如果是使用OSX系统的话，从10.10开始1024一下的端口是不能够使用的，所以如果需要外网域名映射到本地80端口的话需要进行端口转发才可以（踩了不少坑..）特别是在做微信开发的时候，需要与Tencent的服务器交互验证，同时也需要在本地进行调试才方便。对这一块应该还是比较需要的。至于用外网域名映射到本地的方案，可以选择ngrok。</strong><br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-09-18-23%3A37%3A08.jpg" alt=""><br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-09-18-23%3A41%3A29.jpg" alt=""><br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-09-18-23%3A46%3A30.jpg" alt=""><br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-09-18-23%3A49%3A16.jpg" alt=""><br><img src="http://7xpajj.com1.z0.glb.clouddn.com/2016-09-18-23%3A54%3A18.jpg" alt=""></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   最近正好需要用到Java来做一个web项目，好久也没接触Java了，正好趁着这个机会再熟悉熟悉Java。用Java来做web项目，配置是至关重要的，但也是相当繁琐的。不过好在自从servlet3.0与Spring出现之后，编写Java web已经变得比较简单了。不再需要那么多的xml配置，确实大大提高了生产力。&lt;/p&gt;
&lt;p&gt;   接下来进入主题了，主要还是用maven来构建一个web项目，首先还是先要来了解一下Maven是什么，以及它可以拿来干嘛。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Maven 其实是很多东西，Maven是一个项目管理工具，它包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。当你使用Maven的时候，你用一个明确定义的项目对象模型来描述你的项目，然后Maven可以应用横切的逻辑，这些逻辑来自一组共享的（或者自定义的）插件。Maven 有一个生命周期，当你运行 mvn install 的时候被调用。这条命令告诉 Maven 执行一系列的有序的步骤，直到到达你指定的生命周期。遍历生命周期旅途中的一个影响就是，Maven 运行了许多默认的插件目标，这些目标完成了像编译和创建一个 JAR 文件这样的工作。此外，Maven能够很方便的帮你管理项目报告，生成站点，管理JAR文件，等等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;但是简而言之，maven是把设计模式应用于构建架构的一种尝试，如下列出了maven 的大部分功能。&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;-Builds&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;-Documentation&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;-Reporting&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;-Dependencies&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;-SCMs&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;-Releases&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;-Distribution.&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Web" scheme="http://jihong.xyz/categories/Web/"/>
    
    
      <category term="web后端" scheme="http://jihong.xyz/tags/web-background/"/>
    
  </entry>
  
  <entry>
    <title>Vim 常用命令</title>
    <link href="http://jihong.xyz/knowledge/vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://jihong.xyz/knowledge/vim常用命令/</id>
    <published>2016-06-27T12:19:43.000Z</published>
    <updated>2018-03-04T07:34:38.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vim常用命令"><a href="#Vim常用命令" class="headerlink" title="Vim常用命令"></a>Vim常用命令</h1><h3 id="光标移动-Cursor-Movement"><a href="#光标移动-Cursor-Movement" class="headerlink" title="光标移动(Cursor Movement)"></a>光标移动(Cursor Movement)</h3><table><thead><tr><th>命令</th><th>作用（解释）</th></tr></thead><tbody><tr><td>h,j,k,l</td><td>h表示往左，j表示往下，k表示往右，l表示往上</td></tr><tr><td>Ctrl+f</td><td>上一页</td></tr><tr><td>Ctrl+b</td><td>下一页</td></tr><tr><td>w, e, W, E</td><td>跳到单词的后面，小写包括标点</td></tr><tr><td>b, B</td><td>以单词为单位往前跳动光标，小写包含标点</td></tr><tr><td>O</td><td>开启新的一行</td></tr><tr><td>^</td><td>一行的开始</td></tr><tr><td>$</td><td>一行的结尾</td></tr><tr><td>gg</td><td>文档的第一行</td></tr><tr><td>[N]G</td><td>文档的第N行或者最后一行</td></tr></tbody></table><h3 id="插入模式-Insert-Mode"><a href="#插入模式-Insert-Mode" class="headerlink" title="插入模式(Insert Mode)"></a>插入模式(Insert Mode)</h3><table><thead><tr><th>命令</th><th>作用（解释)</th></tr></thead><tbody><tr><td>i</td><td>插入到光标前面</td></tr><tr><td>I</td><td>插入到行的开始位置</td></tr><tr><td>a</td><td>插入到光标的后面</td></tr><tr><td>A</td><td>插入到行的最后位置</td></tr><tr><td>o, O</td><td>新开一行</td></tr><tr><td>Esc</td><td>关闭插入模式</td></tr></tbody></table><a id="more"></a><h3 id="编辑-Editing"><a href="#编辑-Editing" class="headerlink" title="编辑(Editing)"></a>编辑(Editing)</h3><table><thead><tr><th>命令</th><th>作用（解释）</th></tr></thead><tbody><tr><td>r</td><td>在插入模式替换光标所在的一个字符</td></tr><tr><td>J</td><td>合并下一行到上一行</td></tr><tr><td>s</td><td>删除光标所在的一个字符, 光标还在当行</td></tr><tr><td>S</td><td>删除光标所在的一行，光标还在当行，不同于dd</td></tr><tr><td>u</td><td>撤销上一步操作</td></tr><tr><td>ctrl+r</td><td>恢复上一步操作</td></tr><tr><td>.</td><td>重复最后一个命令</td></tr><tr><td>~</td><td>变换为大写</td></tr><tr><td>[N]&gt;&gt;</td><td>一行或N行往右移动一个tab</td></tr><tr><td>[N]&lt;&lt;</td><td>一行或N行往左移动一个tab</td></tr></tbody></table><h3 id="关闭-Exiting"><a href="#关闭-Exiting" class="headerlink" title="关闭(Exiting)"></a>关闭(Exiting)</h3><table><thead><tr><th>命令</th><th>作用（解释)</th></tr></thead><tbody><tr><td>:w</td><td>保存</td></tr><tr><td>:wq, :x</td><td>保存并关闭</td></tr><tr><td>:q</td><td>关闭（已保存）</td></tr><tr><td>:q!</td><td>强制关闭</td></tr></tbody></table><h3 id="搜索-Search"><a href="#搜索-Search" class="headerlink" title="搜索(Search)"></a>搜索(Search)</h3><table><thead><tr><th>命令</th><th>作用（解释)</th></tr></thead><tbody><tr><td>/pattern</td><td>搜索（非插入模式)</td></tr><tr><td>?pattern</td><td>往后搜索</td></tr><tr><td>n</td><td>光标到达搜索结果的前一个目标</td></tr><tr><td>N</td><td>光标到达搜索结果的后一个目标</td></tr></tbody></table><h3 id="视觉模式-Visual-Mode"><a href="#视觉模式-Visual-Mode" class="headerlink" title="视觉模式(Visual Mode)"></a>视觉模式(Visual Mode)</h3><table><thead><tr><th>命令</th><th>作用（解释)</th></tr></thead><tbody><tr><td>v</td><td>选中一个或多个字符</td></tr><tr><td>V</td><td>选中一行</td></tr></tbody></table><h3 id="剪切和复制-Cut-and-Paste"><a href="#剪切和复制-Cut-and-Paste" class="headerlink" title="剪切和复制(Cut and Paste)"></a>剪切和复制(Cut and Paste)</h3><table><thead><tr><th>命令</th><th>作用（解释)</th></tr></thead><tbody><tr><td>dd</td><td>删除一行</td></tr><tr><td>dw</td><td>删除一个单词</td></tr><tr><td>x</td><td>删除后一个字符</td></tr><tr><td>X</td><td>删除前一个字符</td></tr><tr><td>D</td><td>删除一行最后一个字符</td></tr><tr><td>[N]yy</td><td>复制一行或者N行</td></tr><tr><td>yw</td><td>复制一个单词</td></tr><tr><td>p</td><td>粘贴</td></tr></tbody></table><h3 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h3><table><thead><tr><th>命令</th><th>作用（解释)</th></tr></thead><tbody><tr><td>:split</td><td>水平方向分割出一个窗口</td></tr><tr><td>:vsplit</td><td>垂直方向分割出一个窗口</td></tr><tr><td>:close</td><td>关闭窗口</td></tr><tr><td>Ctrl+W</td><td>切换窗口, h到左边窗口，j到下方窗口，k到上方窗口，l到右边窗口</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Vim常用命令&quot;&gt;&lt;a href=&quot;#Vim常用命令&quot; class=&quot;headerlink&quot; title=&quot;Vim常用命令&quot;&gt;&lt;/a&gt;Vim常用命令&lt;/h1&gt;&lt;h3 id=&quot;光标移动-Cursor-Movement&quot;&gt;&lt;a href=&quot;#光标移动-Cursor-Movement&quot; class=&quot;headerlink&quot; title=&quot;光标移动(Cursor Movement)&quot;&gt;&lt;/a&gt;光标移动(Cursor Movement)&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;作用（解释）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;h,j,k,l&lt;/td&gt;
&lt;td&gt;h表示往左，j表示往下，k表示往右，l表示往上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+f&lt;/td&gt;
&lt;td&gt;上一页&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+b&lt;/td&gt;
&lt;td&gt;下一页&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;w, e, W, E&lt;/td&gt;
&lt;td&gt;跳到单词的后面，小写包括标点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;b, B&lt;/td&gt;
&lt;td&gt;以单词为单位往前跳动光标，小写包含标点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;开启新的一行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;一行的开始&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$&lt;/td&gt;
&lt;td&gt;一行的结尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;gg&lt;/td&gt;
&lt;td&gt;文档的第一行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[N]G&lt;/td&gt;
&lt;td&gt;文档的第N行或者最后一行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;插入模式-Insert-Mode&quot;&gt;&lt;a href=&quot;#插入模式-Insert-Mode&quot; class=&quot;headerlink&quot; title=&quot;插入模式(Insert Mode)&quot;&gt;&lt;/a&gt;插入模式(Insert Mode)&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;作用（解释)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;插入到光标前面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;插入到行的开始位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;插入到光标的后面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;插入到行的最后位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;o, O&lt;/td&gt;
&lt;td&gt;新开一行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Esc&lt;/td&gt;
&lt;td&gt;关闭插入模式&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="必备知识" scheme="http://jihong.xyz/categories/knowledge/"/>
    
    
      <category term="vim" scheme="http://jihong.xyz/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Python元类到底是什么</title>
    <link href="http://jihong.xyz/programming/python%E5%85%83%E7%B1%BB%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://jihong.xyz/programming/python元类到底是什么/</id>
    <published>2016-06-01T01:01:41.000Z</published>
    <updated>2018-03-04T07:34:22.851Z</updated>
    
    <content type="html"><![CDATA[<p>最近趁着有点时间，打算把Python重拾一下。Python确实在很大意义上方便了我们的编程，解放了双手。特别是从 Java 变换过来，所以这也是为什么那么多人感叹“人生苦短，我用Python！”</p><p>在读到Python元类的时候，刚开始看到下面这段代码的我是很惊讶的.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(object, type)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(type, object)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(object(), type)</div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure><p>wtf？type和object互为子类？深受静态语言洗脑的我完全无法接受这样的现实.然后就开始了啃书啃知识的阶段了…开始搜寻它们俩到底是什么关系。</p><p>最后打破世界观的观点来了.type和object就好比蛋鸡关系那样，它们是一个共生关系，并不能说先有谁后有谁，需要同时存在.object的类型是type，也就是说object类是type类的实例对象，它们之间的关系就是实例关系.说起来有点拗口，不嫌烦的话再啰嗦一句，object类是type的实例化对象.</p><p>首先，要缕清这个关系，还是需要舍弃掉之前静态语言所带来的概念，重新构造我们的世界观.在python里，一切都是对象，这个一切比号称完全面向对象的java还要完全.<strong> 包括class、type、object等等都是对象 </strong>.</p><blockquote><p>“鸡・蛋”问题通常都是通过一种叫“自举”（bootstrap）的过程来解决的。其实“鸡蛋问题”的根本矛盾就在于假定了“鸡”或“蛋”的其中一个要先进入“完全可用”的状态。而许多现实中被简化为“鸡蛋问题”的情况实际可以在“混沌”中把“鸡”和“蛋”都初始化好，而不存在先后问题；在它们初始化的过程中，两者都不处于“完全可用”状态，而完成初始化后它们就同时都进入了可用状态。</p></blockquote><blockquote><p>打个比方，番茄炒蛋。并不是要先把番茄完全炒好，然后把鸡蛋完全炒好，然后把它们混起来；而是先炒番茄炒到半熟，再炒鸡蛋炒到半熟，然后把两个半熟的部分混在一起同时炒熟。<br><a id="more"></a></p></blockquote><p>对象之间需要联系在一起，靠什么？靠的就是关系，在python中，对象之间有两种关系：</p><ul><li>继承关系</li><li>实例关系</li></ul><p>首先说说继承关系，这个应该不会很陌生，引用知乎上的一段解析：</p><blockquote><p>比如有class A和class B(A)，再强调一下，A和B都是对象，则对象B继承了对象A，或者说A是B的超类，继承关系可以通过<strong>base</strong>属性得知，如</p></blockquote><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>B.__base__</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">A</span>'&gt;</span></div></pre></td></tr></table></figure></blockquote><blockquote><p>在python里，所有对象（包括type）均继承自object，而object则是继承体系的根，上面再无对象：</p></blockquote><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>object.__base__</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>type.__base__</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">object</span>'&gt;</span></div></pre></td></tr></table></figure></blockquote><p>接着在说说实例关系，比如有class A， a = A()，不嫌烦的再强调一下，a和A都是对象，则对象a是对象A的实例，或者说对象A是对象a的类型.如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.__class__</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">A</span>'&gt;</span></div></pre></td></tr></table></figure><p>在python里，对象又可以分为三种：type object、class object和non-class object。<br><strong> non-class object指通过实例化class object得来的对象 </strong><br>就如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">l=Mylist()</div></pre></td></tr></table></figure><p>三者的区别和联系在于：<br>type object都是type的实例，<br>class object是type object的实例，<br>non-class object是class object的实例，<br>type object和class object都可以进行实例化，<br>而non-class object不能进行实例化</p><p>最后借用一下在某blog里看到的图，不记得是在哪看到的了..没法引用地址，请原谅.<br><img src="http://7xpajj.com1.z0.glb.clouddn.com/ca54cfa2cc510d2dcc40e3cc7fb2e051_b.png" alt=""></p><p>第一列，元类列，type是所有元类的父亲。我们可以通过继承type来创建元类。</p><p>第二列，TypeObject列，也称类列，object是所有类的父亲，大部份我们直接使用的数据类型都存在这个列的。</p><p>第三列，实例列，实例是对象关系链的末端，不能再被子类化和实例化。</p><p>如果type和object只保留一个，那么一定是object。只有object 时，第一列将不复存在，只剩下二三列，第二列表示类型，第三列表示实例，这个和大部分静态语言的类型架构类似，如java 。<br>这样的架构将让python 失去一种很重要的动态特性–动态创建类型。本来，类(第二列的同学)在Python里面是一个对象(typeobject)，对象是可以在运行时动态修改的，所以我们能在你定义一个类之后去修改他的行为或属性！拿掉第一列后，第二列变成了纯类型，写成怎样的，运行时行为就怎样。在这一点上，并不比静态语言有优势。</p><p><strong> “鸡蛋问题”在于：Python里的所有类型都确实用一个type object表示，而所有类型都是object类的子类。<br>换句话说，<type 'type'="">类是<type 'object'="">的子类；而<type 'object'="">既是类又是个对象，是<type 'type'="">的实例。<br>这些核心类型的type对象在CPython里的C层面的类型是PyTypeObject，其结构是确定的；它们的存储空间通过静态变量分配，例如<type 'type'="">就声明为在object.h的PyTypeObject PyType_Type，对应的还有<type 'object'="">的PyTypeObject PyBaseObject_Type。<br>所以在进行初始化动作之前它们的存储空间就已经有着落了，真正做初始化时只要把它们的相互引用串起来就好. </type></type></type></type></type></type></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近趁着有点时间，打算把Python重拾一下。Python确实在很大意义上方便了我们的编程，解放了双手。特别是从 Java 变换过来，所以这也是为什么那么多人感叹“人生苦短，我用Python！”&lt;/p&gt;
&lt;p&gt;在读到Python元类的时候，刚开始看到下面这段代码的我是很惊讶的.&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;isinstance(object, type)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;isinstance(type, object)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;isinstance(object(), type)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;False&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;wtf？type和object互为子类？深受静态语言洗脑的我完全无法接受这样的现实.然后就开始了啃书啃知识的阶段了…开始搜寻它们俩到底是什么关系。&lt;/p&gt;
&lt;p&gt;最后打破世界观的观点来了.type和object就好比蛋鸡关系那样，它们是一个共生关系，并不能说先有谁后有谁，需要同时存在.object的类型是type，也就是说object类是type类的实例对象，它们之间的关系就是实例关系.说起来有点拗口，不嫌烦的话再啰嗦一句，object类是type的实例化对象.&lt;/p&gt;
&lt;p&gt;首先，要缕清这个关系，还是需要舍弃掉之前静态语言所带来的概念，重新构造我们的世界观.在python里，一切都是对象，这个一切比号称完全面向对象的java还要完全.&lt;strong&gt; 包括class、type、object等等都是对象 &lt;/strong&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“鸡・蛋”问题通常都是通过一种叫“自举”（bootstrap）的过程来解决的。其实“鸡蛋问题”的根本矛盾就在于假定了“鸡”或“蛋”的其中一个要先进入“完全可用”的状态。而许多现实中被简化为“鸡蛋问题”的情况实际可以在“混沌”中把“鸡”和“蛋”都初始化好，而不存在先后问题；在它们初始化的过程中，两者都不处于“完全可用”状态，而完成初始化后它们就同时都进入了可用状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;打个比方，番茄炒蛋。并不是要先把番茄完全炒好，然后把鸡蛋完全炒好，然后把它们混起来；而是先炒番茄炒到半熟，再炒鸡蛋炒到半熟，然后把两个半熟的部分混在一起同时炒熟。&lt;br&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://jihong.xyz/categories/programming/"/>
    
    
      <category term="Python" scheme="http://jihong.xyz/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Java中常见的问题</title>
    <link href="http://jihong.xyz/programming/java%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9D%91/"/>
    <id>http://jihong.xyz/programming/java中常见的坑/</id>
    <published>2016-03-30T11:42:21.000Z</published>
    <updated>2018-03-04T02:56:03.164Z</updated>
    
    <content type="html"><![CDATA[<h3 id="把数组转成ArrayList"><a href="#把数组转成ArrayList" class="headerlink" title="把数组转成ArrayList"></a>把数组转成ArrayList</h3><p>为了将数组转换为ArrayList，我们经常会这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list = Arrays.asList(arr);</div></pre></td></tr></table></figure><p>使用<code>Arrays.asList()</code>方法可以得到一个<code>ArrayList</code>，但是得到这个<code>ArrayList</code>其实是定义在<code>Arrays</code>类中的一个私有的静态内部类。这个类虽然和<code>java.util.ArrayList</code>同名，但是并不是同一个类。我就曾经被深深地坑过…<code>java.util.Arrays.ArrayList</code>类中实现了<code>set()</code>, <code>get()</code>, <code>contains()</code>等方法，但是并没有定义向其中增加元素的方法。也就是说通过<code>Arrays.asList()</code>得到的<code>ArrayList</code>的大小是固定的。</p><p>如果在开发过程中，想得到一个真正的<code>ArrayList</code>对象（java.util.ArrayList的实例），可以通过以下方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(arr));</div></pre></td></tr></table></figure><p>java.util.ArrayList中包含一个可以接受集合类型参数的构造函数。因为java.util.Arrays.ArrayList这个内部类继承了AbstractList类，所以，该类也是Collection的子类。<br><a id="more"></a></p><h3 id="判断一个数组是否包含某个值"><a href="#判断一个数组是否包含某个值" class="headerlink" title="判断一个数组是否包含某个值"></a>判断一个数组是否包含某个值</h3><p>在判断一个数组中是否包含某个值的时候，我们经常这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(arr));</div><div class="line">    <span class="keyword">return</span> set.contains(targetValue);</div></pre></td></tr></table></figure><p>以上方式虽然可以实现功能，但是效率却比较低。因为将数组压入Collection类型中，首先要将数组元素遍历一遍，然后再使用集合类做其他操作。</p><p>在判断一个数组是否包含某个值的时候，推荐使用for循环遍历的形式或者使用Apache Commons类库中提供的ArrayUtils类的contains方法。</p><h3 id="在循环中删除列表中的元素"><a href="#在循环中删除列表中的元素" class="headerlink" title="在循环中删除列表中的元素"></a>在循环中删除列表中的元素</h3><p>在讨论这个问题之前，先考虑以下代码的输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>));</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</div><div class="line">list.remove(i);</div><div class="line">&#125;</div><div class="line">System.out.println(list);</div></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[b,d]</div></pre></td></tr></table></figure><p>以上代码的目的是想遍历删除list中所有元素，但是结果却没有成功。原因是忽略了一个关键的问题：当一个元素被删除时，列表的大小缩小并且下标也会随之变化，所以当你想要在一个循环中用下标删除多个元素的时候，它并不会正常的生效。</p><p>也有些人知道以上代码的问题就由于数组下标变换引起的。所以，他们想到使用增强for循环的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>));</div><div class="line"><span class="keyword">for</span>(String s:list)&#123;</div><div class="line">    <span class="keyword">if</span>(s.equals(<span class="string">"a"</span>))&#123;</div><div class="line">        list.remove(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是，很不幸的是，以上代码会抛出<code>ConcurrentModificationException</code>，有趣的是，如果在remove操作后增加一个break，代码就不会报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>));</div><div class="line"><span class="keyword">for</span>(String s:list)&#123;</div><div class="line">    <span class="keyword">if</span>(s.equals(<span class="string">"a"</span>))&#123;</div><div class="line">        list.remove(s);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>迭代器（Iterator）是工作在一个独立的线程中，并且拥有一个 mutex 锁。 迭代器被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 迭代器会马上抛出java.util.ConcurrentModificationException 异常。</p></blockquote><p>所以，正确的在遍历过程中删除元素的方法应该是使用Iterator：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>));</div><div class="line">Iterator&lt;String&gt; iter = list.iterator();</div><div class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</div><div class="line">    String s = iter.next();</div><div class="line">    <span class="keyword">if</span> (s.equals(<span class="string">"a"</span>)) &#123;</div><div class="line">        iter.remove();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>next()方法必须在调用remove()方法之前调用。如果在循环过程中先调用remove()，再调用next()，就会导致异常ConcurrentModificationException。原因如上。</p><h3 id="HashTable-和-HashMap-的选择"><a href="#HashTable-和-HashMap-的选择" class="headerlink" title="HashTable 和 HashMap 的选择"></a>HashTable 和 HashMap 的选择</h3><p>了解算法的人可能对HashTable比较熟悉，因为他是一个数据结构的名字。但在Java里边，用HashMap来表示这样的数据结构。Hashtable和 HashMap的一个关键性的不同是，HashTable是同步的，而HashMap不是。所以通常不需要HashTable，HashMap用的更多。</p><h3 id="使用原始集合类型"><a href="#使用原始集合类型" class="headerlink" title="使用原始集合类型"></a>使用原始集合类型</h3><p>在 Java 里边，原始类型和无界通配符类型很容易混合在一起。以 Set 为例，<code>Set</code>是一个原始类型，而<code>Set&lt; ? &gt;</code>是一个无界通配符类型。 （可以把原始类型理解为没有使用泛型约束的类型）</p><p>考虑下面使用原始类型List作为参数的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(List list, Object o)</span></span>&#123;</div><div class="line">    list.add(o);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">    add(list, <span class="number">10</span>);</div><div class="line">    String s = list.get(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面的代码将会抛出异常：</p><p><code>java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</code></p><p>使用原始集合类型是很危险的，因为原始集合类型跳过了泛型类型检查，是不安全的。<code>Set</code>、<code>Set&lt; ? &gt;</code>和<code>Set&lt; Object &gt;</code>之间有很大差别。</p><h3 id="访问级别"><a href="#访问级别" class="headerlink" title="访问级别"></a>访问级别</h3><p>程序员们经常使用public作为类中的字段的修饰符，因为这样可以很简单的通过引用得到值，但这并不是好的设计，按照经验，分配给成员变量的访问级别应该尽可能的低。参考Java中的四种访问级别</p><h3 id="ArrayList与LinkedList的选择"><a href="#ArrayList与LinkedList的选择" class="headerlink" title="ArrayList与LinkedList的选择"></a>ArrayList与LinkedList的选择</h3><p>当程序员们不知道<code>ArrayList</code>与<code>LinkedList</code>的区别时，他们经常使用ArrayList，因为它看起来比较熟悉。然而，它们之前有巨大的性能差别。简而言之，如果有大量的增加删除操作并且没有很多的随机访问元素的操作，应该首先<code>LinkedList</code>。（<code>LinkedList</code>更适合从中间插入或者删除（链表的特性））</p><h3 id="可变与不可变"><a href="#可变与不可变" class="headerlink" title="可变与不可变"></a>可变与不可变</h3><p>不可变对象有许多的优点，比如简单，安全等等。同时，也有人提出疑问：既然不可变有这么多好处，为什么不把所有类都搞成不可变的呢？</p><p>通常情况下，可变对象可以用来避免产生过多的中间对象。一个经典的实例就是连接大量的字符串，如果使用不可变的字符串，将会产生大量的需要进行垃圾回收的对象。这会浪费CPU大量的时间，使用可变对象才是正确的方案(比如StringBuilder)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String result=<span class="string">""</span>;</div><div class="line"><span class="keyword">for</span>(String s: arr)&#123;</div><div class="line">    result = result + s;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="http://stackoverflow.com/questions/23616211/why-we-need-mutable-classes" target="_blank" rel="noopener">StackOverflow</a>中也有关于这个的讨论。</p><h3 id="父类和子类的构造函数"><a href="#父类和子类的构造函数" class="headerlink" title="父类和子类的构造函数"></a>父类和子类的构造函数</h3><p>上图的代码中有两处编译时错误，原因其实很简单，主要和构造函数有关。首先，我们都知道：如果一个类没有定义构造函数，编译器将会插入一个无参数的默认构造函数。如果一个类中定义了一个带参数的构造函数，那么编译器就不会再帮我们创建无参的构造函数。</p><p>上面的Super类中定义了一个带参数的构造函数。编译器将不会插入默认的无参数构造函数。</p><p>我们还应该知道：<br>子类的所有构造函数（无论是有参还是无参）在执行时，都会调用父类的无参构造函数。<br>所以，编译器试图调用Super类中的无参构造函数。但是父类默认的构造函数未定义，编译器就会报出这个错误信息。</p><p>要解决这个问题，可以简单的通过</p><ol><li>在父类中添加一个Super()构造方法，就像这样：</li></ol><p><code>public Super(){}</code></p><ol><li><p>移除自定义的父类构造函数</p></li><li><p>在子类的构造函数中调用父类的super(value)。</p></li></ol><h3 id="””还是构造函数"><a href="#””还是构造函数" class="headerlink" title="””还是构造函数"></a>””还是构造函数</h3><p>关于这个问题，也是经常容易出现困惑的地方。</p><p>其实，如果你只需要创建一个字符串，你可以使用双引号的方式，如果你需要在堆中创建一个新的对象，你可以选择构造函数的方式。</p><p>在String d = new String(“abcd”)时，因为字面值“abcd”已经是字符串类型，那么使用构造函数方式只会创建一个额外没有用处的对象。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;把数组转成ArrayList&quot;&gt;&lt;a href=&quot;#把数组转成ArrayList&quot; class=&quot;headerlink&quot; title=&quot;把数组转成ArrayList&quot;&gt;&lt;/a&gt;把数组转成ArrayList&lt;/h3&gt;&lt;p&gt;为了将数组转换为ArrayList，我们经常会这样做：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;List&amp;lt;String&amp;gt; list = Arrays.asList(arr);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用&lt;code&gt;Arrays.asList()&lt;/code&gt;方法可以得到一个&lt;code&gt;ArrayList&lt;/code&gt;，但是得到这个&lt;code&gt;ArrayList&lt;/code&gt;其实是定义在&lt;code&gt;Arrays&lt;/code&gt;类中的一个私有的静态内部类。这个类虽然和&lt;code&gt;java.util.ArrayList&lt;/code&gt;同名，但是并不是同一个类。我就曾经被深深地坑过…&lt;code&gt;java.util.Arrays.ArrayList&lt;/code&gt;类中实现了&lt;code&gt;set()&lt;/code&gt;, &lt;code&gt;get()&lt;/code&gt;, &lt;code&gt;contains()&lt;/code&gt;等方法，但是并没有定义向其中增加元素的方法。也就是说通过&lt;code&gt;Arrays.asList()&lt;/code&gt;得到的&lt;code&gt;ArrayList&lt;/code&gt;的大小是固定的。&lt;/p&gt;
&lt;p&gt;如果在开发过程中，想得到一个真正的&lt;code&gt;ArrayList&lt;/code&gt;对象（java.util.ArrayList的实例），可以通过以下方式：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ArrayList&amp;lt;String&amp;gt; arrayList = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;(Arrays.asList(arr));&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;java.util.ArrayList中包含一个可以接受集合类型参数的构造函数。因为java.util.Arrays.ArrayList这个内部类继承了AbstractList类，所以，该类也是Collection的子类。&lt;br&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://jihong.xyz/categories/programming/"/>
    
    
      <category term="Java" scheme="http://jihong.xyz/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中常见的问题</title>
    <link href="http://jihong.xyz/programming/Java%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://jihong.xyz/programming/Java中常见的问题/</id>
    <published>2016-03-30T11:42:21.000Z</published>
    <updated>2018-03-04T02:56:03.164Z</updated>
    
    <content type="html"><![CDATA[<h3 id="把数组转成ArrayList"><a href="#把数组转成ArrayList" class="headerlink" title="把数组转成ArrayList"></a>把数组转成ArrayList</h3><p>为了将数组转换为ArrayList，我们经常会这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list = Arrays.asList(arr);</div></pre></td></tr></table></figure><p>使用<code>Arrays.asList()</code>方法可以得到一个<code>ArrayList</code>，但是得到这个<code>ArrayList</code>其实是定义在<code>Arrays</code>类中的一个私有的静态内部类。这个类虽然和<code>java.util.ArrayList</code>同名，但是并不是同一个类。我就曾经被深深地坑过…<code>java.util.Arrays.ArrayList</code>类中实现了<code>set()</code>, <code>get()</code>, <code>contains()</code>等方法，但是并没有定义向其中增加元素的方法。也就是说通过<code>Arrays.asList()</code>得到的<code>ArrayList</code>的大小是固定的。</p><p>如果在开发过程中，想得到一个真正的<code>ArrayList</code>对象（java.util.ArrayList的实例），可以通过以下方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(arr));</div></pre></td></tr></table></figure><p>java.util.ArrayList中包含一个可以接受集合类型参数的构造函数。因为java.util.Arrays.ArrayList这个内部类继承了AbstractList类，所以，该类也是Collection的子类。<br><a id="more"></a></p><h3 id="判断一个数组是否包含某个值"><a href="#判断一个数组是否包含某个值" class="headerlink" title="判断一个数组是否包含某个值"></a>判断一个数组是否包含某个值</h3><p>在判断一个数组中是否包含某个值的时候，我们经常这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(arr));</div><div class="line">    <span class="keyword">return</span> set.contains(targetValue);</div></pre></td></tr></table></figure><p>以上方式虽然可以实现功能，但是效率却比较低。因为将数组压入Collection类型中，首先要将数组元素遍历一遍，然后再使用集合类做其他操作。</p><p>在判断一个数组是否包含某个值的时候，推荐使用for循环遍历的形式或者使用Apache Commons类库中提供的ArrayUtils类的contains方法。</p><h3 id="在循环中删除列表中的元素"><a href="#在循环中删除列表中的元素" class="headerlink" title="在循环中删除列表中的元素"></a>在循环中删除列表中的元素</h3><p>在讨论这个问题之前，先考虑以下代码的输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>));</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</div><div class="line">list.remove(i);</div><div class="line">&#125;</div><div class="line">System.out.println(list);</div></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[b,d]</div></pre></td></tr></table></figure><p>以上代码的目的是想遍历删除list中所有元素，但是结果却没有成功。原因是忽略了一个关键的问题：当一个元素被删除时，列表的大小缩小并且下标也会随之变化，所以当你想要在一个循环中用下标删除多个元素的时候，它并不会正常的生效。</p><p>也有些人知道以上代码的问题就由于数组下标变换引起的。所以，他们想到使用增强for循环的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>));</div><div class="line"><span class="keyword">for</span>(String s:list)&#123;</div><div class="line">    <span class="keyword">if</span>(s.equals(<span class="string">"a"</span>))&#123;</div><div class="line">        list.remove(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是，很不幸的是，以上代码会抛出<code>ConcurrentModificationException</code>，有趣的是，如果在remove操作后增加一个break，代码就不会报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>));</div><div class="line"><span class="keyword">for</span>(String s:list)&#123;</div><div class="line">    <span class="keyword">if</span>(s.equals(<span class="string">"a"</span>))&#123;</div><div class="line">        list.remove(s);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>迭代器（Iterator）是工作在一个独立的线程中，并且拥有一个 mutex 锁。 迭代器被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 迭代器会马上抛出java.util.ConcurrentModificationException 异常。</p></blockquote><p>所以，正确的在遍历过程中删除元素的方法应该是使用Iterator：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>));</div><div class="line">Iterator&lt;String&gt; iter = list.iterator();</div><div class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</div><div class="line">    String s = iter.next();</div><div class="line">    <span class="keyword">if</span> (s.equals(<span class="string">"a"</span>)) &#123;</div><div class="line">        iter.remove();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>next()方法必须在调用remove()方法之前调用。如果在循环过程中先调用remove()，再调用next()，就会导致异常ConcurrentModificationException。原因如上。</p><h3 id="HashTable-和-HashMap-的选择"><a href="#HashTable-和-HashMap-的选择" class="headerlink" title="HashTable 和 HashMap 的选择"></a>HashTable 和 HashMap 的选择</h3><p>了解算法的人可能对HashTable比较熟悉，因为他是一个数据结构的名字。但在Java里边，用HashMap来表示这样的数据结构。Hashtable和 HashMap的一个关键性的不同是，HashTable是同步的，而HashMap不是。所以通常不需要HashTable，HashMap用的更多。</p><h3 id="使用原始集合类型"><a href="#使用原始集合类型" class="headerlink" title="使用原始集合类型"></a>使用原始集合类型</h3><p>在 Java 里边，原始类型和无界通配符类型很容易混合在一起。以 Set 为例，<code>Set</code>是一个原始类型，而<code>Set&lt; ? &gt;</code>是一个无界通配符类型。 （可以把原始类型理解为没有使用泛型约束的类型）</p><p>考虑下面使用原始类型List作为参数的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(List list, Object o)</span></span>&#123;</div><div class="line">    list.add(o);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">    add(list, <span class="number">10</span>);</div><div class="line">    String s = list.get(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面的代码将会抛出异常：</p><p><code>java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</code></p><p>使用原始集合类型是很危险的，因为原始集合类型跳过了泛型类型检查，是不安全的。<code>Set</code>、<code>Set&lt; ? &gt;</code>和<code>Set&lt; Object &gt;</code>之间有很大差别。</p><h3 id="访问级别"><a href="#访问级别" class="headerlink" title="访问级别"></a>访问级别</h3><p>程序员们经常使用public作为类中的字段的修饰符，因为这样可以很简单的通过引用得到值，但这并不是好的设计，按照经验，分配给成员变量的访问级别应该尽可能的低。参考Java中的四种访问级别</p><h3 id="ArrayList与LinkedList的选择"><a href="#ArrayList与LinkedList的选择" class="headerlink" title="ArrayList与LinkedList的选择"></a>ArrayList与LinkedList的选择</h3><p>当程序员们不知道<code>ArrayList</code>与<code>LinkedList</code>的区别时，他们经常使用ArrayList，因为它看起来比较熟悉。然而，它们之前有巨大的性能差别。简而言之，如果有大量的增加删除操作并且没有很多的随机访问元素的操作，应该首先<code>LinkedList</code>。（<code>LinkedList</code>更适合从中间插入或者删除（链表的特性））</p><h3 id="可变与不可变"><a href="#可变与不可变" class="headerlink" title="可变与不可变"></a>可变与不可变</h3><p>不可变对象有许多的优点，比如简单，安全等等。同时，也有人提出疑问：既然不可变有这么多好处，为什么不把所有类都搞成不可变的呢？</p><p>通常情况下，可变对象可以用来避免产生过多的中间对象。一个经典的实例就是连接大量的字符串，如果使用不可变的字符串，将会产生大量的需要进行垃圾回收的对象。这会浪费CPU大量的时间，使用可变对象才是正确的方案(比如StringBuilder)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String result=<span class="string">""</span>;</div><div class="line"><span class="keyword">for</span>(String s: arr)&#123;</div><div class="line">    result = result + s;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="http://stackoverflow.com/questions/23616211/why-we-need-mutable-classes" target="_blank" rel="noopener">StackOverflow</a>中也有关于这个的讨论。</p><h3 id="父类和子类的构造函数"><a href="#父类和子类的构造函数" class="headerlink" title="父类和子类的构造函数"></a>父类和子类的构造函数</h3><p>上图的代码中有两处编译时错误，原因其实很简单，主要和构造函数有关。首先，我们都知道：如果一个类没有定义构造函数，编译器将会插入一个无参数的默认构造函数。如果一个类中定义了一个带参数的构造函数，那么编译器就不会再帮我们创建无参的构造函数。</p><p>上面的Super类中定义了一个带参数的构造函数。编译器将不会插入默认的无参数构造函数。</p><p>我们还应该知道：<br>子类的所有构造函数（无论是有参还是无参）在执行时，都会调用父类的无参构造函数。<br>所以，编译器试图调用Super类中的无参构造函数。但是父类默认的构造函数未定义，编译器就会报出这个错误信息。</p><p>要解决这个问题，可以简单的通过</p><ol><li>在父类中添加一个Super()构造方法，就像这样：</li></ol><p><code>public Super(){}</code></p><ol><li><p>移除自定义的父类构造函数</p></li><li><p>在子类的构造函数中调用父类的super(value)。</p></li></ol><h3 id="””还是构造函数"><a href="#””还是构造函数" class="headerlink" title="””还是构造函数"></a>””还是构造函数</h3><p>关于这个问题，也是经常容易出现困惑的地方。</p><p>其实，如果你只需要创建一个字符串，你可以使用双引号的方式，如果你需要在堆中创建一个新的对象，你可以选择构造函数的方式。</p><p>在String d = new String(“abcd”)时，因为字面值“abcd”已经是字符串类型，那么使用构造函数方式只会创建一个额外没有用处的对象。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;把数组转成ArrayList&quot;&gt;&lt;a href=&quot;#把数组转成ArrayList&quot; class=&quot;headerlink&quot; title=&quot;把数组转成ArrayList&quot;&gt;&lt;/a&gt;把数组转成ArrayList&lt;/h3&gt;&lt;p&gt;为了将数组转换为ArrayList，我们经常会这样做：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;List&amp;lt;String&amp;gt; list = Arrays.asList(arr);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用&lt;code&gt;Arrays.asList()&lt;/code&gt;方法可以得到一个&lt;code&gt;ArrayList&lt;/code&gt;，但是得到这个&lt;code&gt;ArrayList&lt;/code&gt;其实是定义在&lt;code&gt;Arrays&lt;/code&gt;类中的一个私有的静态内部类。这个类虽然和&lt;code&gt;java.util.ArrayList&lt;/code&gt;同名，但是并不是同一个类。我就曾经被深深地坑过…&lt;code&gt;java.util.Arrays.ArrayList&lt;/code&gt;类中实现了&lt;code&gt;set()&lt;/code&gt;, &lt;code&gt;get()&lt;/code&gt;, &lt;code&gt;contains()&lt;/code&gt;等方法，但是并没有定义向其中增加元素的方法。也就是说通过&lt;code&gt;Arrays.asList()&lt;/code&gt;得到的&lt;code&gt;ArrayList&lt;/code&gt;的大小是固定的。&lt;/p&gt;
&lt;p&gt;如果在开发过程中，想得到一个真正的&lt;code&gt;ArrayList&lt;/code&gt;对象（java.util.ArrayList的实例），可以通过以下方式：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ArrayList&amp;lt;String&amp;gt; arrayList = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;(Arrays.asList(arr));&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;java.util.ArrayList中包含一个可以接受集合类型参数的构造函数。因为java.util.Arrays.ArrayList这个内部类继承了AbstractList类，所以，该类也是Collection的子类。&lt;br&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://jihong.xyz/categories/programming/"/>
    
    
      <category term="Java" scheme="http://jihong.xyz/tags/Java/"/>
    
  </entry>
  
</feed>
